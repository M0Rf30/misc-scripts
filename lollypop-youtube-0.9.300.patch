diff --git a/.tx/config b/.tx/config
index 531af99e..b583344f 100644
--- a/.tx/config
+++ b/.tx/config
@@ -2,77 +2,77 @@
 host = https://www.transifex.com
 
 [lollypop.lollypop]
-file_filter = subprojects/po/<lang>.po
-source_file = subprojects/po/lollypop.pot
+file_filter = po/<lang>.po
+source_file = po/lollypop.pot
 source_lang = en
-trans.eo = subprojects/po/eo.po
-trans.fi = subprojects/po/fi.po
-trans.da = subprojects/po/da.po
-trans.de = subprojects/po/de.po
-trans.fr = subprojects/po/fr.po
-trans.it = subprojects/po/it.po
-trans.nl = subprojects/po/nl.po
-trans.ca = subprojects/po/ca.po
-trans.sk = subprojects/po/sk.po
-trans.cs = subprojects/po/cs.po
-trans.pt_PT = subprojects/po/pt_PT.po
-trans.pt_BR = subprojects/po/pt_BR.po
-trans.he = subprojects/po/he.po
-trans.ka = subprojects/po/ka.po
-trans.uk = subprojects/po/uk.po
-trans.sr = subprojects/po/sr.po
-trans.sr@latin = subprojects/po/sr@latin.po
-trans.ro = subprojects/po/ro.po
-trans.ru = subprojects/po/ru.po
-trans.es = subprojects/po/es.po
-trans.el = subprojects/po/el.po
-trans.pl = subprojects/po/pl.po
-trans.sv = subprojects/po/sv.po
-trans.tr_TR = subprojects/po/tr_TR.po
-trans.tr = subprojects/po/tr.po
-trans.en_IE = subprojects/po/en_IE.po
-trans.ga = subprojects/po/ga.po
-trans.hu = subprojects/po/hu.po
-trans.zh_CN = subprojects/po/zh_CN.po
-trans.es_EC = subprojects/po/es_EC.po
-trans.id = subprojects/po/id.po
-trans.lt = subprojects/po/lt.po
+trans.eo = po/eo.po
+trans.fi = po/fi.po
+trans.da = po/da.po
+trans.de = po/de.po
+trans.fr = po/fr.po
+trans.it = po/it.po
+trans.nl = po/nl.po
+trans.ca = po/ca.po
+trans.sk = po/sk.po
+trans.cs = po/cs.po
+trans.pt_PT = po/pt_PT.po
+trans.pt_BR = po/pt_BR.po
+trans.he = po/he.po
+trans.ka = po/ka.po
+trans.uk = po/uk.po
+trans.sr = po/sr.po
+trans.sr@latin = po/sr@latin.po
+trans.ro = po/ro.po
+trans.ru = po/ru.po
+trans.es = po/es.po
+trans.el = po/el.po
+trans.pl = po/pl.po
+trans.sv = po/sv.po
+trans.tr_TR = po/tr_TR.po
+trans.tr = po/tr.po
+trans.en_IE = po/en_IE.po
+trans.ga = po/ga.po
+trans.hu = po/hu.po
+trans.zh_CN = po/zh_CN.po
+trans.es_EC = po/es_EC.po
+trans.id = po/id.po
+trans.lt = po/lt.po
 type = PO
 
 [lollypop.help]
-file_filter = subprojects/help/<lang>.po
-source_file = subprojects/help/lollypop.pot
+file_filter = help/<lang>.po
+source_file = help/lollypop.pot
 source_lang = en
-trans.da = subprojects/help/da/da.po
-trans.de = subprojects/help/de/de.po
-trans.eo = subprojects/help/eo/eo.po
-trans.fr = subprojects/help/fr/fr.po
-trans.fi = subprojects/help/fi/fi.po
-trans.it = subprojects/help/it/it.po
-trans.nl = subprojects/help/nl/nl.po
-trans.ca = subprojects/help/ca/ca.po
-trans.sk = subprojects/help/sk/sk.po
-trans.cs = subprojects/help/cs/cs.po
-trans.pt_PT = subprojects/help/pt_PT/pt_PT.po
-trans.pt_BR = subprojects/help/pt_BR/pt_BR.po
-trans.he = subprojects/help/he/he.po
-trans.ka = subprojects/help/ka/ka.po
-trans.uk = subprojects/help/uk/uk.po
-trans.sr = subprojects/help/sr/sr.po
-trans.sr@latin = subprojects/help/sr/sr@latin.po
-trans.ro = subprojects/help/ro/ro.po
-trans.ru = subprojects/help/ru/ru.po
-trans.es = subprojects/help/es/es.po
-trans.el = subprojects/help/el/el.po
-trans.pl = subprojects/help/pl/pl.po
-trans.sv = subprojects/help/sv/sv.po
-trans.tr_TR = subprojects/help/tr_TR/tr_TR.po
-trans.tr = subprojects/help/tr/tr.po
-trans.en_IE = subprojects/help/en_IE/en_IE.po
-trans.ga = subprojects/help/ga/ga.po
-trans.hu = subprojects/help/hu/hu.po
-trans.zh_CN = subprojects/help/zh_CN/zh_CN.po
-trans.es_EC = subprojects/help/es_EC/es_EC.po
-trans.id = subprojects/help/id/id.po
-trans.lt = subprojects/help/lt/lt.po
+trans.da = help/da/da.po
+trans.de = help/de/de.po
+trans.eo = help/eo/eo.po
+trans.fr = help/fr/fr.po
+trans.fi = help/fi/fi.po
+trans.it = help/it/it.po
+trans.nl = help/nl/nl.po
+trans.ca = help/ca/ca.po
+trans.sk = help/sk/sk.po
+trans.cs = help/cs/cs.po
+trans.pt_PT = help/pt_PT/pt_PT.po
+trans.pt_BR = help/pt_BR/pt_BR.po
+trans.he = help/he/he.po
+trans.ka = help/ka/ka.po
+trans.uk = help/uk/uk.po
+trans.sr = help/sr/sr.po
+trans.sr@latin = help/sr/sr@latin.po
+trans.ro = help/ro/ro.po
+trans.ru = help/ru/ru.po
+trans.es = help/es/es.po
+trans.el = help/el/el.po
+trans.pl = help/pl/pl.po
+trans.sv = help/sv/sv.po
+trans.tr_TR = help/tr_TR/tr_TR.po
+trans.tr = help/tr/tr.po
+trans.en_IE = help/en_IE/en_IE.po
+trans.ga = help/ga/ga.po
+trans.hu = help/hu/hu.po
+trans.zh_CN = help/zh_CN/zh_CN.po
+trans.es_EC = help/es_EC/es_EC.po
+trans.id = help/id/id.po
+trans.lt = help/lt/lt.po
 type = PO
diff --git a/README.md b/README.md
index 467c3e98..ea4a7abc 100644
--- a/README.md
+++ b/README.md
@@ -1,7 +1,5 @@
 # Lollypop
 
-[![Join the chat at https://gitter.im/gnumdk/lollypop](https://badges.gitter.im/gnumdk/lollypop.svg)](https://gitter.im/gnumdk/lollypop?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)
-
 ![Lollypop logo](https://raw.github.com/gnumdk/lollypop/master/data/icons/hicolor/256x256/apps/org.gnome.Lollypop.png)
 
 Lollypop is a new GNOME music playing application.
diff --git a/data/ArtworkSearch.ui b/data/ArtworkSearch.ui
index 16951c9e..ed8097f9 100644
--- a/data/ArtworkSearch.ui
+++ b/data/ArtworkSearch.ui
@@ -218,9 +218,9 @@
           <object class="GtkLabel">
             <property name="visible">True</property>
             <property name="can_focus">False</property>
-            <property name="label" translatable="yes">&lt;b&gt;Lollypop uses the Google Custom Search API to search for images on the web.&lt;/b&gt;
-&lt;small&gt;This API is limited, so it may not work with the default API key.&lt;/small&gt;</property>
-            <property name="use_markup">True</property>
+            <property name="label" translatable="yes">Lollypop uses "Google Custom Search API" to search images on the web.
+This API is limited so it mays not work with default API key.
+Please create a "Custom Search Engine" here:</property>
           </object>
           <packing>
             <property name="left_attach">0</property>
@@ -236,20 +236,20 @@
             <property name="has_focus">True</property>
             <property name="has_default">True</property>
             <property name="receives_default">True</property>
-            <property name="halign">end</property>
+            <property name="halign">center</property>
             <property name="relief">none</property>
             <property name="uri">https://console.developers.google.com/apis/</property>
           </object>
           <packing>
-            <property name="left_attach">1</property>
+            <property name="left_attach">0</property>
             <property name="top_attach">1</property>
+            <property name="width">2</property>
           </packing>
         </child>
         <child>
           <object class="GtkLabel">
             <property name="visible">True</property>
             <property name="can_focus">False</property>
-            <property name="halign">start</property>
             <property name="label" translatable="yes">API key</property>
           </object>
           <packing>
@@ -257,25 +257,10 @@
             <property name="top_attach">2</property>
           </packing>
         </child>
-        <child>
-          <object class="GtkLabel">
-            <property name="visible">True</property>
-            <property name="can_focus">False</property>
-            <property name="halign">start</property>
-            <property name="label" translatable="yes">&lt;b&gt;Please create a "Custom Search Engine" here&lt;/b&gt;:</property>
-            <property name="use_markup">True</property>
-          </object>
-          <packing>
-            <property name="left_attach">0</property>
-            <property name="top_attach">1</property>
-            <property name="width">2</property>
-          </packing>
-        </child>
         <child>
           <object class="GtkEntry" id="api_entry">
             <property name="visible">True</property>
             <property name="can_focus">True</property>
-            <property name="valign">start</property>
             <property name="placeholder_text">AIzaSyAfXimyn-JsnPzAhhIuxYwgyMrj21Ee7e0</property>
             <signal name="changed" handler="_on_api_entry_changed" swapped="no"/>
           </object>
diff --git a/data/FirstRunView.ui b/data/FirstRunView.ui
index 64a4da1e..87d30b5c 100644
--- a/data/FirstRunView.ui
+++ b/data/FirstRunView.ui
@@ -29,7 +29,7 @@
         <property name="visible">True</property>
         <property name="can_focus">False</property>
         <property name="label" translatable="yes">&lt;b&gt;Welcome to Lollypop!&lt;/b&gt;
-Here you can enable network access, allowing Lollypop to fetch music information from the Web.</property>
+Here you can enable network access, allowing Lollypop to fetch music informations from the Web.</property>
         <property name="use_markup">True</property>
         <property name="wrap">True</property>
         <style>
diff --git a/data/FullScreen.ui b/data/FullScreen.ui
index 40295131..393326b7 100644
--- a/data/FullScreen.ui
+++ b/data/FullScreen.ui
@@ -1,23 +1,13 @@
 <?xml version="1.0" encoding="UTF-8"?>
-<!-- Generated with glade 3.20.0 -->
+<!-- Generated with glade 3.19.0 -->
 <interface>
   <requires lib="gtk+" version="3.12"/>
   <object class="GtkImage" id="close_image">
     <property name="visible">True</property>
     <property name="can_focus">False</property>
+    <property name="pixel_size">24</property>
     <property name="icon_name">window-close-symbolic</property>
-  </object>
-  <object class="GtkButton" id="close_btn">
-    <property name="visible">True</property>
-    <property name="can_focus">True</property>
-    <property name="receives_default">True</property>
-    <property name="margin_left">3</property>
-    <property name="margin_right">3</property>
-    <property name="margin_end">5</property>
-    <property name="margin_top">5</property>
-    <property name="image">close_image</property>
-    <property name="relief">none</property>
-    <signal name="clicked" handler="_on_close_button_clicked" swapped="no"/>
+    <property name="icon_size">1</property>
   </object>
   <object class="GtkImage" id="next_image">
     <property name="visible">True</property>
@@ -115,6 +105,23 @@
         <property name="width">2</property>
       </packing>
     </child>
+    <child>
+      <object class="GtkButton" id="close_btn">
+        <property name="visible">True</property>
+        <property name="can_focus">True</property>
+        <property name="receives_default">True</property>
+        <property name="halign">end</property>
+        <property name="valign">start</property>
+        <property name="margin_end">5</property>
+        <property name="margin_top">5</property>
+        <property name="image">close_image</property>
+        <property name="relief">none</property>
+      </object>
+      <packing>
+        <property name="left_attach">2</property>
+        <property name="top_attach">0</property>
+      </packing>
+    </child>
     <child>
       <object class="GtkBox" id="box2">
         <property name="visible">True</property>
@@ -279,9 +286,6 @@
     <child>
       <placeholder/>
     </child>
-    <child>
-      <placeholder/>
-    </child>
   </object>
   <object class="GtkSizeGroup" id="sizegroup1">
     <property name="mode">vertical</property>
diff --git a/data/SearchPopover.ui b/data/SearchPopover.ui
index c2af5ffa..bbfd9b3b 100644
--- a/data/SearchPopover.ui
+++ b/data/SearchPopover.ui
@@ -84,5 +84,44 @@
         <property name="top_attach">0</property>
       </packing>
     </child>
+    <child>
+      <object class="GtkGrid">
+        <property name="visible">True</property>
+        <property name="can_focus">False</property>
+        <property name="halign">end</property>
+        <child>
+          <object class="GtkLabel">
+            <property name="visible">True</property>
+            <property name="can_focus">False</property>
+            <property name="halign">end</property>
+            <property name="label" translatable="yes">Search on the web</property>
+          </object>
+          <packing>
+            <property name="left_attach">0</property>
+            <property name="top_attach">0</property>
+          </packing>
+        </child>
+        <child>
+          <object class="GtkSwitch" id="search-switch">
+            <property name="visible">True</property>
+            <property name="can_focus">True</property>
+            <property name="margin_left">5</property>
+            <property name="margin_right">5</property>
+            <property name="margin_top">5</property>
+            <property name="margin_bottom">5</property>
+            <signal name="state-set" handler="_on_state_set" swapped="no"/>
+          </object>
+          <packing>
+            <property name="left_attach">1</property>
+            <property name="top_attach">0</property>
+          </packing>
+        </child>
+      </object>
+      <packing>
+        <property name="left_attach">0</property>
+        <property name="top_attach">2</property>
+        <property name="width">2</property>
+      </packing>
+    </child>
   </object>
 </interface>
diff --git a/data/SettingsDialog.ui b/data/SettingsDialog.ui
index 17865f17..4fca8850 100644
--- a/data/SettingsDialog.ui
+++ b/data/SettingsDialog.ui
@@ -105,7 +105,6 @@
   <object class="GtkWindow" id="settings_dialog">
     <property name="can_focus">False</property>
     <property name="title" translatable="yes">Preferences</property>
-    <property name="resizable">False</property>
     <property name="modal">True</property>
     <property name="window_position">center-on-parent</property>
     <property name="destroy_with_parent">True</property>
@@ -121,10 +120,7 @@
           <object class="GtkGrid" id="grid_appearance">
             <property name="visible">True</property>
             <property name="can_focus">False</property>
-            <property name="halign">center</property>
-            <property name="valign">center</property>
-            <property name="margin_left">10</property>
-            <property name="margin_right">10</property>
+            <property name="halign">start</property>
             <property name="margin_start">10</property>
             <property name="margin_end">10</property>
             <property name="margin_top">10</property>
@@ -310,10 +306,7 @@
           <object class="GtkGrid" id="grid_behaviour">
             <property name="visible">True</property>
             <property name="can_focus">False</property>
-            <property name="halign">center</property>
-            <property name="valign">center</property>
-            <property name="margin_left">10</property>
-            <property name="margin_right">10</property>
+            <property name="halign">start</property>
             <property name="margin_start">10</property>
             <property name="margin_end">10</property>
             <property name="margin_top">10</property>
@@ -459,7 +452,7 @@
               </object>
               <packing>
                 <property name="left_attach">0</property>
-                <property name="top_attach">6</property>
+                <property name="top_attach">5</property>
               </packing>
             </child>
             <child>
@@ -476,15 +469,9 @@
               </object>
               <packing>
                 <property name="left_attach">1</property>
-                <property name="top_attach">6</property>
+                <property name="top_attach">5</property>
               </packing>
             </child>
-            <child>
-              <placeholder/>
-            </child>
-            <child>
-              <placeholder/>
-            </child>
           </object>
           <packing>
             <property name="position">1</property>
@@ -639,10 +626,31 @@
                             <property name="visible">True</property>
                             <property name="can_focus">False</property>
                             <child>
-                              <placeholder/>
+                              <object class="GtkLabel">
+                                <property name="visible">True</property>
+                                <property name="can_focus">False</property>
+                                <property name="halign">start</property>
+                                <property name="hexpand">True</property>
+                                <property name="label" translatable="yes">The charts</property>
+                              </object>
+                              <packing>
+                                <property name="expand">False</property>
+                                <property name="fill">True</property>
+                                <property name="position">0</property>
+                              </packing>
                             </child>
                             <child>
-                              <placeholder/>
+                              <object class="GtkSwitch" id="switch_charts">
+                                <property name="visible">True</property>
+                                <property name="can_focus">True</property>
+                                <property name="halign">end</property>
+                                <signal name="state-set" handler="_update_charts_setting" swapped="no"/>
+                              </object>
+                              <packing>
+                                <property name="expand">False</property>
+                                <property name="fill">True</property>
+                                <property name="position">1</property>
+                              </packing>
                             </child>
                           </object>
                           <packing>
@@ -687,7 +695,6 @@
                 <property name="visible">True</property>
                 <property name="can_focus">False</property>
                 <property name="halign">center</property>
-                <property name="margin_bottom">10</property>
                 <property name="row_spacing">5</property>
                 <property name="column_spacing">5</property>
                 <child>
@@ -791,25 +798,18 @@
             <property name="can_focus">True</property>
             <property name="tab_pos">left</property>
             <child>
-              <object class="GtkGrid" id="lastfm_grid">
+              <object class="GtkGrid">
                 <property name="visible">True</property>
-                <property name="sensitive">False</property>
                 <property name="can_focus">False</property>
                 <property name="halign">center</property>
                 <property name="valign">center</property>
-                <property name="margin_left">10</property>
-                <property name="margin_right">10</property>
-                <property name="margin_top">10</property>
-                <property name="margin_bottom">10</property>
-                <property name="row_spacing">20</property>
-                <property name="column_spacing">20</property>
+                <property name="row_spacing">10</property>
+                <property name="column_spacing">10</property>
                 <child>
-                  <object class="GtkLabel" id="label6">
+                  <object class="GtkLabel" id="spotify_label">
                     <property name="visible">True</property>
                     <property name="can_focus">False</property>
-                    <property name="halign">start</property>
-                    <property name="label" translatable="yes">Login:</property>
-                    <property name="ellipsize">end</property>
+                    <property name="label" translatable="yes">Spotify</property>
                   </object>
                   <packing>
                     <property name="left_attach">0</property>
@@ -817,11 +817,10 @@
                   </packing>
                 </child>
                 <child>
-                  <object class="GtkLabel" id="label7">
+                  <object class="GtkLabel" id="itunes_label">
                     <property name="visible">True</property>
                     <property name="can_focus">False</property>
-                    <property name="halign">start</property>
-                    <property name="label" translatable="yes">Password:</property>
+                    <property name="label" translatable="yes">Itunes</property>
                   </object>
                   <packing>
                     <property name="left_attach">0</property>
@@ -829,97 +828,66 @@
                   </packing>
                 </child>
                 <child>
-                  <object class="GtkEntry" id="lastfm_login">
+                  <object class="GtkSwitch" id="switch_spotify">
                     <property name="visible">True</property>
                     <property name="can_focus">True</property>
-                    <property name="halign">center</property>
+                    <property name="tooltip_text" translatable="yes">Search tracks on Spotify</property>
+                    <property name="halign">end</property>
+                    <signal name="state-set" handler="_update_spotify_setting" swapped="no"/>
                   </object>
                   <packing>
                     <property name="left_attach">1</property>
                     <property name="top_attach">1</property>
-                    <property name="width">2</property>
                   </packing>
                 </child>
                 <child>
-                  <object class="GtkEntry" id="lastfm_password">
+                  <object class="GtkSwitch" id="switch_itunes">
                     <property name="visible">True</property>
                     <property name="can_focus">True</property>
-                    <property name="halign">center</property>
-                    <property name="visibility">False</property>
-                    <property name="invisible_char">●</property>
-                    <property name="input_purpose">password</property>
+                    <property name="tooltip_text" translatable="yes">Search tracks on Itunes</property>
+                    <property name="halign">end</property>
+                    <signal name="state-set" handler="_update_itunes_setting" swapped="no"/>
                   </object>
                   <packing>
                     <property name="left_attach">1</property>
                     <property name="top_attach">2</property>
-                    <property name="width">2</property>
-                  </packing>
-                </child>
-                <child>
-                  <object class="GtkButton" id="connect_btn">
-                    <property name="label" translatable="yes">Connect</property>
-                    <property name="visible">True</property>
-                    <property name="can_focus">True</property>
-                    <property name="receives_default">True</property>
-                    <property name="valign">center</property>
-                    <signal name="clicked" handler="_on_lastfm_test_btn_clicked" swapped="no"/>
-                  </object>
-                  <packing>
-                    <property name="left_attach">1</property>
-                    <property name="top_attach">3</property>
-                  </packing>
-                </child>
-                <child>
-                  <object class="GtkImage" id="lastfm_test_image">
-                    <property name="visible">True</property>
-                    <property name="can_focus">False</property>
-                    <property name="valign">center</property>
-                  </object>
-                  <packing>
-                    <property name="left_attach">2</property>
-                    <property name="top_attach">3</property>
                   </packing>
                 </child>
                 <child>
-                  <object class="GtkLabel" id="lastfm_error_label">
-                    <property name="visible">True</property>
+                  <object class="GtkLabel" id="yt-dl">
                     <property name="can_focus">False</property>
-                    <property name="label" translatable="yes">You need to install pylast and gi secret</property>
+                    <property name="label" translatable="yes">You need to install youtube-dl</property>
                   </object>
                   <packing>
                     <property name="left_attach">0</property>
                     <property name="top_attach">0</property>
-                    <property name="width">3</property>
+                    <property name="width">2</property>
                   </packing>
                 </child>
-                <child>
-                  <placeholder/>
-                </child>
               </object>
             </child>
             <child type="tab">
               <object class="GtkLabel">
                 <property name="visible">True</property>
                 <property name="can_focus">False</property>
-                <property name="label">Last.fm</property>
+                <property name="label" translatable="yes">Search</property>
               </object>
               <packing>
+                <property name="position">2</property>
                 <property name="tab_fill">False</property>
               </packing>
             </child>
             <child>
-              <object class="GtkGrid" id="librefm_grid">
+              <object class="GtkGrid" id="lastfm_grid">
                 <property name="visible">True</property>
                 <property name="sensitive">False</property>
                 <property name="can_focus">False</property>
                 <property name="halign">center</property>
-                <property name="valign">center</property>
-                <property name="margin_top">10</property>
-                <property name="margin_bottom">10</property>
+                <property name="margin_top">40</property>
                 <property name="row_spacing">20</property>
                 <property name="column_spacing">20</property>
                 <child>
-                  <object class="GtkLabel" id="label3">
+                  <object class="GtkLabel" id="label6">
                     <property name="visible">True</property>
                     <property name="can_focus">False</property>
                     <property name="halign">start</property>
@@ -932,7 +900,7 @@
                   </packing>
                 </child>
                 <child>
-                  <object class="GtkLabel" id="label5">
+                  <object class="GtkLabel" id="label7">
                     <property name="visible">True</property>
                     <property name="can_focus">False</property>
                     <property name="halign">start</property>
@@ -944,7 +912,7 @@
                   </packing>
                 </child>
                 <child>
-                  <object class="GtkEntry" id="librefm_login">
+                  <object class="GtkEntry" id="login">
                     <property name="visible">True</property>
                     <property name="can_focus">True</property>
                     <property name="halign">center</property>
@@ -956,7 +924,7 @@
                   </packing>
                 </child>
                 <child>
-                  <object class="GtkEntry" id="librefm_password">
+                  <object class="GtkEntry" id="password">
                     <property name="visible">True</property>
                     <property name="can_focus">True</property>
                     <property name="halign">center</property>
@@ -971,32 +939,32 @@
                   </packing>
                 </child>
                 <child>
-                  <object class="GtkButton" id="connect_btn1">
+                  <object class="GtkButton" id="connect_btn">
                     <property name="label" translatable="yes">Connect</property>
                     <property name="visible">True</property>
                     <property name="can_focus">True</property>
                     <property name="receives_default">True</property>
                     <property name="valign">center</property>
-                    <signal name="clicked" handler="_on_librefm_test_btn_clicked" swapped="no"/>
+                    <signal name="clicked" handler="_on_test_btn_clicked" swapped="no"/>
                   </object>
                   <packing>
                     <property name="left_attach">1</property>
-                    <property name="top_attach">3</property>
+                    <property name="top_attach">4</property>
                   </packing>
                 </child>
                 <child>
-                  <object class="GtkImage" id="librefm_test_image">
+                  <object class="GtkImage" id="test_img">
                     <property name="visible">True</property>
                     <property name="can_focus">False</property>
                     <property name="valign">center</property>
                   </object>
                   <packing>
                     <property name="left_attach">2</property>
-                    <property name="top_attach">3</property>
+                    <property name="top_attach">4</property>
                   </packing>
                 </child>
                 <child>
-                  <object class="GtkLabel" id="librefm_error_label">
+                  <object class="GtkLabel" id="lastfm_error">
                     <property name="visible">True</property>
                     <property name="can_focus">False</property>
                     <property name="label" translatable="yes">You need to install pylast and gi secret</property>
@@ -1007,6 +975,33 @@
                     <property name="width">3</property>
                   </packing>
                 </child>
+                <child>
+                  <object class="GtkLabel">
+                    <property name="visible">True</property>
+                    <property name="can_focus">False</property>
+                    <property name="halign">start</property>
+                    <property name="label" translatable="yes">Use Libre.fm</property>
+                  </object>
+                  <packing>
+                    <property name="left_attach">0</property>
+                    <property name="top_attach">3</property>
+                  </packing>
+                </child>
+                <child>
+                  <object class="GtkSwitch" id="switch_librefm">
+                    <property name="visible">True</property>
+                    <property name="can_focus">True</property>
+                    <property name="halign">start</property>
+                    <signal name="state-set" handler="_update_librefm_setting" swapped="no"/>
+                  </object>
+                  <packing>
+                    <property name="left_attach">1</property>
+                    <property name="top_attach">3</property>
+                  </packing>
+                </child>
+                <child>
+                  <placeholder/>
+                </child>
                 <child>
                   <placeholder/>
                 </child>
@@ -1019,7 +1014,7 @@
               <object class="GtkLabel">
                 <property name="visible">True</property>
                 <property name="can_focus">False</property>
-                <property name="label" translatable="yes">Libre.fm</property>
+                <property name="label">Last.fm</property>
               </object>
               <packing>
                 <property name="position">1</property>
@@ -1031,7 +1026,6 @@
                 <property name="visible">True</property>
                 <property name="can_focus">False</property>
                 <property name="halign">center</property>
-                <property name="valign">center</property>
                 <property name="margin_left">10</property>
                 <property name="margin_right">10</property>
                 <property name="margin_top">10</property>
@@ -1042,11 +1036,12 @@
                   <object class="GtkLabel">
                     <property name="visible">True</property>
                     <property name="can_focus">False</property>
-                    <property name="halign">start</property>
-                    <property name="label" translatable="yes">&lt;b&gt;Google Web Services require an API key.&lt;/b&gt;
-&lt;small&gt;Otherwise you will soon reach the default quota…
-Lollypop needs this to search for artwork.&lt;/small&gt;</property>
-                    <property name="use_markup">True</property>
+                    <property name="halign">center</property>
+                    <property name="margin_top">10</property>
+                    <property name="label" translatable="yes">Google Web Services need a custom API key.
+Without one, you will reach default quota soon…
+Lollypop needs this to search artwork and music.</property>
+                    <property name="justify">center</property>
                   </object>
                   <packing>
                     <property name="left_attach">0</property>
@@ -1058,7 +1053,6 @@ Lollypop needs this to search for artwork.&lt;/small&gt;</property>
                   <object class="GtkEntry" id="cs-entry">
                     <property name="visible">True</property>
                     <property name="can_focus">True</property>
-                    <property name="halign">start</property>
                     <property name="placeholder_text">AIzaSyAfXimyn-JsnPzAhhIuxYwgyMrj21Ee7e0</property>
                     <signal name="changed" handler="_on_cs_api_changed" swapped="no"/>
                   </object>
@@ -1073,7 +1067,6 @@ Lollypop needs this to search for artwork.&lt;/small&gt;</property>
                     <property name="visible">True</property>
                     <property name="can_focus">True</property>
                     <property name="receives_default">True</property>
-                    <property name="halign">start</property>
                     <property name="relief">none</property>
                     <property name="uri">https://console.developers.google.com/apis/</property>
                   </object>
@@ -1086,9 +1079,9 @@ Lollypop needs this to search for artwork.&lt;/small&gt;</property>
                   <object class="GtkLabel">
                     <property name="visible">True</property>
                     <property name="can_focus">False</property>
-                    <property name="halign">start</property>
-                    <property name="label" translatable="yes">&lt;small&gt;You need to enable "Custom Search API"  for your project.&lt;/small&gt;</property>
-                    <property name="use_markup">True</property>
+                    <property name="label" translatable="yes">You need to enable "Custom Search API" 
+and "YouTube Data API" for your project.</property>
+                    <property name="justify">center</property>
                     <style>
                       <class name="dim-label"/>
                     </style>
@@ -1108,19 +1101,13 @@ Lollypop needs this to search for artwork.&lt;/small&gt;</property>
               <object class="GtkLabel">
                 <property name="visible">True</property>
                 <property name="can_focus">False</property>
-                <property name="label" translatable="yes">Search</property>
+                <property name="label" translatable="yes">Google</property>
               </object>
               <packing>
                 <property name="position">2</property>
                 <property name="tab_fill">False</property>
               </packing>
             </child>
-            <child>
-              <placeholder/>
-            </child>
-            <child type="tab">
-              <placeholder/>
-            </child>
             <child type="action-start">
               <placeholder/>
             </child>
diff --git a/data/ToolbarPlayback.ui b/data/ToolbarPlayback.ui
index a91f2371..fa5350ae 100644
--- a/data/ToolbarPlayback.ui
+++ b/data/ToolbarPlayback.ui
@@ -45,6 +45,12 @@
             <property name="always_show_image">True</property>
             <property name="tooltip_text" translatable="yes">Play</property>
             <child>
+              <object class="GtkImage" id="pause_image">
+                <property name="visible">True</property>
+                <property name="can_focus">False</property>
+                <property name="icon_name">media-playback-pause-symbolic</property>
+                <property name="icon_size">1</property>
+              </object>
               <object class="GtkImage" id="play_image">
                 <property name="visible">True</property>
                 <property name="can_focus">False</property>
@@ -90,10 +96,4 @@
           <class name="linked"/>
         </style>
       </object>
-     <object class="GtkImage" id="pause_image">
-                <property name="visible">True</property>
-                <property name="can_focus">False</property>
-                <property name="icon_name">media-playback-pause-symbolic</property>
-                <property name="icon_size">1</property>
-              </object>
 </interface>
diff --git a/data/application-legacy.css b/data/application-legacy.css
new file mode 100644
index 00000000..dec8db10
--- /dev/null
+++ b/data/application-legacy.css
@@ -0,0 +1,373 @@
+GtkWidget {
+	outline-width: 0px;
+    text-shadow: none;
+}
+
+GtkTreeView {
+    padding: 2px 2px 2px 2px;
+}
+
+GtkTreeView:selected:hover {
+        background-color: shade(@theme_selected_bg_color, 0.9);
+        color: @theme_selected_fg_color;
+}
+
+GtkTreeView:hover {
+    background-color: alpha(@theme_fg_color, 0.05);
+    color: @theme_fg_color;
+}
+
+GtkTreeView.separator {
+    color: alpha(@theme_fg_color, 0.1);
+}
+
+GtkTreeView .image{
+    color: alpha(@theme_fg_color, 0.8);
+}
+
+GtkTreeView .image:backdrop{
+    color: alpha(@theme_fg_color, 0.6);
+}
+
+GtkTreeView .image:selected{
+    color: @theme_selected_fg_color;
+}
+
+Gtk.ListBoxRow .loved-button {
+	border-color: transparent;
+	background-color: transparent;
+	color: transparent;
+}
+
+Gtk.ListBoxRow .loved-button:hover {
+	border-color: alpha(@theme_fg_color, 0.1);
+}
+
+Gtk.ListBoxRow .menu-button {
+	border-color: transparent;
+	background-color: transparent;
+	color: transparent;
+}
+
+Gtk.ListBoxRow .menu-button:hover {
+	border-color: alpha(@theme_fg_color, 0.1);
+}
+
+.box-shadow {
+    box-shadow: 1px 1px 5px 5px alpha(black, 0.4);
+}
+
+.loading {
+    background-color: shade(@theme_bg_color, 1.2);
+    border: 1px solid @theme_bg_color;
+}
+
+.selected {
+    color: @theme_selected_bg_color;
+}
+
+.osd-popover {
+    opacity: 0.95;
+}
+
+.no-border {
+    border: none;
+    background-image: none;
+}
+
+.lollypop-title {
+    font-weight: bold;
+    font-size: smaller;
+    padding: 0px 12px;
+}
+
+.lollypop-subtitle {
+    font-size: smaller;
+    padding: 0px 12px;
+}
+
+.white {
+    background-color: white;
+    border-radius: 4px;
+}
+
+.black {
+    background-color: black;
+}
+
+.header-borders {
+    border: 1px solid shade(@theme_bg_color, 0.7);
+    border-radius: 4px;
+    border-top: none;
+    border-left: none;
+    border-top-left-radius: 0px;
+    border-bottom-left-radius: 0px;
+    border-top-right-radius: 0px;
+    background-color: @theme_bg_color;
+}
+
+.header {
+    border: 1px solid alpha(@theme_bg_color, 0);
+    border-radius: 4px;
+    border-top-left-radius: 0px;
+    border-top-right-radius: 0px;
+}
+
+.header:hover {
+    border: 1px solid shade(@theme_bg_color, 0.7);
+    border-radius: 4px;
+    border-top-left-radius: 0px;
+    border-top-right-radius: 0px;
+    background-color: shade(@theme_bg_color, 0.95);
+}
+
+.header-dim {
+    color: alpha(@theme_fg_color, 0.7); 
+}
+
+.cover-frame {
+    border: 1px solid shade(@theme_bg_color, 0.7);
+    background-color: shade(@theme_bg_color, 1.5);
+    padding: 3px;
+    border-radius: 2px;
+}
+
+.small-cover-frame {
+    border-radius: 1px;
+    border: 1px solid shade(@theme_bg_color, 0.7);
+}
+
+.small-cover-web {
+    border-radius: 1px;
+    border: 1px solid alpha(red, 0.5);
+}
+
+.cover-frame-web {
+    border-color: alpha(red, 0.3);
+    background-color: alpha(red, 0.3);
+}
+
+.cover-frame-selected {
+    border-color: @theme_selected_bg_color;
+    background-color: @theme_selected_bg_color;
+}
+
+.artwork-icon {
+    border: 2px solid #bebebe;
+    background-color: white;
+    color: #bebebe;
+    border-radius: 20px;
+}
+
+.rounded-icon {
+    transition: 70ms linear;
+    border: 3px solid white;
+    background-color: black;
+    color: white;
+    padding: 12px;
+    opacity: 0.7;
+    border-radius: 30px;
+}
+
+.rounded-icon-small {
+    transition: 70ms linear;
+    border: 2px solid white;
+    background-color: black;
+    color: white;
+    opacity: 0.7;
+    padding: 5px;
+    border-radius: 16px;
+}
+
+.squared-icon {
+    transition:70ms linear;
+    border: 2px solid white;
+    background-color: black;
+    color: white;
+    opacity: 0.7;
+    padding: 5px;
+    border-radius: 5px;
+}
+
+.no-padding {
+    padding: 0px;
+}
+
+.fastscroll {
+    padding: 2px;
+    background-color: @theme_bg_color;
+    border: 1px solid shade(@theme_bg_color, 0.7);
+    border-right: none;
+    border-radius: 2px;
+    border-top-right-radius: 0px;
+    border-bottom-right-radius: 0px;
+}
+
+.queued {
+    border-radius: 5px;
+    color: @theme_selected_fg_color;
+    background-color: @theme_selected_bg_color;
+}
+
+.drag-up {
+    background-image: -gtk-gradient (linear,
+                                     left top,
+                                     left bottom,
+                                     from (@theme_bg_color),
+                                     color-stop (0.9, @theme_bg_color),
+                                     to (@theme_selected_bg_color));
+}
+
+.drag-down {
+    background-image: -gtk-gradient (linear,
+                                     left top,
+                                     left bottom,
+                                     from (@theme_selected_bg_color),
+                                     color-stop (0.1, @theme_bg_color),
+                                     to (@theme_bg_color));
+}
+
+.trackswidget {
+	background-color: transparent;
+}
+
+.trackrow {
+    padding: 0px;
+	background-color: transparent;
+  	color: inherit;
+}
+
+.trackrow:hover {
+    border-radius: 5px;
+    outline-radius: 5px;
+	background-color: alpha(@theme_fg_color, 0.05);
+  	color: inherit;
+}
+
+.trackrow:selected {
+    border-radius: 5px;
+    outline-radius: 5px;
+	background-color: alpha(@theme_fg_color, 0.07);
+  	color: inherit;
+}
+
+.trackrowplaying {
+    border-radius: 5px;
+    outline-radius: 5px;
+    padding: 0px;
+	background-color: alpha(@theme_fg_color, 0.07);
+  	color: inherit;
+}
+
+.trackrowplaying .loved-button {
+	background-color: transparent;
+	border-color: transparent;
+	color: transparent;
+}
+
+.trackrowplaying:hover .loved-button {
+	border-color: transparent;
+	color: inherit;
+}
+
+.trackrowplaying:hover .loved-button:hover {
+	border-color: alpha(#000000, 0.1);
+}
+
+.trackrowplaying .menu-button {
+	background-color: transparent;
+    border-color: transparent;
+  	color: transparent;
+}
+
+.trackrowplaying:hover .menu-button {
+	border-color: transparent;
+  	color: inherit;
+}
+
+.trackrowplaying:hover .menu-button:hover {
+	border-color: alpha(#000000, 0.1);
+}
+
+.trackrow .loved-button {
+	border-color: transparent;
+	background-color: transparent;
+	color: transparent;
+}
+
+.trackrow .menu-button {
+	border-color: transparent;
+	background-color: transparent;
+	color: transparent;
+}
+
+.trackrow:hover .loved-button {
+	color: inherit;
+}
+
+.trackrow:hover .menu-button {
+  	color: inherit;
+}
+
+.trackrow:hover .loved-button:hover {
+	border-color: alpha(@theme_fg_color, 0.1);
+}
+
+.trackrow:hover .menu-button:hover {
+	border-color: alpha(@theme_fg_color, 0.1);
+}
+
+.album-menu-selected .album-menu-button{
+	border-color: alpha(@theme_fg_color, 0.1);
+  	color: inherit;
+}
+
+.track-menu-selected {
+	background-color: alpha(@theme_fg_color, 0.03);
+  	color: inherit;
+}
+
+.track-menu-selected .track-loved-button {
+	border-color: alpha(@theme_fg_color, 0.1);
+	color: inherit;
+}
+
+.track-menu-selected .track-menu-button {
+	border-color: alpha(@theme_fg_color, 0.1);
+  	color: inherit;
+}
+
+.menu-button {
+	box-shadow: none;
+	padding-left: 8px;
+	padding-right: 8px;
+	padding-top: 0px;
+	padding-bottom: 0px;
+	background-image: none;
+	border-style: solid;
+	border-image-source: none;
+    border-bottom-width: 1px;
+    border-top-width: 1px;
+    border-left-width: 1px;
+    border-right-width: 1px;
+    border-color: transparent;
+    color: inherit;
+}
+
+.menu-button:hover {
+    border-color: alpha(@theme_fg_color, 0.1);
+  	color: inherit;
+}
+
+.loved-button {
+	box-shadow: none;
+	padding-top: 0px;
+	padding-bottom: 0px;
+	background-image: none;
+	color: inherit;
+}
+
+.loved-button:hover {
+	border-color: alpha(@theme_fg_color, 0.1);
+	color: inherit;
+}
diff --git a/data/icons/hicolor/scalable/places/lollypop-itunes-symbolic.svg b/data/icons/hicolor/scalable/places/lollypop-itunes-symbolic.svg
new file mode 100644
index 00000000..f7a291e8
--- /dev/null
+++ b/data/icons/hicolor/scalable/places/lollypop-itunes-symbolic.svg
@@ -0,0 +1,142 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no"?>
+<!-- Created with Inkscape (http://www.inkscape.org/) -->
+
+<svg
+   xmlns:dc="http://purl.org/dc/elements/1.1/"
+   xmlns:cc="http://creativecommons.org/ns#"
+   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
+   xmlns:svg="http://www.w3.org/2000/svg"
+   xmlns="http://www.w3.org/2000/svg"
+   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
+   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
+   sodipodi:docname="lollypop-itunes.svg"
+   inkscape:export-filename="/home/sam/dev/RESOURCES/gnome-icon-theme-symbolic/src/gnome-stencils.png"
+   inkscape:export-xdpi="90"
+   inkscape:export-ydpi="90"
+   height="17.066668"
+   id="svg7384"
+   version="1.1"
+   inkscape:version="0.92.0 r"
+   width="17.066668">
+  <metadata
+     id="metadata90">
+    <rdf:RDF>
+      <cc:Work
+         rdf:about="">
+        <dc:format>image/svg+xml</dc:format>
+        <dc:type
+           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
+        <dc:title>Gnome Symbolic Icon Theme</dc:title>
+      </cc:Work>
+    </rdf:RDF>
+  </metadata>
+  <sodipodi:namedview
+     inkscape:bbox-nodes="false"
+     inkscape:bbox-paths="true"
+     bordercolor="#666666"
+     borderopacity="1"
+     inkscape:current-layer="layer12"
+     inkscape:cx="28.280122"
+     inkscape:cy="-1.3505051"
+     gridtolerance="10"
+     inkscape:guide-bbox="true"
+     guidetolerance="10"
+     id="namedview88"
+     inkscape:object-nodes="false"
+     inkscape:object-paths="false"
+     objecttolerance="10"
+     pagecolor="#3a3b39"
+     inkscape:pageopacity="1"
+     inkscape:pageshadow="2"
+     showborder="false"
+     showgrid="false"
+     showguides="true"
+     inkscape:snap-bbox="true"
+     inkscape:snap-bbox-midpoints="false"
+     inkscape:snap-global="true"
+     inkscape:snap-grids="true"
+     inkscape:snap-nodes="true"
+     inkscape:snap-others="false"
+     inkscape:snap-to-guides="true"
+     inkscape:window-height="986"
+     inkscape:window-maximized="1"
+     inkscape:window-width="1680"
+     inkscape:window-x="0"
+     inkscape:window-y="27"
+     inkscape:zoom="14.481547">
+    <inkscape:grid
+       dotted="false"
+       empspacing="2"
+       enabled="true"
+       id="grid4866"
+       originx="106.66667"
+       originy="629.33333"
+       snapvisiblegridlinesonly="true"
+       spacingx="1.0666667"
+       spacingy="1.0666667"
+       type="xygrid"
+       visible="true" />
+  </sodipodi:namedview>
+  <title
+     id="title9167">Gnome Symbolic Icon Theme</title>
+  <defs
+     id="defs7386" />
+  <g
+     inkscape:groupmode="layer"
+     id="layer9"
+     inkscape:label="status"
+     style="display:inline"
+     transform="translate(-150.40021,-860.8)" />
+  <g
+     inkscape:groupmode="layer"
+     id="layer10"
+     inkscape:label="devices"
+     style="display:inline"
+     transform="translate(-150.40021,-860.8)" />
+  <g
+     inkscape:groupmode="layer"
+     id="layer11"
+     inkscape:label="apps"
+     transform="translate(-150.40021,-860.8)" />
+  <g
+     inkscape:groupmode="layer"
+     id="layer13"
+     inkscape:label="places"
+     style="display:inline"
+     transform="translate(-150.40021,-860.8)" />
+  <g
+     inkscape:groupmode="layer"
+     id="layer14"
+     inkscape:label="mimetypes"
+     transform="translate(-150.40021,-860.8)" />
+  <g
+     inkscape:groupmode="layer"
+     id="layer15"
+     inkscape:label="emblems"
+     style="display:inline"
+     transform="translate(-150.40021,-860.8)" />
+  <g
+     inkscape:groupmode="layer"
+     id="g71291"
+     inkscape:label="emotes"
+     style="display:inline"
+     transform="translate(-150.40021,-860.8)" />
+  <g
+     inkscape:groupmode="layer"
+     id="g4953"
+     inkscape:label="categories"
+     style="display:inline"
+     transform="translate(-150.40021,-860.8)" />
+  <g
+     inkscape:groupmode="layer"
+     id="layer12"
+     inkscape:label="actions"
+     style="display:inline"
+     transform="translate(-150.40021,-860.8)">
+    <path
+       inkscape:connector-curvature="0"
+       id="iTunes"
+       d="m 158.90021,860.86667 c -4.69427,0 -8.5,3.80573 -8.5,8.5 0,4.69427 3.80573,8.5 8.5,8.5 4.69427,0 8.5,-3.80573 8.5,-8.5 0,-4.69427 -3.80573,-8.5 -8.5,-8.5 z m 0,15.3 c -3.7553,0 -6.8,-3.0447 -6.8,-6.8 0,-3.7553 3.0447,-6.8 6.8,-6.8 3.7553,0 6.8,3.0447 6.8,6.8 0,3.7553 -3.0447,6.8 -6.8,6.8 z m 3.11289,-4.52219 c 0.0546,0.72307 -0.48809,1.38135 -1.21305,1.47163 -0.72382,0.0899 -1.35716,-0.42311 -1.41137,-1.14598 -0.0554,-0.72213 0.48922,-1.38135 1.21304,-1.47088 0.22931,-0.0281 0.44823,0.004 0.64411,0.0827 v -3.55017 l -3.4,0.6324 v 4.43512 h -0.007 c 0.002,0.0125 0.005,0.024 0.005,0.0364 0.055,0.72307 -0.48809,1.38059 -1.21191,1.47088 -0.72533,0.0897 -1.35622,-0.4233 -1.41119,-1.14542 -0.0557,-0.72307 0.48734,-1.38191 1.21191,-1.47088 0.22913,-0.0291 0.44824,0.004 0.64412,0.0837 v -5.11228 -9.5e-4 l 4.93245,-0.84244 0.005,-0.002 v 7.6e-4 l 0.002,-7.6e-4 -0.002,0.0225 v 6.46944 h -0.007 c 0.002,0.0127 0.005,0.0232 0.006,0.0359 z"
+       style="fill:#bebebe;fill-opacity:1;stroke:none;display:inline" />
+  </g>
+</svg>
diff --git a/data/icons/hicolor/scalable/places/lollypop-lastfm-symbolic.svg b/data/icons/hicolor/scalable/places/lollypop-lastfm-symbolic.svg
new file mode 100644
index 00000000..6551a3ea
--- /dev/null
+++ b/data/icons/hicolor/scalable/places/lollypop-lastfm-symbolic.svg
@@ -0,0 +1,7 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Svg Vector Icons : http://www.onlinewebfonts.com/icon -->
+<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
+<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 1000 1000" enable-background="new 0 0 1000 1000" xml:space="preserve">
+<metadata> Svg Vector Icons : http://www.onlinewebfonts.com/icon </metadata>
+<g><g><path d="M716.6,348.8c0,2.2,1.8,9.7,5.5,22.4c3.6,10.6,8.2,19.6,13.7,27.1c5.5,7.5,12.9,13.7,22.4,18.6s17.5,8.6,24.1,10.9s16.6,5.4,30.1,9C930.8,470.1,990,530.6,990,618.5c0,53.2-19.2,97.4-57.7,132.6s-84.9,52.8-139.2,52.8c-21.5,0-41.8-3.4-61-10.1s-35.8-15-50-24.9c-14.2-9.8-28.3-23.4-42.1-40.7c-13.9-17.3-25.3-33.3-34.5-47.9c-9.1-14.6-18.9-33.5-29.3-56.6s-18.3-41.9-23.8-56.3s-12.7-33.8-21.6-58.2c-8.9-24.4-15.4-41.7-19.4-52c-11.7-29.5-22.9-53.9-33.6-73c-10.8-19.1-24.2-36.7-40.2-52.8c-16-16-35-27.7-56.9-35s-47.8-10.9-77.7-10.9c-35,0-68.4,10.1-100.1,30.4c-31.7,20.2-56.9,46.6-75.5,79C109,427.2,99.7,461,99.7,496c0,58.3,19.4,109.3,58.2,152.9c38.8,43.6,86.9,65.4,144.1,65.4c64.5,0,111.6-17.3,141.1-52c20.4-23,35.5-44.1,45.4-63.4l45.9,83.1c-5.5,12.4-13.5,25.2-24.1,38.3l0.5,0.5c-47.8,55.4-118.5,83.1-212.2,83.1c-53.6,0-102.7-14.4-147.4-43.2C106.7,731.8,72,694,47.2,647.2C22.4,600.3,10,550.3,10,497c0-38.3,7.9-75.8,23.8-112.7c15.9-36.8,37-69,63.4-96.5c26.4-27.5,57.8-49.7,94.1-66.4c36.3-16.8,73.6-25.2,111.8-25.2c31.7,0,60.7,3.5,87,10.4c26.3,6.9,48.8,16,67.5,27.3c18.8,11.3,36.1,25.9,52,43.7c15.9,17.9,29.1,35.9,39.6,54.1c10.6,18.2,21.2,39.6,32,64s20,47.1,27.6,68.1c7.7,21,16.8,44.8,27.3,71.4c10.6,26.6,20.6,49.8,30.1,69.5c35,72.9,77.5,109.4,127.4,109.4c29.5,0,54.8-8.8,75.7-26.5c21-17.7,31.4-41.1,31.4-70.3c0-15.3-3.5-28.4-10.4-39.4c-6.9-10.9-16.1-19.3-27.6-25.2s-24.7-11.6-39.6-17.2S792.9,525,777,520.8c-15.9-4.2-31.8-10.4-47.9-18.6c-16-8.2-30.8-17.7-44.3-28.4c-13.5-10.8-25.3-25.7-35.5-44.8S632,387.5,628,362c-1.1-5.8-1.6-11.8-1.6-18c0-40.1,16-75.1,47.9-105c31.9-29.9,68.1-44.1,108.6-42.7c28.4,1.1,50.4,3.7,65.9,7.9c15.5,4.2,32,13.9,49.5,29.3h-0.5c4.4,4,8.6,8.5,12.6,13.4c4,4.9,8.8,11.5,14.2,19.7c5.5,8.2,8.9,13.2,10.4,15l-70.5,54.1c-9.5-17.9-19.3-30.6-29.5-38.3v-0.5c-8.4-7.7-26.1-11.5-53-11.5c-17.9,0-33.2,6-45.9,18C722.9,315.5,716.6,330.6,716.6,348.8L716.6,348.8z"/></g></g>
+</svg>
\ No newline at end of file
diff --git a/data/icons/hicolor/scalable/places/lollypop-spotify-symbolic.svg b/data/icons/hicolor/scalable/places/lollypop-spotify-symbolic.svg
new file mode 100644
index 00000000..473653c6
--- /dev/null
+++ b/data/icons/hicolor/scalable/places/lollypop-spotify-symbolic.svg
@@ -0,0 +1,57 @@
+<?xml version="1.0" encoding="iso-8859-1"?>
+<!-- Generator: Adobe Illustrator 19.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0)  -->
+<svg version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
+	 viewBox="0 0 508.52 508.52" style="enable-background:new 0 0 508.52 508.52;" xml:space="preserve">
+<g>
+	<g>
+		<g>
+			<g>
+				<path style="fill:#090509;" d="M254.26,0C113.845,0,0,113.845,0,254.26s113.845,254.26,254.26,254.26
+					s254.26-113.845,254.26-254.26C508.52,113.813,394.675,0,254.26,0z M254.26,444.955c-105.327,0-190.695-85.368-190.695-190.695
+					S148.933,63.565,254.26,63.565s190.695,85.368,190.695,190.695S359.587,444.955,254.26,444.955z"/>
+				<path style="fill:#090509;" d="M384.568,201.787c-50.089-24.981-103.96-37.63-160.247-37.63c-29.303,0-58.48,3.56-86.798,10.584
+					c-9.376,2.32-15.065,13.635-12.745,22.979c2.32,9.344,11.791,15.065,21.167,12.745c25.553-6.325,51.933-9.535,78.407-9.535
+					c50.788,0,99.416,11.41,144.61,33.944c2.479,1.24,5.149,1.843,7.755,1.843c6.452,0,12.586-5.371,15.701-11.505
+					C396.709,216.598,393.213,206.078,384.568,201.787z"/>
+				<path style="fill:#090509;" d="M224.321,311.977c-23.614,0-46.943,3.464-69.349,10.425c-6.929,2.066-10.774,16.749-8.645,23.71
+					c2.129,6.897,9.471,10.806,16.4,8.613c19.864-6.166,40.618-9.28,61.594-9.28c35.024,0,69.699,8.867,100.242,25.776l6.325,1.621
+					c4.64,0,9.122-2.479,11.442-6.833c3.464-6.325,1.24-21.676-5.149-25.14C302.792,321.988,263.763,311.977,224.321,311.977z"/>
+				<path style="fill:#090509;" d="M360.064,273.615c-41.635-21.612-88.546-33.086-135.711-33.086
+					c-26.316,0-52.505,3.496-77.772,10.393c-8.136,2.225-12.935,16.114-10.711,24.25c2.225,8.136,10.615,12.904,18.783,10.711
+					c22.629-6.166,46.116-9.312,69.699-9.312c42.906,0,83.779,9.948,121.663,29.621c2.225,1.176,4.64,1.78,7.024,1.78
+					c5.562,0,10.87-8.581,13.603-13.794C370.457,286.71,367.533,277.461,360.064,273.615z"/>
+			</g>
+		</g>
+	</g>
+</g>
+<g>
+</g>
+<g>
+</g>
+<g>
+</g>
+<g>
+</g>
+<g>
+</g>
+<g>
+</g>
+<g>
+</g>
+<g>
+</g>
+<g>
+</g>
+<g>
+</g>
+<g>
+</g>
+<g>
+</g>
+<g>
+</g>
+<g>
+</g>
+<g>
+</g>
+</svg>
diff --git a/data/lollypop.gresource.xml b/data/lollypop.gresource.xml
index f78cb406..01e649ff 100644
--- a/data/lollypop.gresource.xml
+++ b/data/lollypop.gresource.xml
@@ -1,43 +1,44 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <gresources>
   <gresource prefix="/org/gnome/Lollypop">
-    <file compressed="true">application.css</file>
-     <file compressed="true" preprocess="xml-stripblanks">AlbumDetailedWidget.ui</file>
-     <file compressed="true" preprocess="xml-stripblanks">Appmenu.ui</file>
-     <file compressed="true" preprocess="xml-stripblanks">ArtistInfo.ui</file>
-     <file compressed="true" preprocess="xml-stripblanks">ArtistView.ui</file>
-     <file compressed="true" preprocess="xml-stripblanks">ArtworkSearch.ui</file>
-     <file compressed="true" preprocess="xml-stripblanks">CoverBox.ui</file>
-     <file compressed="true" preprocess="xml-stripblanks">DeviceManagerView.ui</file>
-     <file compressed="true" preprocess="xml-stripblanks">DeviceManagerWidget.ui</file>
-     <file compressed="true" preprocess="xml-stripblanks">ExternalSearchRow.ui</file>
-     <file compressed="true" preprocess="xml-stripblanks">ExternalsPopover.ui</file>
-     <file compressed="true" preprocess="xml-stripblanks">FirstRunView.ui</file>
-     <file compressed="true" preprocess="xml-stripblanks">FullScreen.ui</file>
-     <file compressed="true" preprocess="xml-stripblanks">InfoContent.ui</file>
-     <file compressed="true" preprocess="xml-stripblanks">InternalSearchRow.ui</file>
-     <file compressed="true" preprocess="xml-stripblanks">LastfmPopover.ui</file>
-     <file compressed="true" preprocess="xml-stripblanks">LovedWidget.ui</file>
-     <file compressed="true" preprocess="xml-stripblanks">MiniPlayer.ui</file>
-     <file compressed="true" preprocess="xml-stripblanks">NextPopover.ui</file>
-     <file compressed="true" preprocess="xml-stripblanks">PlaylistEditView.ui</file>
-     <file compressed="true" preprocess="xml-stripblanks">PlaylistEditWidget.ui</file>
-     <file compressed="true" preprocess="xml-stripblanks">PlaylistsManagerView.ui</file>
-     <file compressed="true" preprocess="xml-stripblanks">PlaylistsManagerWidget.ui</file>
-     <file compressed="true" preprocess="xml-stripblanks">PlaylistView.ui</file>
-     <file compressed="true" preprocess="xml-stripblanks">QueuePopover.ui</file>
-     <file compressed="true" preprocess="xml-stripblanks">RadioPopover.ui</file>
-     <file compressed="true" preprocess="xml-stripblanks">RadiosView.ui</file>
-     <file compressed="true" preprocess="xml-stripblanks">RatingWidget.ui</file>
-     <file compressed="true" preprocess="xml-stripblanks">SearchPopover.ui</file>
-     <file compressed="true" preprocess="xml-stripblanks">SelectionList.ui</file>
-     <file compressed="true" preprocess="xml-stripblanks">SettingsDialog.ui</file>
-     <file compressed="true" preprocess="xml-stripblanks">Shortcuts.ui</file>
-     <file compressed="true" preprocess="xml-stripblanks">ToolbarEnd.ui</file>
-     <file compressed="true" preprocess="xml-stripblanks">ToolbarInfo.ui</file>
-     <file compressed="true" preprocess="xml-stripblanks">ToolbarPlayback.ui</file>
-     <file compressed="true" preprocess="xml-stripblanks">ToolbarTitle.ui</file>
-     <file compressed="true" preprocess="xml-stripblanks">TuneinPopover.ui</file>
-     <file compressed="true" preprocess="xml-stripblanks">AboutDialog.ui</file>
+    <file preprocess="xml-stripblanks">AboutDialog.ui</file>
+    <file preprocess="xml-stripblanks">Appmenu.ui</file>
+    <file preprocess="xml-stripblanks">LastfmPopover.ui</file>
+    <file preprocess="xml-stripblanks">InternalSearchRow.ui</file>
+    <file preprocess="xml-stripblanks">ExternalSearchRow.ui</file>
+    <file preprocess="xml-stripblanks">SearchPopover.ui</file>
+    <file preprocess="xml-stripblanks">QueuePopover.ui</file>
+    <file preprocess="xml-stripblanks">RatingWidget.ui</file>
+    <file preprocess="xml-stripblanks">LovedWidget.ui</file>
+    <file preprocess="xml-stripblanks">RadiosView.ui</file>
+    <file preprocess="xml-stripblanks">RadioPopover.ui</file>
+    <file preprocess="xml-stripblanks">MiniPlayer.ui</file>
+    <file preprocess="xml-stripblanks">PlaylistView.ui</file>
+    <file preprocess="xml-stripblanks">PlaylistEditView.ui</file>
+    <file preprocess="xml-stripblanks">PlaylistEditWidget.ui</file>
+    <file preprocess="xml-stripblanks">DeviceManagerWidget.ui</file>
+    <file preprocess="xml-stripblanks">DeviceManagerView.ui</file>
+    <file preprocess="xml-stripblanks">AlbumDetailedWidget.ui</file>
+    <file preprocess="xml-stripblanks">CoverBox.ui</file>
+    <file preprocess="xml-stripblanks">FirstRunView.ui</file>
+    <file preprocess="xml-stripblanks">ArtworkSearch.ui</file>
+    <file preprocess="xml-stripblanks">FullScreen.ui</file>
+    <file preprocess="xml-stripblanks">SelectionList.ui</file>
+    <file preprocess="xml-stripblanks">PlaylistsManagerView.ui</file>
+    <file preprocess="xml-stripblanks">PlaylistsManagerWidget.ui</file>
+    <file>application.css</file>
+    <file>application-legacy.css</file>
+    <file preprocess="xml-stripblanks">ArtistView.ui</file>
+    <file preprocess="xml-stripblanks">ArtistInfo.ui</file>
+    <file preprocess="xml-stripblanks">InfoContent.ui</file>
+    <file preprocess="xml-stripblanks">TuneinPopover.ui</file>
+    <file preprocess="xml-stripblanks">ExternalsPopover.ui</file>
+    <file preprocess="xml-stripblanks">ToolbarPlayback.ui</file>
+    <file preprocess="xml-stripblanks">ToolbarInfo.ui</file>
+    <file preprocess="xml-stripblanks">ToolbarEnd.ui</file>
+    <file preprocess="xml-stripblanks">ToolbarTitle.ui</file>
+    <file preprocess="xml-stripblanks">NextPopover.ui</file>
+    <file preprocess="xml-stripblanks">SettingsDialog.ui</file>
+    <file compressed="true" preprocess="xml-stripblanks">Shortcuts.ui</file>
   </gresource>
 </gresources>
diff --git a/data/org.gnome.Lollypop.appdata.xml.in b/data/org.gnome.Lollypop.appdata.xml.in
index b54f0c90..d535d00f 100644
--- a/data/org.gnome.Lollypop.appdata.xml.in
+++ b/data/org.gnome.Lollypop.appdata.xml.in
@@ -32,7 +32,7 @@
     </ul>
   </description>
   <screenshots>
-    <screenshot type="default" width="800" height="439">http://gnumdk.github.io/lollypop-web/images/screenshot.jpg</screenshot>
+    <screenshot type="default" width="800" height="439">https://raw.githubusercontent.com/gnumdk/lollypop-data/master/mainsmall.jpg</screenshot>
   </screenshots>
   <url type="homepage">https://gnumdk.github.io/lollypop-web/</url>
   <url type="bugtracker">https://github.com/gnumdk/lollypop/issues</url>
diff --git a/data/org.gnome.Lollypop.desktop.in b/data/org.gnome.Lollypop.desktop.in
index 1694df35..11da46d4 100644
--- a/data/org.gnome.Lollypop.desktop.in
+++ b/data/org.gnome.Lollypop.desktop.in
@@ -8,7 +8,6 @@ Terminal=false
 Type=Application
 Categories=GNOME;GTK;AudioVideo;Player;Audio;
 StartupNotify=true
-X-PulseAudio-Properties=media.role=music
 MimeType=application/ogg;application/x-ogg;application/x-ogm-audio;audio/aac;audio/mp4;audio/mpeg;audio/mpegurl;audio/ogg;audio/vnd.rn-realaudio;audio/vorbis;audio/x-flac;audio/x-mp3;audio/x-mpeg;audio/x-mpegurl;audio/x-ms-wma;audio/x-musepack;audio/x-oggflac;audio/x-pn-realaudio;audio/x-scpls;audio/x-speex;audio/x-vorbis;audio/x-vorbis+ogg;audio/x-wav;x-content/audio-player;audio/x-aac;audio/m4a;audio/x-m4a;audio/mp3;audio/ac3;audio/flac;application/xspf+xml;audio/x-opus+ogg;
 
 Actions=Toggle;Next;Prev;
diff --git a/data/org.gnome.Lollypop.gschema.xml b/data/org.gnome.Lollypop.gschema.xml
index 18546db1..480cf0b9 100644
--- a/data/org.gnome.Lollypop.gschema.xml
+++ b/data/org.gnome.Lollypop.gschema.xml
@@ -5,12 +5,6 @@
        <value nick="tracks" value="1"/>
        <value nick="albums" value="2"/>
     </enum>
-    <enum id="org.gnome.Lollypop.PowerManagement">
-       <value nick="none" value="0"/>
-       <value nick="idle" value="1"/>
-       <value nick="suspend" value="2"/>
-       <value nick="both" value="3"/>
-    </enum>
     <enum id="org.gnome.Lollypop.Playback">
        <value nick="none" value="0"/>
        <value nick="repeat_track" value="1"/>
@@ -22,6 +16,10 @@
        <value nick="year" value="2"/>
        <value nick="popularity" value="3"/>
     </enum>
+    <enum id="org.gnome.Lollypop.Charts">
+       <value nick="itunes" value="0"/>
+       <value nick="spotify" value="1"/>
+    </enum>
     <schema path="/org/gnome/Lollypop/" id="org.gnome.Lollypop" gettext-domain="lollypop">
         <key type="ai" name="window-size">
             <default>[768, 600]</default>
@@ -48,6 +46,11 @@
             <summary>Access network</summary>
             <description></description>
         </key>
+        <key type="b" name="network-search">
+            <default>false</default>
+            <summary>Search over network</summary>
+            <description></description>
+        </key>
         <key type="b" name="save-to-tags">
             <default>false</default>
             <summary>Save artwork/popularity in tags</summary>
@@ -58,17 +61,17 @@
             <summary>Window maximized</summary>
             <description>Window maximized state.</description>
         </key>
-            <key type="ai" name="party-ids">
+  	    <key type="ai" name="party-ids">
             <default>[]</default>
             <summary>Enabled genres in party mode</summary>
             <description>ID for genres.</description>
         </key>
-        <key type="as" name="music-path">
+ 	<key type="as" name="music-path">
             <default>[]</default>
             <summary></summary>
             <description></description>
         </key>
-        <key type="as" name="music-uris">
+ 	<key type="as" name="music-uris">
             <default>[]</default>
             <summary>Music URI</summary>
             <description>When empty, use XDG_MUSIC_DIR</description>
@@ -103,7 +106,7 @@
             <summary>INTERNAL</summary>
             <description></description>
         </key>
-        <key type="s" name="preview-output">
+	<key type="s" name="preview-output">
             <default>""</default>
             <summary>Audio output preview on track hover</summary>
             <description>PulseAudio only. Example: alsa_output.pci-0000_00_14.2.analog-stereo. Command to get outputs: $ pacmd list-sinks|grep 'name:'</description>
@@ -135,12 +138,12 @@
         </key>
          <key type="b" name="convert-mp3">
             <default>false</default>
-            <summary>Encode to MP3(MTP)</summary>
+            <summary>Convert to MP3(MTP)</summary>
             <description></description>
         </key>
         <key type="i" name="mp3-quality">
             <default>4</default>
-            <summary>Quality of MP3 encoding</summary>
+            <summary>Quality for converting MP3</summary>
             <description></description>
         </key>
          <key type="b" name="normalize-mp3">
@@ -160,7 +163,7 @@
         </key>
          <key type="b" name="show-genres">
             <default>false</default>
-            <summary>Show list of genres</summary>
+            <summary>Show genres list</summary>
             <description></description>
         </key>
          <key type="b" name="show-navigation-list">
@@ -168,14 +171,19 @@
             <summary>Show navigation list</summary>
             <description></description>
         </key>
-        <key type="b" name="artist-artwork">
+         <key type="b" name="show-charts">
+            <default>true</default>
+            <summary>Show charts</summary>
+            <description></description>
+        </key>
+	<key type="b" name="artist-artwork">
             <default>false</default>
             <summary>Show artist artwork</summary>
             <description></description>
         </key>
-        <key type="b" name="dark-ui">
+	 <key type="b" name="dark-ui">
             <default>false</default>
-            <summary>Use dark GTK theme</summary>
+            <summary>Use dark gtk theme</summary>
             <description></description>
         </key>
          <key type="b" name="disable-csd">
@@ -183,12 +191,12 @@
             <summary>Disable use of client side window decorations (headerbar)</summary>
             <description></description>
         </key>
-        <key type="b" name="show-compilations">
+     	 <key type="b" name="show-compilations">
             <default>false</default>
             <summary>Show compilations in albums view</summary>
             <description></description>
         </key>
-        <key type="b" name="background-mode">
+     	 <key type="b" name="background-mode">
             <default>false</default>
             <summary>Continue playback when closed</summary>
             <description></description>
@@ -196,9 +204,9 @@
         <key type="b" name="smart-artist-sort">
             <default>true</default>
             <summary>Smart sort for artist</summary>
-            <description>Ex: The Beatles sorted as Beatles. Reset of database required.</description>
+            <description>Ex: The Beatles sorted as Beatles. Resetting database needed.</description>
         </key>
-        <key type="b" name="save-state">
+     	 <key type="b" name="save-state">
             <default>false</default>
             <summary>Restore previous state</summary>
             <description></description>
@@ -210,11 +218,8 @@
         </key>
         <key type="b" name="disable-notifications">
             <default>false</default>
-            <summary>Disable all notifications</summary>
-        </key>
-        <key type="b" name="disable-song-notifications">
-            <default>true</default>
-            <summary>Disable notifications upon change of song</summary>
+            <summary>Disable notifications</summary>
+            <description>Restart needed</description>
         </key>
         <key type="b" name="show-tag-tracknumber">
             <default>false</default>
@@ -226,7 +231,7 @@
             <summary>INTERNAL</summary>
             <description></description>
         </key>
-            <key type="i" name="paned-listview-width">
+	    <key type="i" name="paned-listview-width">
             <default>200</default>
             <summary>INTERNAL</summary>
             <description></description>
@@ -236,12 +241,12 @@
             <summary>JPG cover quality</summary>
             <description>0-100</description>
         </key>
-        <key type="ai" name="list-one-ids">
+		<key type="ai" name="list-one-ids">
             <default>[0]</default>
             <summary>INTERNAL</summary>
             <description></description>
         </key>
-        <key type="ai" name="list-two-ids">
+		<key type="ai" name="list-two-ids">
             <default>[-1]</default>
             <summary>INTERNAL</summary>
             <description></description>
@@ -256,6 +261,16 @@
             <summary>Only mix songs in party mode</summary>
             <description></description>
         </key>
+        <key type="b" name="search-itunes">
+            <default>true</default>
+            <summary>Search tracks on Itunes</summary>
+            <description></description>
+        </key>
+        <key type="b" name="search-spotify">
+            <default>true</default>
+            <summary>Search tracks on Spotify</summary>
+            <description></description>
+        </key>
         <key type="i" name="mix-duration">
             <default>3</default>
             <summary>Mix duration</summary>
@@ -271,20 +286,20 @@
             <summary>Shuffle mode</summary>
             <description></description>
         </key>
-        <key enum="org.gnome.Lollypop.PowerManagement" name="power-management">
-            <default>'none'</default>
-            <summary>Possibilities for powermanagement options</summary>
-            <description>This option inhibits screensaver and suspend during Lollypop playback.</description>
-        </key>
         <key enum="org.gnome.Lollypop.Playback" name="playback">
             <default>'none'</default>
             <summary>Playback behaviour</summary>
             <description></description>
         </key>
-        <key enum="org.gnome.Lollypop.OrderBy" name="orderby">
+	    <key enum="org.gnome.Lollypop.OrderBy" name="orderby">
             <default>'artist'</default>
             <summary>Order albums by</summary>
             <description></description>
         </key>
+	    <key enum="org.gnome.Lollypop.Charts" name="charts">
+            <default>'itunes'</default>
+            <summary>Charts provider</summary>
+            <description></description>
+        </key>
     </schema>
 </schemalist>
diff --git a/generate_data.sh b/generate_data.sh
deleted file mode 100755
index 4d3c0bc0..00000000
--- a/generate_data.sh
+++ /dev/null
@@ -1,39 +0,0 @@
-#!/bin/bash
-
-function generate_resource()
-{
-    echo '<?xml version="1.0" encoding="UTF-8"?>'
-    echo '<gresources>'
-    echo '  <gresource prefix="/org/gnome/Lollypop">'
-    for file in data/*.css
-    do
-        echo -n '    <file compressed="true">'
-        echo -n $(basename $file)
-        echo '</file>'
-    done
-    for file in data/*.ui AboutDialog.ui
-    do
-        echo -n '     <file compressed="true" preprocess="xml-stripblanks">'
-        echo -n $(basename $file)
-        echo '</file>'
-    done
-    echo '  </gresource>'
-    echo '</gresources>'
-}
-
-function generate_pot()
-{
-    echo '[encoding: UTF-8]'
-    for file in data/*.xml data/*.in lollypop/*.py
-    do
-        echo ../$file
-    done
-    for file in data/*.ui data/AboutDialog.ui.in
-    do
-        echo -n '[type: gettext/glade]'
-        echo ../$file
-    done
-}
-
-generate_resource > data/lollypop.gresource.xml
-generate_pot > subprojects/po/POTFILES.in
diff --git a/lollypop-cli.in b/lollypop-cli.in
index e4933290..8b2b26dd 100755
--- a/lollypop-cli.in
+++ b/lollypop-cli.in
@@ -1,4 +1,4 @@
-#!@PYTHON@
+#!/usr/bin/env python3
 # Copyright (c) 2014-2016 Cedric Bellegarde <cedric.bellegarde@adishatz.org>
 # This program is free software: you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
diff --git a/lollypop.in b/lollypop.in
index 6a52cd8c..9d5be600 100755
--- a/lollypop.in
+++ b/lollypop.in
@@ -1,4 +1,4 @@
-#!@PYTHON@
+#!/usr/bin/env python3
 
 import sys
 import signal
diff --git a/lollypop/GioNotify.py b/lollypop/GioNotify.py
new file mode 100644
index 00000000..af25925d
--- /dev/null
+++ b/lollypop/GioNotify.py
@@ -0,0 +1,110 @@
+#
+# Copyright (C) 2016 Jason Gray <jasonlevigray3@gmail.com>
+#
+# This program is free software: you can redistribute it and/or modify it
+# under the terms of the GNU General Public License version 3, as published
+# by the Free Software Foundation.
+#
+# This program is distributed in the hope that it will be useful, but
+# WITHOUT ANY WARRANTY; without even the implied warranties of
+# MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR
+# PURPOSE.  See the GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License along
+# with this program.  If not, see <http://www.gnu.org/licenses/>.
+# END LICENSE
+
+# See <https://developer.gnome.org/notification-spec/> and
+# <https://github.com/JasonLG1979/possibly-useful-scraps/wiki/GioNotify>
+# for documentation.
+
+from gi.repository import GLib, Gio
+
+
+class GioNotify(Gio.DBusProxy):
+
+    __gtype_name__ = "GioNotify"
+
+    def __init__(self, **kwargs):
+        super().__init__(
+            g_bus_type=Gio.BusType.SESSION,
+            g_interface_name="org.freedesktop.Notifications",
+            g_name="org.freedesktop.Notifications",
+            g_object_path="/org/freedesktop/Notifications",
+            **kwargs
+        )
+
+        self._replace_id = 0
+        self._actions = []
+        self._callbacks = {}
+        self._hints = {}
+
+    @classmethod
+    def async_init(cls, app_name, callback):
+        def on_init_finish(self, result, callback):
+            self.init_finish(result)
+            self.call(
+                "GetCapabilities",
+                None,
+                Gio.DBusCallFlags.NONE,
+                -1,
+                None,
+                on_GetCapabilities_finish,
+                callback,
+            )
+
+        def on_GetCapabilities_finish(self, result, callback):
+            try:
+                caps = self.call_finish(result).unpack()[0]
+
+                self._app_name = app_name
+
+                callback(caps)
+            except Exception as e:
+                print("GioNotify::async_init():", e)
+
+        self = cls()
+        self.init_async(GLib.PRIORITY_DEFAULT, None, on_init_finish, callback)
+        return self
+
+    def show_new(self, summary, body, icon):
+        def on_Notify_finish(self, result):
+            self._replace_id = self.call_finish(result).unpack()[0]
+
+        args = GLib.Variant("(susssasa{sv}i)", (self._app_name,
+                                                self._replace_id,
+                                                icon, summary, body,
+                                                self._actions, self._hints,
+                                                -1))
+
+        self.call(
+            "Notify",
+            args,
+            Gio.DBusCallFlags.NONE,
+            -1,
+            None,
+            on_Notify_finish,
+        )
+
+    def add_action(self, action_id, label, callback):
+        self._actions += [action_id, label]
+        self._callbacks[action_id] = callback
+
+    def clear_actions(self):
+        self._actions.clear()
+        self._callbacks.clear()
+
+    def set_hint(self, key, value):
+        if value is None:
+            if key in self._hints:
+                del self._hints[key]
+        else:
+            self._hints[key] = value
+
+    def do_g_signal(self, sender_name, signal_name, parameters):
+        id, signal_value = parameters.unpack()
+        # We only care about our notifications.
+        if id != self._replace_id:
+            return
+        if signal_name == "ActionInvoked":
+            self._callbacks[signal_value]()
diff --git a/lollypop/application.py b/lollypop/application.py
index 14851298..c8d03b44 100644
--- a/lollypop/application.py
+++ b/lollypop/application.py
@@ -21,6 +21,7 @@ from gi.repository import Gtk, Gio, GLib, Gdk, Notify, TotemPlParser
 
 from pickle import dump
 from gettext import gettext as _
+from threading import Thread
 
 
 try:
@@ -29,16 +30,15 @@ except Exception as e:
     print(e)
     print(_("    - Scrobbler disabled\n"
             "    - Auto cover download disabled\n"
-            "    - Artist information disabled"))
+            "    - Artist informations disabled"))
     print("$ sudo pip3 install pylast")
     LastFM = None
 
-from lollypop.utils import is_gnome, is_unity
+from lollypop.utils import is_gnome, is_unity, get_network_available
 from lollypop.define import Type, DataPath
 from lollypop.window import Window
 from lollypop.database import Database
 from lollypop.player import Player
-from lollypop.inhibitor import Inhibitor
 from lollypop.art import Art
 from lollypop.sqlcursor import SqlCursor
 from lollypop.settings import Settings, SettingsDialog
@@ -46,11 +46,10 @@ from lollypop.database_albums import AlbumsDatabase
 from lollypop.database_artists import ArtistsDatabase
 from lollypop.database_genres import GenresDatabase
 from lollypop.database_tracks import TracksDatabase
-from lollypop.notification import NotificationManager
 from lollypop.playlists import Playlists
 from lollypop.objects import Album, Track
-from lollypop.helper_task import TaskHelper
 from lollypop.collectionscanner import CollectionScanner
+from lollypop.lio import Lio
 
 
 class Application(Gtk.Application):
@@ -91,9 +90,7 @@ class Application(Gtk.Application):
         self.window = None
         self.notify = None
         self.lastfm = None
-        self.librefm = None
         self.debug = False
-        self.__fs = None
         self.__externals_count = 0
         self.__init_proxy()
         GLib.set_application_name("Lollypop")
@@ -103,7 +100,7 @@ class Application(Gtk.Application):
         self.add_main_option("debug", b"d", GLib.OptionFlags.NONE,
                              GLib.OptionArg.NONE, "Debug lollypop", None)
         self.add_main_option("set-rating", b"r", GLib.OptionFlags.NONE,
-                             GLib.OptionArg.STRING, "Rate the current track",
+                             GLib.OptionArg.INT, "Rate the current track",
                              None)
         self.add_main_option("play-pause", b"t", GLib.OptionFlags.NONE,
                              GLib.OptionArg.NONE, "Toggle playback",
@@ -148,9 +145,13 @@ class Application(Gtk.Application):
                                          None)
         except Exception as e:
             print("Application::init():", e)
-
-        cssProviderFile = Gio.File.new_for_uri(
+        self.__is_fs = False
+        if Gtk.get_minor_version() > 18:
+            cssProviderFile = Lio.File.new_for_uri(
                 "resource:///org/gnome/Lollypop/application.css")
+        else:
+            cssProviderFile = Lio.File.new_for_uri(
+                "resource:///org/gnome/Lollypop/application-legacy.css")
         cssProvider = Gtk.CssProvider()
         cssProvider.load_from_file(cssProviderFile)
         screen = Gdk.Screen.get_default()
@@ -167,19 +168,24 @@ class Application(Gtk.Application):
         self.genres = GenresDatabase()
         self.tracks = TracksDatabase()
         self.player = Player()
-        self.inhibitor = Inhibitor()
         self.scanner = CollectionScanner()
         self.art = Art()
-        self.notify = NotificationManager()
         self.art.update_art_size()
         if self.settings.get_value("artist-artwork"):
             GLib.timeout_add(5000, self.art.cache_artists_info)
         if LastFM is not None:
-            self.lastfm = LastFM("lastfm")
-            self.librefm = LastFM("librefm")
+            self.lastfm = LastFM()
         if not self.settings.get_value("disable-mpris"):
-            from lollypop.mpris import MPRIS
+            # Ubuntu > 16.04
+            if Gtk.get_minor_version() > 18:
+                from lollypop.mpris import MPRIS
+            # Ubuntu <= 16.04, Debian Jessie, ElementaryOS
+            else:
+                from lollypop.mpris_legacy import MPRIS
             MPRIS(self)
+        if not self.settings.get_value("disable-notifications"):
+            from lollypop.notification import NotificationManager
+            self.notify = NotificationManager()
 
         settings = Gtk.Settings.get_default()
         self.__gtk_dark = settings.get_property(
@@ -218,6 +224,16 @@ class Application(Gtk.Application):
             # We add to mainloop as we want to run
             # after player::restore_state() signals
             GLib.idle_add(self.window.toolbar.set_mark)
+            self.charts = None
+            if self.settings.get_value("show-charts"):
+                if GLib.find_program_in_path("youtube-dl") is not None:
+                    from lollypop.charts import Charts
+                    self.charts = Charts()
+                    if get_network_available():
+                        self.charts.start()
+                else:
+                    self.settings.set_value("network-search",
+                                            GLib.Variant("b", False))
             self.__preload_portal()
 
     def quit(self, vacuum=False):
@@ -237,7 +253,7 @@ class Application(Gtk.Application):
         """
             Return True if application is fullscreen
         """
-        return self.__fs is not None
+        return self.__is_fs
 
     def set_mini(self, action, param):
         """
@@ -263,7 +279,7 @@ class Application(Gtk.Application):
         """
             Save window position and view
         """
-        if self.is_fullscreen():
+        if self.__is_fs:
             return
         if self.settings.get_value("save-state"):
             self.window.save_view_state()
@@ -307,6 +323,8 @@ class Application(Gtk.Application):
         dump(position, open(DataPath + "/position.bin", "wb"))
         self.player.stop_all()
         self.window.stop_all()
+        if self.charts is not None:
+            self.charts.stop()
 
     def __vacuum(self):
         """
@@ -316,6 +334,7 @@ class Application(Gtk.Application):
             self.scanner.stop()
             GLib.idle_add(self.__vacuum)
             return
+        self.db.del_tracks(self.tracks.get_non_persistent())
         try:
             from lollypop.radios import Radios
             with SqlCursor(self.db) as sql:
@@ -387,14 +406,10 @@ class Application(Gtk.Application):
         if options.contains("debug"):
             self.debug = True
         if options.contains("set-rating"):
-            value = options.lookup_value("set-rating").get_string()
-            try:
-                value = min(max(0, int(value)), 5)
-                if self.player.current_track.id is not None:
-                    self.player.current_track.set_rate(value)
-            except Exception as e:
-                print(e)
-                pass
+            value = options.lookup_value("set-rating").get_int32()
+            if value > 0 and value < 6 and\
+                    self.player.current_track.id is not None:
+                self.player.current_track.set_rate(value)
         elif options.contains("play-pause"):
             self.player.play_pause()
         elif options.contains("play-ids"):
@@ -483,8 +498,9 @@ class Application(Gtk.Application):
             @param param as GLib.Variant
         """
         if self.window:
-            helper = TaskHelper()
-            helper.run(self.art.clean_all_cache)
+            t = Thread(target=self.art.clean_all_cache)
+            t.daemon = True
+            t.start()
             self.window.update_db()
 
     def __set_network(self, action, param):
@@ -495,27 +511,32 @@ class Application(Gtk.Application):
         """
         action.set_state(param)
         self.settings.set_value("network-access", param)
+        if self.charts is not None:
+            if param.get_boolean():
+                self.charts.start()
+            else:
+                self.charts.stop()
+        self.window.reload_view()
 
     def __fullscreen(self, action=None, param=None):
         """
-            Show a fullscreen window with cover and artist information
+            Show a fullscreen window with cover and artist informations
             @param action as Gio.SimpleAction
             @param param as GLib.Variant
         """
-        if self.window and not self.is_fullscreen():
+        if self.window and not self.__is_fs:
             from lollypop.fullscreen import FullScreen
-            self.__fs = FullScreen(self, self.window)
-            self.__fs.connect("destroy", self.__on_fs_destroyed)
-            self.__fs.show()
-        elif self.window and self.is_fullscreen():
-            self.__fs.destroy()
+            fs = FullScreen(self, self.window)
+            fs.connect("destroy", self.__on_fs_destroyed)
+            self.__is_fs = True
+            fs.show()
 
     def __on_fs_destroyed(self, widget):
         """
             Mark fullscreen as False
             @param widget as Fullscreen
         """
-        self.__fs = None
+        self.__is_fs = False
         if not self.window.is_visible():
             self.quit(True)
 
diff --git a/lollypop/art_album.py b/lollypop/art_album.py
index 730e1ac2..c6a7c31a 100644
--- a/lollypop/art_album.py
+++ b/lollypop/art_album.py
@@ -12,6 +12,7 @@
 
 from gi.repository import GLib, Gdk, GdkPixbuf, Gio, Gst
 
+from threading import Thread
 import re
 
 from lollypop.art_base import BaseArt
@@ -19,8 +20,8 @@ from lollypop.tagreader import TagReader
 from lollypop.define import Lp, ArtSize
 from lollypop.objects import Album
 from lollypop.utils import escape, is_readonly
+from lollypop.lio import Lio
 from lollypop.helper_dbus import DBusHelper
-from lollypop.helper_task import TaskHelper
 
 
 class AlbumArt(BaseArt, TagReader):
@@ -52,7 +53,7 @@ class AlbumArt(BaseArt, TagReader):
             cache_path_jpg = "%s/%s_%s.jpg" % (self._CACHE_PATH,
                                                filename,
                                                size)
-            f = Gio.File.new_for_path(cache_path_jpg)
+            f = Lio.File.new_for_path(cache_path_jpg)
             if f.query_exists():
                 return cache_path_jpg
             else:
@@ -89,7 +90,7 @@ class AlbumArt(BaseArt, TagReader):
                 album.uri + "/" + filename
             ]
             for uri in uris:
-                f = Gio.File.new_for_uri(uri)
+                f = Lio.File.new_for_uri(uri)
                 if f.query_exists():
                     return uri
         except:
@@ -105,7 +106,7 @@ class AlbumArt(BaseArt, TagReader):
         # Folders with many albums, get_album_artwork_uri()
         if Lp().albums.get_uri_count(album.uri) > 1:
             return None
-        f = Gio.File.new_for_uri(album.uri)
+        f = Lio.File.new_for_uri(album.uri)
         infos = f.enumerate_children("standard::name",
                                      Gio.FileQueryInfoFlags.NOFOLLOW_SYMLINKS,
                                      None)
@@ -123,22 +124,20 @@ class AlbumArt(BaseArt, TagReader):
             @param album as Album
             @return [paths]
         """
-        try:
-            f = Gio.File.new_for_uri(album.uri)
-            infos = f.enumerate_children(
-                                     "standard::name",
+        if album.is_web:
+            return []
+
+        f = Lio.File.new_for_uri(album.uri)
+        infos = f.enumerate_children("standard::name",
                                      Gio.FileQueryInfoFlags.NOFOLLOW_SYMLINKS,
                                      None)
-            all_uris = []
-            for info in infos:
-                f = infos.get_child(info)
-                all_uris.append(f.get_uri())
-            uris = []
-            for uri in filter(lambda p: p.lower().endswith(self._MIMES),
-                              all_uris):
-                uris.append(uri)
-        except Exception as e:
-            print("AlbumArt::get_album_artworks()", e)
+        all_uris = []
+        for info in infos:
+            f = infos.get_child(info)
+            all_uris.append(f.get_uri())
+        uris = []
+        for uri in filter(lambda p: p.lower().endswith(self._MIMES), all_uris):
+            uris.append(uri)
         return uris
 
     def get_album_artwork(self, album, size, scale):
@@ -156,7 +155,7 @@ class AlbumArt(BaseArt, TagReader):
 
         try:
             # Look in cache
-            f = Gio.File.new_for_path(cache_path_jpg)
+            f = Lio.File.new_for_path(cache_path_jpg)
             if f.query_exists():
                 pixbuf = GdkPixbuf.Pixbuf.new_from_file_at_size(cache_path_jpg,
                                                                 size,
@@ -167,12 +166,11 @@ class AlbumArt(BaseArt, TagReader):
                     uri = self.get_album_artwork_uri(album)
                     data = None
                     if uri is not None:
-                        f = Gio.File.new_for_uri(uri)
+                        f = Lio.File.new_for_uri(uri)
                         (status, data, tag) = f.load_contents(None)
                         ratio = self._respect_ratio(uri)
-                        bytes = GLib.Bytes(data)
-                        stream = Gio.MemoryInputStream.new_from_bytes(bytes)
-                        bytes.unref()
+                        stream = Gio.MemoryInputStream.new_from_data(data,
+                                                                     None)
                         pixbuf = GdkPixbuf.Pixbuf.new_from_stream_at_scale(
                                                                        stream,
                                                                        size,
@@ -193,12 +191,11 @@ class AlbumArt(BaseArt, TagReader):
                     uri = self.get_first_album_artwork(album)
                     # Look in album folder
                     if uri is not None:
-                        f = Gio.File.new_for_uri(uri)
+                        f = Lio.File.new_for_uri(uri)
                         (status, data, tag) = f.load_contents(None)
                         ratio = self._respect_ratio(uri)
-                        bytes = GLib.Bytes(data)
-                        stream = Gio.MemoryInputStream.new_from_bytes(bytes)
-                        bytes.unref()
+                        stream = Gio.MemoryInputStream.new_from_data(data,
+                                                                     None)
                         pixbuf = GdkPixbuf.Pixbuf.new_from_stream_at_scale(
                                                                        stream,
                                                                        size,
@@ -217,6 +214,7 @@ class AlbumArt(BaseArt, TagReader):
                                  [str(Lp().settings.get_value(
                                                 "cover-quality").get_int32())])
             surface = Gdk.cairo_surface_create_from_pixbuf(pixbuf, scale, None)
+            del pixbuf
             return surface
 
         except Exception as e:
@@ -236,6 +234,7 @@ class AlbumArt(BaseArt, TagReader):
         pixbuf = self.pixbuf_from_tags(uri, size)
         if pixbuf is not None:
             surface = Gdk.cairo_surface_create_from_pixbuf(pixbuf, scale, None)
+            del pixbuf
             return surface
         else:
             return self.get_default_icon("folder-music-symbolic", size, scale)
@@ -249,12 +248,15 @@ class AlbumArt(BaseArt, TagReader):
         try:
             album = Album(album_id)
             arturi = None
-            save_to_tags = Lp().settings.get_value("save-to-tags")
+            save_to_tags = Lp().settings.get_value("save-to-tags") and\
+                not album.is_web
             uri_count = Lp().albums.get_uri_count(album.uri)
             filename = self.get_album_cache_name(album) + ".jpg"
             if save_to_tags:
-                helper = TaskHelper()
-                helper.run(self.__save_artwork_tags, data, album)
+                t = Thread(target=self.__save_artwork_tags,
+                           args=(data, album))
+                t.daemon = True
+                t.start()
 
             store_path = self._STORE_PATH + "/" + filename
             if album.uri == "" or is_readonly(album.uri):
@@ -263,17 +265,14 @@ class AlbumArt(BaseArt, TagReader):
             elif uri_count > 1:
                 arturi = album.uri + "/" + filename
                 favorite_uri = album.uri + "/" + self.__favorite
-                favorite = Gio.File.new_for_uri(favorite_uri)
+                favorite = Lio.File.new_for_uri(favorite_uri)
                 if favorite.query_exists():
                     favorite.trash()
             else:
                 arturi = album.uri + "/" + self.__favorite
             # Save cover to uri
-            dst = Gio.File.new_for_uri(arturi)
-            if not save_to_tags or dst.query_exists():
-                bytes = GLib.Bytes(data)
-                stream = Gio.MemoryInputStream.new_from_bytes(bytes)
-                bytes.unref()
+            if not save_to_tags:
+                stream = Gio.MemoryInputStream.new_from_data(data, None)
                 pixbuf = GdkPixbuf.Pixbuf.new_from_stream_at_scale(
                                                                stream,
                                                                ArtSize.MONSTER,
@@ -284,11 +283,16 @@ class AlbumArt(BaseArt, TagReader):
                 pixbuf.savev(store_path, "jpeg", ["quality"],
                              [str(Lp().settings.get_value(
                                                 "cover-quality").get_int32())])
-                dst = Gio.File.new_for_uri(arturi)
-                src = Gio.File.new_for_path(store_path)
+                dst = Lio.File.new_for_uri(arturi)
+                src = Lio.File.new_for_path(store_path)
                 src.move(dst, Gio.FileCopyFlags.OVERWRITE, None, None)
+                del pixbuf
                 self.clean_album_cache(album)
                 GLib.idle_add(self.album_artwork_update, album.id)
+            else:
+                dst = Lio.File.new_for_uri(arturi)
+                if dst.query_exists():
+                    dst.trash()
         except Exception as e:
             print("Art::save_album_artwork(): %s" % e)
 
@@ -305,7 +309,7 @@ class AlbumArt(BaseArt, TagReader):
             @param album as Album
         """
         for uri in self.get_album_artworks(album):
-            f = Gio.File.new_for_uri(uri)
+            f = Lio.File.new_for_uri(uri)
             try:
                 f.trash()
             except:
@@ -321,7 +325,7 @@ class AlbumArt(BaseArt, TagReader):
         """
         cache_name = self.get_album_cache_name(album)
         try:
-            d = Gio.File.new_for_path(self._CACHE_PATH)
+            d = Lio.File.new_for_path(self._CACHE_PATH)
             infos = d.enumerate_children(
                 "standard::name",
                 Gio.FileQueryInfoFlags.NOFOLLOW_SYMLINKS,
@@ -356,9 +360,8 @@ class AlbumArt(BaseArt, TagReader):
             if exist:
                 (exist, mapflags) = sample.get_buffer().map(Gst.MapFlags.READ)
             if exist:
-                bytes = GLib.Bytes(mapflags.data)
-                stream = Gio.MemoryInputStream.new_from_bytes(bytes)
-                bytes.unref()
+                stream = Gio.MemoryInputStream.new_from_data(mapflags.data,
+                                                             None)
                 pixbuf = GdkPixbuf.Pixbuf.new_from_stream_at_scale(stream,
                                                                    size,
                                                                    size,
@@ -387,10 +390,9 @@ class AlbumArt(BaseArt, TagReader):
             @param data as bytes
             @param album as Album
         """
-        # https://bugzilla.gnome.org/show_bug.cgi?id=747431
-        bytes = GLib.Bytes(data)
-        stream = Gio.MemoryInputStream.new_from_bytes(bytes)
-        bytes.unref()
+        if album.is_web:
+            return
+        stream = Gio.MemoryInputStream.new_from_data(data, None)
         pixbuf = GdkPixbuf.Pixbuf.new_from_stream_at_scale(stream,
                                                            ArtSize.MONSTER,
                                                            ArtSize.MONSTER,
@@ -400,7 +402,8 @@ class AlbumArt(BaseArt, TagReader):
         pixbuf.savev("%s/lollypop_cover_tags.jpg" % self._CACHE_PATH,
                      "jpeg", ["quality"], [str(Lp().settings.get_value(
                                            "cover-quality").get_int32())])
-        f = Gio.File.new_for_path("%s/lollypop_cover_tags.jpg" %
+        del pixbuf
+        f = Lio.File.new_for_path("%s/lollypop_cover_tags.jpg" %
                                   self._CACHE_PATH)
         if f.query_exists():
             dbus_helper = DBusHelper()
@@ -415,7 +418,7 @@ class AlbumArt(BaseArt, TagReader):
             @param album_id as int
         """
         try:
-            can_set_cover = source.call_finish(result)[0]
+            can_set_cover = source.call_finish(result)
         except:
             can_set_cover = False
         if can_set_cover:
diff --git a/lollypop/art_base.py b/lollypop/art_base.py
index 554c9473..6017e278 100644
--- a/lollypop/art_base.py
+++ b/lollypop/art_base.py
@@ -19,6 +19,7 @@
 from gi.repository import Gtk, Gdk, GObject, GdkPixbuf, Gio, GLib
 
 from lollypop.define import ArtSize, Lp
+from lollypop.lio import Lio
 
 
 class BaseArt(GObject.GObject):
@@ -65,7 +66,7 @@ class BaseArt(GObject.GObject):
         """
         try:
             filepath = self._STORE_PATH + "/" + filename + ".jpg"
-            f = Gio.File.new_for_path(filepath)
+            f = Lio.File.new_for_path(filepath)
             if f.query_exists():
                 f.delete()
         except Exception as e:
@@ -83,7 +84,7 @@ class BaseArt(GObject.GObject):
         try:
             # First look in cache
             cache_path_jpg = self._get_default_icon_path(size, icon_name)
-            f = Gio.File.new_for_path(cache_path_jpg)
+            f = Lio.File.new_for_path(cache_path_jpg)
             if f.query_exists():
                 pixbuf = GdkPixbuf.Pixbuf.new_from_file_at_scale(
                                                                 cache_path_jpg,
@@ -122,6 +123,7 @@ class BaseArt(GObject.GObject):
                                  ["quality"], [str(Lp().settings.get_value(
                                               "cover-quality").get_int32())])
             surface = Gdk.cairo_surface_create_from_pixbuf(pixbuf, scale, None)
+            del pixbuf
             return surface
         except:
             return self.get_default_icon("computer-fail-symbolic",
@@ -137,11 +139,10 @@ class BaseArt(GObject.GObject):
             @param uri as str
             @return respect aspect ratio as bool
         """
-        f = Gio.File.new_for_uri(uri)
+        f = Lio.File.new_for_uri(uri)
         (status, data, tag) = f.load_contents(None)
-        bytes = GLib.Bytes(data)
-        stream = Gio.MemoryInputStream.new_from_bytes(bytes)
-        bytes.unref()
+        stream = Gio.MemoryInputStream.new_from_data(data,
+                                                     None)
         cover = GdkPixbuf.Pixbuf.new_from_stream(stream, None)
         stream.close()
         cover_width = cover.get_width()
@@ -160,7 +161,7 @@ class BaseArt(GObject.GObject):
         """
             Create store dir
         """
-        d = Gio.File.new_for_path(self._STORE_PATH)
+        d = Lio.File.new_for_path(self._STORE_PATH)
         if not d.query_exists():
             try:
                 d.make_directory_with_parents()
@@ -171,7 +172,7 @@ class BaseArt(GObject.GObject):
         """
             Create cache dir
         """
-        d = Gio.File.new_for_path(self._CACHE_PATH)
+        d = Lio.File.new_for_path(self._CACHE_PATH)
         if not d.query_exists():
             try:
                 d.make_directory_with_parents()
diff --git a/lollypop/art_radio.py b/lollypop/art_radio.py
index edebe4ba..4bc3420f 100644
--- a/lollypop/art_radio.py
+++ b/lollypop/art_radio.py
@@ -15,6 +15,7 @@ from gi.repository import GLib, Gdk, GdkPixbuf, Gio
 import re
 
 from lollypop.art_base import BaseArt
+from lollypop.lio import Lio
 
 
 class RadioArt(BaseArt):
@@ -31,7 +32,7 @@ class RadioArt(BaseArt):
             Init radio art
         """
         BaseArt.__init__(self)
-        d = Gio.File.new_for_path(self._RADIOS_PATH)
+        d = Lio.File.new_for_path(self._RADIOS_PATH)
         if not d.query_exists():
             try:
                 d.make_directory_with_parents()
@@ -50,7 +51,7 @@ class RadioArt(BaseArt):
             cache_path_png = "%s/%s_%s.png" % (self._CACHE_PATH,
                                                filename,
                                                size)
-            f = Gio.File.new_for_path(cache_path_png)
+            f = Lio.File.new_for_path(cache_path_png)
             if f.query_exists():
                 return cache_path_png
             else:
@@ -80,7 +81,7 @@ class RadioArt(BaseArt):
 
         try:
             # Look in cache
-            f = Gio.File.new_for_path(cache_path_png)
+            f = Lio.File.new_for_path(cache_path_png)
             if f.query_exists():
                 pixbuf = GdkPixbuf.Pixbuf.new_from_file_at_size(cache_path_png,
                                                                 size,
@@ -98,6 +99,7 @@ class RadioArt(BaseArt):
                                              scale)
             pixbuf.savev(cache_path_png, "png", [None], [None])
             surface = Gdk.cairo_surface_create_from_pixbuf(pixbuf, scale, None)
+            del pixbuf
             return surface
 
         except Exception as e:
@@ -106,17 +108,18 @@ class RadioArt(BaseArt):
                                          size,
                                          scale)
 
-    def copy_uri_to_cache(self, params):
+    def copy_uri_to_cache(self, uri, name, size):
         """
             Copy uri to cache at size
-            @param params as (str, str, int)
+            @param uri as string
+            @param name as string
+            @param size as int
             @thread safe
         """
-        uri, name, size = params
         filename = self.__get_radio_cache_name(name)
         cache_path_png = "%s/%s_%s.png" % (self._CACHE_PATH, filename, size)
-        s = Gio.File.new_for_uri(uri)
-        d = Gio.File.new_for_path(cache_path_png)
+        s = Lio.File.new_for_uri(uri)
+        d = Lio.File.new_for_path(cache_path_png)
         s.copy(d, Gio.FileCopyFlags.OVERWRITE, None, None)
         GLib.idle_add(self.emit, "radio-artwork-changed", name)
 
@@ -129,8 +132,8 @@ class RadioArt(BaseArt):
         old = "%s/%s.png" % (self._RADIOS_PATH, old_name)
         new = "%s/%s.png" % (self._RADIOS_PATH, new_name)
         try:
-            src = Gio.File.new_for_path(old)
-            dst = Gio.File.new_for_path(new)
+            src = Lio.File.new_for_path(old)
+            dst = Lio.File.new_for_path(new)
             src.move(dst, Gio.FileCopyFlags.OVERWRITE, None, None)
         except Exception as e:
             print("RadioArt::rename_radio(): %s" % e)
@@ -162,7 +165,7 @@ class RadioArt(BaseArt):
         """
         cache_name = self.__get_radio_cache_name(name)
         try:
-            f = Gio.File.new_for_path(self._CACHE_PATH)
+            f = Lio.File.new_for_path(self._CACHE_PATH)
             infos = f.enumerate_children(
                 "standard::name",
                 Gio.FileQueryInfoFlags.NOFOLLOW_SYMLINKS,
@@ -186,7 +189,7 @@ class RadioArt(BaseArt):
         """
         try:
             name = name.replace("/", "-")
-            f = Gio.File.new_for_path(self._RADIOS_PATH + "/" + name + ".png")
+            f = Lio.File.new_for_path(self._RADIOS_PATH + "/" + name + ".png")
             if f.query_exists():
                 return self._RADIOS_PATH + "/" + name + ".png"
             return None
diff --git a/lollypop/art_widgets.py b/lollypop/art_widgets.py
index 2c9225b7..0c72fe95 100644
--- a/lollypop/art_widgets.py
+++ b/lollypop/art_widgets.py
@@ -12,12 +12,13 @@
 
 from gi.repository import Gtk, Gdk, GLib, Gio, GdkPixbuf
 
+from threading import Thread
 from gettext import gettext as _
 
 from lollypop.cache import InfoCache
 from lollypop.define import Lp, ArtSize, Type
 from lollypop.utils import get_network_available
-from lollypop.helper_task import TaskHelper
+from lollypop.lio import Lio
 
 
 class ArtworkSearch(Gtk.Bin):
@@ -36,9 +37,9 @@ class ArtworkSearch(Gtk.Bin):
         Gtk.Bin.__init__(self)
         self.connect("unmap", self.__on_self_unmap)
         self.__timeout_id = None
+        self.__loading = False
         self.__album = album
         self.__artist_id = artist_id
-        self.__cancellable = Gio.Cancellable()
         is_compilation = album is not None and\
             album.artist_ids and\
             album.artist_ids[0] == Type.COMPILATIONS
@@ -46,7 +47,7 @@ class ArtworkSearch(Gtk.Bin):
             self.__artist = ""
         else:
             self.__artist = Lp().artists.get_name(artist_id)
-        self.__contents = {}
+        self.__datas = {}
         builder = Gtk.Builder()
         builder.add_from_resource("/org/gnome/Lollypop/ArtworkSearch.ui")
         builder.connect_signals(self)
@@ -75,9 +76,8 @@ class ArtworkSearch(Gtk.Bin):
         self._stack.add_named(builder.get_object("scrolled"), "main")
         self._stack.set_visible_child_name("main")
         self.add(widget)
-        key = Lp().settings.get_value("cs-api-key").get_string() or\
-            Lp().settings.get_default_value("cs-api-key").get_string()
-        self._api_entry.set_text(key)
+        self._api_entry.set_text(
+                            Lp().settings.get_value("cs-api-key").get_string())
         self.set_size_request(700, 400)
 
     def populate(self):
@@ -89,6 +89,7 @@ class ArtworkSearch(Gtk.Bin):
                                             ArtSize.BIG,
                                             self.get_scale_factor())
         image.set_from_surface(surface)
+        del surface
         image.set_property("valign", Gtk.Align.CENTER)
         image.set_property("halign", Gtk.Align.CENTER)
         image.get_style_context().add_class("cover-frame")
@@ -100,23 +101,22 @@ class ArtworkSearch(Gtk.Bin):
             uris = Lp().art.get_album_artworks(self.__album)
             for uri in uris:
                 try:
-                    f = Gio.File.new_for_uri(uri)
-                    (status, content, tag) = f.load_contents()
-                    self.__add_pixbuf(uri, status, content, print)
+                    f = Lio.File.new_for_uri(uri)
+                    (status, data, tag) = f.load_contents()
+                    self.__add_pixbuf(data)
                 except Exception as e:
                     print("ArtworkSearch::populate()", e)
         # Then google
-        uri = Lp().art.get_google_search_uri(self.__get_current_search())
-        helper = TaskHelper()
-        helper.load_uri_content(uri,
-                                self.__cancellable,
-                                self.__on_google_content_loaded)
+        self.__loading = True
+        t = Thread(target=self.__populate)
+        t.daemon = True
+        t.start()
 
     def stop(self):
         """
             Stop loading
         """
-        self.__cancellable.cancel()
+        self.__loading = False
 
 #######################
 # PROTECTED           #
@@ -145,7 +145,7 @@ class ArtworkSearch(Gtk.Bin):
         response = dialog.run()
         if response == Gtk.ResponseType.OK:
             try:
-                f = Gio.File.new_for_path(dialog.get_filename())
+                f = Lio.File.new_for_path(dialog.get_filename())
                 (status, data, tag) = f.load_contents()
                 if not status:
                     raise
@@ -210,106 +210,132 @@ class ArtworkSearch(Gtk.Bin):
 #######################
 # PRIVATE             #
 #######################
-    def __get_current_search(self):
+    def __get_current_searches(self):
         """
             Return current searches
-            @return str
+            @return [str]
         """
+        searches = []
         if self._entry.get_text() != "":
-            search = self._entry.get_text()
+            searches = [self._entry.get_text()]
         elif self.__album is not None:
-            search = "%s+%s" % (self.__artist, self.__album.name)
+            searches = ["%s+%s" % (self.__artist, self.__album.name)]
         elif self.__artist_id is not None:
-            search = self.__artist
-        return search
+            for album_id in Lp().artists.get_albums([self.__artist_id]):
+                for genre_id in Lp().albums.get_genre_ids(album_id):
+                    genre = Lp().genres.get_name(genre_id)
+                    searches.append("%s+%s" % (self.__artist, genre))
+            searches.append(self.__artist)
+        return searches
 
-    def __populate(self, uris):
+    def __populate(self, current_search=""):
         """
-            Add uris to view
-            @param uris as [str]
+            Same as populate
+            @param current search as str
+            @thread safe
         """
-        if self.__cancellable.is_cancelled():
+        urls = []
+        if get_network_available():
+            for search in self.__get_current_searches():
+                urls += Lp().art.get_google_arts(search)
+            if urls:
+                self.__add_pixbufs(urls, current_search)
+            else:
+                self.__fallback(current_search)
+        else:
+            GLib.idle_add(self._spinner.stop)
+
+    def __add_pixbufs(self, urls, current_search):
+        """
+            Add urls to the view
+            @param urls as [string]
+            @param current search as str
+        """
+        if current_search != self._entry.get_text():
             return
-        helper = TaskHelper()
-        # Fallback to link extraction
-        if uris is None:
-            self._label.set_text(_("Low quality, missing API key…"))
-            uri = "https://www.google.fr/search?q=%s&tbm=isch" %\
-                GLib.uri_escape_string(self.__get_current_search(), None, True)
-            helper.load_uri_content(uri,
-                                    self.__cancellable,
-                                    self.__extract_links)
-        # Populate the view
-        elif uris:
-            uri = uris.pop(0)
-            helper.load_uri_content(uri,
-                                    self.__cancellable,
-                                    self.__add_pixbuf,
-                                    self.__populate,
-                                    uris)
-        # Nothing to load, stop
+        if urls and self.__loading:
+            url = urls.pop(0)
+            try:
+                f = Lio.File.new_for_uri(url)
+                (status, data, tag) = f.load_contents()
+                if status:
+                    GLib.idle_add(self.__add_pixbuf, data)
+            except Exception as e:
+                print("ArtworkSearch::__add_pixbufs: %s" % e)
+            if self.__loading:
+                self.__add_pixbufs(urls, current_search)
         else:
             self._spinner.stop()
 
-    def __add_pixbuf(self, uri, loaded, content, callback, *args):
+    def __fallback(self, current_search):
         """
-            Add uri to the view and load callback
-            @param uri as str
-            @param loaded as bool
-            @param content as bytes
-            @param callback as function
+            Fallback google image search, low quality
+            @param current search as str
         """
-        if self.__cancellable.is_cancelled():
+        try:
+            from bs4 import BeautifulSoup
+        except:
+            print("$ sudo pip3 install beautifulsoup4")
             return
+        urls = []
+        GLib.idle_add(self._label.set_text,
+                      _("Low quality, missing API key…"))
         try:
-            if loaded:
-                bytes = GLib.Bytes(content)
-                stream = Gio.MemoryInputStream.new_from_bytes(bytes)
-                bytes.unref()
-                if stream is not None:
-                    big = GdkPixbuf.Pixbuf.new_from_stream_at_scale(
-                        stream, ArtSize.BIG,
-                        ArtSize.BIG,
-                        True,
-                        None)
-                    stream.close()
-                image = Gtk.Image()
-                image.get_style_context().add_class("cover-frame")
-                image.set_property("halign", Gtk.Align.CENTER)
-                image.set_property("valign", Gtk.Align.CENTER)
-                self.__contents[image] = content
-                surface = Gdk.cairo_surface_create_from_pixbuf(big,
-                                                               0,
-                                                               None)
-                image.set_from_surface(surface)
-                image.show()
-                self._view.add(image)
+            for search in self.__get_current_searches():
+                url = "https://www.google.fr/search?q=%s&tbm=isch" %\
+                    GLib.uri_escape_string(search, None, True)
+                f = Lio.File.new_for_uri(url)
+                (status, data, tag) = f.load_contents()
+                if status:
+                    html = data.decode("utf-8")
+                    soup = BeautifulSoup(html, "html.parser")
+                    for link in soup.findAll("img"):
+                        try:
+                            urls.append(link.attrs["data-src"])
+                        except:
+                            pass
         except Exception as e:
-            print("ArtworkSearch::__add_pixbuf: %s" % e)
-        callback(*args)
+            print("ArtworkSearch::__fallback: %s" % e)
+        self.__add_pixbufs(urls, current_search)
 
-    def __extract_links(self, uri, loaded, content):
+    def __add_pixbuf(self, data):
         """
-            Extract links from content
-            @param uri as str
-            @param loaded as bool
-            @param content as bytes
-            @param callback as function
+            Add pixbuf to the view
+            @param data as bytes
         """
-        uris = []
         try:
-            from bs4 import BeautifulSoup
-            if loaded:
-                html = content.decode("latin-1")
-                soup = BeautifulSoup(html, "html.parser")
-                for link in soup.findAll("img"):
-                    try:
-                        uris.append(link.attrs["src"])
-                    except:
-                        pass
+            stream = Gio.MemoryInputStream.new_from_data(data, None)
+            if stream is not None:
+                monster = GdkPixbuf.Pixbuf.new_from_stream_at_scale(
+                    stream, ArtSize.MONSTER,
+                    ArtSize.MONSTER,
+                    True,
+                    None)
+                stream.close()
+            stream = Gio.MemoryInputStream.new_from_data(data, None)
+            if stream is not None:
+                big = GdkPixbuf.Pixbuf.new_from_stream_at_scale(
+                    stream, ArtSize.BIG,
+                    ArtSize.BIG,
+                    True,
+                    None)
+                stream.close()
+            image = Gtk.Image()
+            image.get_style_context().add_class("cover-frame")
+            image.set_property("halign", Gtk.Align.CENTER)
+            image.set_property("valign", Gtk.Align.CENTER)
+            self.__datas[image] = data
+            surface = Gdk.cairo_surface_create_from_pixbuf(big,
+                                                           0,
+                                                           None)
+            del monster
+            del big
+            image.set_from_surface(surface)
+            del surface
+            image.show()
+            self._view.add(image)
         except Exception as e:
-            print("ArtworkSearch::__extract_links: %s" % e)
-        self.__populate(uris)
+            print("ArtworkSearch::_add_pixbuf: %s" % e)
 
     def __close_popover(self):
         """
@@ -324,21 +350,10 @@ class ArtworkSearch(Gtk.Bin):
 
     def __on_self_unmap(self, widget):
         """
-            Cancel loading
+            Kill thread
             @param widget as Gtk.Widget
         """
-        self.__cancellable.cancel()
-
-    def __on_google_content_loaded(self, uri, loaded, content):
-        """
-            Extract content
-            @param uri as str
-            @param loaded as bool
-            @param content as bytes
-        """
-        if loaded:
-            uris = Lp().art.get_google_artwork(content)
-            self.__populate(uris)
+        self.stop()
 
     def __on_activate(self, flowbox, child):
         """
@@ -346,7 +361,7 @@ class ArtworkSearch(Gtk.Bin):
             Reset cache and use player object to announce cover change
         """
         try:
-            data = self.__contents[child.get_child()]
+            data = self.__datas[child.get_child()]
             self.__close_popover()
             if self.__album is not None:
                 Lp().art.save_album_artwork(data, self.__album.id)
@@ -368,17 +383,12 @@ class ArtworkSearch(Gtk.Bin):
             Populate widget
             @param string as str
         """
-        self.__cancellable.cancel()
         for child in self._view.get_children():
             child.destroy()
         self._spinner.start()
         self._spinner.show()
         self.__timeout_id = None
         self.__loading = True
-        self.__cancellable.reset()
-        if get_network_available():
-            uri = Lp().art.get_google_search_uri(string)
-            helper = TaskHelper()
-            helper.load_uri_content(uri,
-                                    self.__cancellable,
-                                    self.__on_google_content_loaded)
+        t = Thread(target=self.__populate, args=(string,))
+        t.daemon = True
+        t.start()
diff --git a/lollypop/cache.py b/lollypop/cache.py
index eb800e1a..e1cc1fce 100644
--- a/lollypop/cache.py
+++ b/lollypop/cache.py
@@ -12,10 +12,11 @@
 
 from gi.repository import Gio, GLib, GdkPixbuf
 
-from os import mkdir, path  # FIXME Use Gio
+from os import mkdir, path, rename
 
 from lollypop.utils import escape
 from lollypop.define import ArtSize, Lp
+from lollypop.lio import Lio
 
 
 class InfoCache:
@@ -67,6 +68,18 @@ class InfoCache:
                                          suffix)
             if path.exists(filepath):
                 exists = True
+            else:
+                # FIXME Remove this code, support for old lollypop versions
+                #
+                old_path = "%s/%s_%s_%s.jpg" % (InfoCache._CACHE_PATH,
+                                                escape(prefix),
+                                                suffix,
+                                                ArtSize.ARTIST)
+                if path.exists(old_path):
+                    rename(old_path, filepath)
+                    exists = True
+                #
+                ##########################################################
         return exists
 
     def get_artwork(prefix, suffix, size):
@@ -102,6 +115,7 @@ class InfoCache:
                     else:
                         extract = pixbuf
                     if extract is None:
+                        del pixbuf
                         extract = GdkPixbuf.Pixbuf.new(
                                                     GdkPixbuf.Colorspace.RGB,
                                                     True, 8,
@@ -130,9 +144,11 @@ class InfoCache:
                                              pixbuf.get_height(),
                                              extract,
                                              0, 0)
+                        del pixbuf
                     extract.savev(filepath_at_size, "jpeg",
                                   ["quality"], [str(Lp().settings.get_value(
                                                 "cover-quality").get_int32())])
+                    del extract
                 return filepath_at_size
         except Exception as e:
             print("InfoCache::get_artwork():", e)
@@ -151,13 +167,13 @@ class InfoCache:
         content = None
         data = None
         if path.exists(filepath+".txt"):
-            f = Gio.File.new_for_path(filepath+".txt")
+            f = Lio.File.new_for_path(filepath+".txt")
             (status, content, tag) = f.load_contents()
             if not status:
                 content = None
             image_path = filepath+".jpg"
             if path.exists(image_path):
-                f = Gio.File.new_for_path(image_path)
+                f = Lio.File.new_for_path(image_path)
                 (status, data, tag) = f.load_contents()
                 if not status:
                     data = None
@@ -175,30 +191,29 @@ class InfoCache:
                                  escape(prefix),
                                  suffix)
         if content is not None:
-            f = Gio.File.new_for_path(filepath+".txt")
+            f = Lio.File.new_for_path(filepath+".txt")
             fstream = f.replace(None, False,
                                 Gio.FileCreateFlags.REPLACE_DESTINATION, None)
             if fstream is not None:
                 fstream.write(content, None)
                 fstream.close()
         if data is None:
-            f = Gio.File.new_for_path(filepath+".jpg")
+            f = Lio.File.new_for_path(filepath+".jpg")
             fstream = f.replace(None, False,
                                 Gio.FileCreateFlags.REPLACE_DESTINATION, None)
             fstream.close()
         else:
-            bytes = GLib.Bytes(data)
-            stream = Gio.MemoryInputStream.new_from_bytes(bytes)
-            bytes.unref()
+            stream = Gio.MemoryInputStream.new_from_data(data, None)
             pixbuf = GdkPixbuf.Pixbuf.new_from_stream_at_scale(stream,
                                                                ArtSize.ARTIST,
                                                                -1,
                                                                True,
                                                                None)
             stream.close()
-            pixbuf.savev(filepath + ".jpg",
+            pixbuf.savev(filepath+".jpg",
                          "jpeg", ["quality"], [str(Lp().settings.get_value(
                                                "cover-quality").get_int32())])
+            del pixbuf
 
     def remove(prefix, suffix):
         """
@@ -209,7 +224,7 @@ class InfoCache:
         filepath = "%s/%s_%s.txt" % (InfoCache._INFO_PATH,
                                      escape(prefix),
                                      suffix)
-        f = Gio.File.new_for_path(filepath)
+        f = Lio.File.new_for_path(filepath)
         try:
             f.delete(None)
         except:
@@ -217,7 +232,7 @@ class InfoCache:
         filepath = "%s/%s_%s.jpg" % (InfoCache._INFO_PATH,
                                      escape(prefix),
                                      suffix)
-        f = Gio.File.new_for_path(filepath)
+        f = Lio.File.new_for_path(filepath)
         try:
             f.delete(None)
         except:
@@ -235,7 +250,7 @@ class InfoCache:
                                             escape(prefix),
                                             suffix,
                                             ArtSize.ARTIST_SMALL*scale*i)
-            f = Gio.File.new_for_path(filepath)
+            f = Lio.File.new_for_path(filepath)
             try:
                 f.delete(None)
             except:
diff --git a/lollypop/cellrenderer.py b/lollypop/cellrenderer.py
index 091dc5b0..fc39daab 100644
--- a/lollypop/cellrenderer.py
+++ b/lollypop/cellrenderer.py
@@ -56,6 +56,7 @@ class CellRendererAlbum(Gtk.CellRenderer):
         ctx.set_line_width(1)
         ctx.fill()
         ctx.set_source_surface(surface, 1, 1)
+        del surface
         ctx.paint()
 
     def do_get_preferred_width(self, widget):
@@ -124,6 +125,7 @@ class CellRendererArtist(Gtk.CellRendererText):
                                                      pixbuf,
                                                      self.__scale_factor,
                                                      None)
+                    del pixbuf
                     self.__surfaces[self.rowid] = surface
                     break
         if surface is None:
@@ -144,6 +146,7 @@ class CellRendererArtist(Gtk.CellRendererText):
         ctx.set_source_rgba(0, 0, 0, 0.3)
         ctx.stroke_preserve()
         ctx.set_source_surface(surface, 0, 0)
+        del surface
         ctx.clip()
         ctx.paint()
 
diff --git a/lollypop/charts.py b/lollypop/charts.py
new file mode 100644
index 00000000..0723efa2
--- /dev/null
+++ b/lollypop/charts.py
@@ -0,0 +1,64 @@
+# Copyright (c) 2014-2017 Cedric Bellegarde <cedric.bellegarde@adishatz.org>
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+# GNU General Public License for more details.
+# You should have received a copy of the GNU General Public License
+# along with this program. If not, see <http://www.gnu.org/licenses/>.
+
+from threading import Thread
+from time import time
+
+from lollypop.charts_itunes import ItunesCharts
+from lollypop.charts_spotify import SpotifyCharts
+from lollypop.charts_lastfm import LastfmCharts
+from lollypop.define import Lp
+
+
+class Charts:
+    """
+        Charts
+    """
+
+    def __init__(self):
+        """
+            Init charts
+        """
+        self.__time = int(time())
+        self.__providers = [SpotifyCharts(self.__time),
+                            LastfmCharts(self.__time),
+                            ItunesCharts(self.__time)]
+
+    def start(self):
+        """
+            Start charts update
+        """
+        t = Thread(target=self.__update)
+        t.daemon = True
+        t.start()
+
+    def stop(self):
+        """
+            Stop downloads
+        """
+        for provider in self.__providers:
+            provider.stop()
+
+#######################
+# PRIVATE             #
+#######################
+    def __update(self):
+        """
+            Update charts
+            @thread safe
+        """
+        # Remove charts older than one week
+        t = self.__time - 604800
+        Lp().db.del_tracks(Lp().tracks.get_old_charts_track_ids(t))
+        # Update charts
+        for provider in self.__providers:
+            provider.update()
diff --git a/lollypop/charts_itunes.py b/lollypop/charts_itunes.py
new file mode 100644
index 00000000..6f884232
--- /dev/null
+++ b/lollypop/charts_itunes.py
@@ -0,0 +1,228 @@
+# Copyright (c) 2014-2017 Cedric Bellegarde <cedric.bellegarde@adishatz.org>
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+# GNU General Public License for more details.
+# You should have received a copy of the GNU General Public License
+# along with this program. If not, see <http://www.gnu.org/licenses/>.
+
+from gi.repository import Gio
+
+import json
+from time import sleep
+from locale import getdefaultlocale
+
+
+from lollypop.web import Web
+from lollypop.define import DbPersistent, Lp, Type
+from lollypop.utils import debug, get_network_available
+from lollypop.search_item import SearchItem
+from lollypop.tagreader import TagReader
+from lollypop.sqlcursor import SqlCursor
+from lollypop.lio import Lio
+
+
+class ItunesCharts:
+    """
+        Itunes charts
+    """
+
+    __GENRES = {"alternative": 20,
+                "anime": 29,
+                "blues": 2,
+                "brazil": 1122,
+                "children": 4,
+                "chinese": 1232,
+                "gospel": 22,
+                "comedy": 3,
+                "classic": 5,
+                "country": 6,
+                "dance": 17,
+                "disney": 50000063,
+                "easy": 25,
+                "enka": 28,
+                "fitness": 50,
+                "electro": 7,
+                "french": 50000064,
+                "german pop": 50000066,
+                "german folk": 50000068,
+                "holiday": 8,
+                "indian": 1262,
+                "instrumental": 53,
+                "j-pop": 27,
+                "k-pop": 51,
+                "karaoke": 52,
+                "kayokyoku": 30,
+                "korean": 1243,
+                "singer": 10,
+                "vocal": 23,
+                "rap": 18,
+                "hip hop": 18,
+                "jazz": 11,
+                "latino": 12,
+                "new age": 13,
+                "opera": 9,
+                "pop": 14,
+                "soul": 15,
+                "r&b": 15,
+                "reggae": 24,
+                "rock": 21,
+                "soundtrack": 16,
+                "world": 19,
+                }
+    __LIMIT = 40
+    __ALL = "https://itunes.apple.com/%s/rss/topalbums/limit=%s/json"
+    __GENRE = \
+        "https://itunes.apple.com/%s/rss/topalbums/limit=%s/genre=%s/json"
+    __INFO = "https://itunes.apple.com/lookup?id=%s&entity=song&country=%s"
+
+    def __init__(self, time):
+        """
+            Init charts
+            @param time as int
+        """
+        self.__time = time
+        self.__cancel = Gio.Cancellable.new()
+        self.__stop = False
+
+    def update(self):
+        """
+            Update charts
+        """
+        if not Lp().settings.get_value("show-charts"):
+            return
+        self.__cancel.reset()
+        self.__stop = False
+        self.__update()
+
+    def stop(self):
+        """
+            Stop search
+        """
+        self.__stop = True
+        self.__cancel.cancel()
+
+#######################
+# PRIVATE             #
+#######################
+    def __update(self):
+        """
+            Update charts
+        """
+        sleep(5)
+        if self.__stop:
+            return
+        country = getdefaultlocale()[0][3:]
+        itunes_ids = list(self.__GENRES.values())
+        self.__update_for_url(self.__ALL % (country, self.__LIMIT))
+        for itunes_id in itunes_ids:
+            if self.__stop:
+                return
+            self.__update_for_url(self.__GENRE % (country,
+                                                  self.__LIMIT,
+                                                  itunes_id))
+
+    def __update_for_url(self, url):
+        """
+            Update charts for url
+            @param url as str
+        """
+        if not get_network_available():
+                return
+        debug("ItunesCharts::__update_for_url(): %s => %s" % (url,
+                                                              self.__LIMIT))
+        web = Web()
+        ids = self.__get_ids(url)
+        position = len(ids)
+        while ids:
+            sleep(10)
+            (itunes_id, itunes_genre) = ids.pop(0)
+            album = self.__get_album(itunes_id)
+            if self.__stop:
+                return
+            if album is None or not album.subitems:
+                position -= 1
+                continue
+            album.mtime = self.__time + position
+            for item in album.subitems:
+                item.mtime = self.__time
+            debug("ItunesCharts::__update_for_url(): %s - %s" % (
+                                                                album.name,
+                                                                album.artists))
+            t = TagReader()
+            with SqlCursor(Lp().db) as sql:
+                genre_ids = t.add_genres(itunes_genre)
+                sql.commit()
+            genre_ids.append(Type.ITUNES)
+            web.save_album_thread(album, DbPersistent.CHARTS, genre_ids)
+            position -= 1
+
+    def __get_album(self, itunes_id):
+        """
+            Get itunes album items
+            @param id as int
+            @return SearchItem/None
+        """
+        if not get_network_available():
+                return
+        country = getdefaultlocale()[0][3:]
+        try:
+            debug("ItunesCharts::__get_album(): %s" % itunes_id)
+            url = self.__INFO % (itunes_id, country)
+            f = Lio.File.new_for_uri(url)
+            (status, data, tag) = f.load_contents(self.__cancel)
+            if not status or self.__stop:
+                return
+            decode = json.loads(data.decode("utf-8"))
+            item = decode["results"][0]
+            album_item = SearchItem()
+            album_item.name = item["collectionName"]
+            album_item.artists.append(item["artistName"])
+            album_item.cover = item["artworkUrl60"].replace(
+                                               "60x60",
+                                               "512x512")
+
+            for item in decode["results"][1:]:
+                track_item = SearchItem()
+                track_item.is_track = True
+                track_item.name = item["trackName"]
+                track_item.album = album_item
+                track_item.year = item["releaseDate"][:4]
+                track_item.tracknumber = int(
+                                          item["trackNumber"])
+                track_item.discnumber = int(
+                                           item["discNumber"])
+                track_item.duration = int(
+                                    item["trackTimeMillis"]) / 1000
+                if album_item.artists[0] != item["artistName"]:
+                    track_item.artists.append(album_item.artists[0])
+                track_item.artists.append(item["artistName"])
+                album_item.subitems.append(track_item)
+            return album_item
+        except Exception as e:
+            print("ItunesCharts::__get_album()", e)
+        return None
+
+    def __get_ids(self, url):
+        """
+            Get album itunes ids
+            @param url as str
+        """
+        items = []
+        try:
+            f = Lio.File.new_for_uri(url)
+            (status, data, tag) = f.load_contents(self.__cancel)
+            if not status or self.__stop:
+                return []
+            decode = json.loads(data.decode("utf-8"))
+            for entry in decode["feed"]["entry"]:
+                itunes_id = entry["id"]["attributes"]["im:id"]
+                itunes_genre = entry["category"]["attributes"]["term"]
+                items.append((itunes_id, itunes_genre))
+        except Exception as e:
+            print("ItunesCharts::__get_ids:", e)
+        return items
diff --git a/lollypop/charts_lastfm.py b/lollypop/charts_lastfm.py
new file mode 100644
index 00000000..6b844de4
--- /dev/null
+++ b/lollypop/charts_lastfm.py
@@ -0,0 +1,128 @@
+# Copyright (c) 2014-2017 Cedric Bellegarde <cedric.bellegarde@adishatz.org>
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+# GNU General Public License for more details.
+# You should have received a copy of the GNU General Public License
+# along with this program. If not, see <http://www.gnu.org/licenses/>.
+
+from gi.repository import Gio
+
+from time import sleep
+import json
+
+from lollypop.search_network import NetworkSearch
+from lollypop.web import Web
+from lollypop.define import DbPersistent, Lp, Type
+from lollypop.utils import debug, get_network_available
+from lollypop.lio import Lio
+
+
+class LastfmCharts:
+    """
+        Spotify charts
+    """
+
+    __ALL = "http://ws.audioscrobbler.com/2.0/?method=chart.gettoptracks"\
+            "&api_key=7a9619a850ccf7377c46cf233c51e3c6&format=json"
+
+    def __init__(self, time):
+        """
+            Init charts
+            @param time as int
+        """
+        self.__time = time
+        self.__cancel = Gio.Cancellable.new()
+        self.__stop = False
+
+    def update(self):
+        """
+            Update charts
+        """
+        if not Lp().settings.get_value("show-charts"):
+            return
+        self.__cancel.reset()
+        self._stop = False
+        self.__update()
+
+    def stop(self):
+        """
+            Stop search
+        """
+        self.__stop = True
+        self.__cancel.cancel()
+
+#######################
+# PRIVATE             #
+#######################
+    def __update(self):
+        """
+            Update charts
+        """
+        sleep(5)
+        if self._stop:
+            return
+        self.__update_for_url(self.__ALL)
+
+    def __update_for_url(self, url):
+        """
+            Update charts for url
+            @param url as str
+        """
+        if not get_network_available():
+                return
+        debug("LastfmCharts::__update_for_url(): %s" % (url))
+        ids = self.__get_ids(url)
+        position = len(ids)
+        while ids:
+            sleep(10)
+            (track_name, artist_name) = ids.pop(0)
+            search = NetworkSearch()
+            search.connect("item-found", self.__on_item_found, position)
+            search.do_tracks(track_name + " " + artist_name)
+            if self.__stop:
+                return
+            position -= 1
+
+    def __get_ids(self, url):
+        """
+            Get album itunes ids
+            @param url as str
+            @return [(track name, artist name)] as [(str, str)]
+        """
+        items = []
+        try:
+            f = Lio.File.new_for_uri(url)
+            (status, data, tag) = f.load_contents(self.__cancel)
+            if not status or self.__stop:
+                return []
+            decode = json.loads(data.decode("utf-8"))
+            for entry in decode["tracks"]["track"]:
+                track = entry["name"]
+                artist = entry["artist"]["name"]
+                items.append((track, artist))
+        except Exception as e:
+            print("LastfmCharts::__get_ids:", e)
+        return items
+
+    def __on_item_found(self, search, position):
+        """
+            Get track from search
+            @param search as NetworkSearch
+            @param position as int
+        """
+        if search.items:
+            item = search.items[0]
+            if item.is_track:
+                debug("LastfmCharts::__on_item_found(): %s - %s" % (
+                                                                item.name,
+                                                                item.artists))
+                search.stop()
+                search.disconnect_by_func(self.__on_item_found)
+                item.mtime = self.__time + position
+                web = Web()
+                web.save_track(item, DbPersistent.CHARTS, [Type.LASTFM])
diff --git a/lollypop/charts_spotify.py b/lollypop/charts_spotify.py
new file mode 100644
index 00000000..2e3ebadd
--- /dev/null
+++ b/lollypop/charts_spotify.py
@@ -0,0 +1,127 @@
+# Copyright (c) 2014-2017 Cedric Bellegarde <cedric.bellegarde@adishatz.org>
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+# GNU General Public License for more details.
+# You should have received a copy of the GNU General Public License
+# along with this program. If not, see <http://www.gnu.org/licenses/>.
+
+from gi.repository import Gio
+
+from time import sleep
+from locale import getdefaultlocale
+from csv import reader
+
+from lollypop.search_spotify import SpotifySearch
+from lollypop.web import Web
+from lollypop.define import DbPersistent, Lp, Type
+from lollypop.utils import debug, get_network_available
+from lollypop.lio import Lio
+
+
+class SpotifyCharts:
+    """
+        Spotify charts
+    """
+
+    __ALL = "https://spotifycharts.com/regional/%s/weekly/latest/download"
+
+    def __init__(self, time):
+        """
+            Init charts
+            @param time as int
+        """
+        self.__time = time
+        self.__cancel = Gio.Cancellable.new()
+        self.__stop = False
+
+    def update(self):
+        """
+            Update charts
+        """
+        if not Lp().settings.get_value("show-charts"):
+            return
+        self.__cancel.reset()
+        self._stop = False
+        self.__update()
+
+    def stop(self):
+        """
+            Stop search
+        """
+        self.__stop = True
+        self.__cancel.cancel()
+
+#######################
+# PRIVATE             #
+#######################
+    def __update(self):
+        """
+            Update charts
+        """
+        sleep(5)
+        if self._stop:
+            return
+        language = getdefaultlocale()[0][0:2]
+        self.__update_for_url(self.__ALL % language)
+
+    def __update_for_url(self, url):
+        """
+            Update charts for url
+            @param url as str
+        """
+        if not get_network_available():
+                return
+        debug("SpotifyCharts::__update_for_url(): %s" % (url))
+        ids = self.__get_ids(url)
+        web = Web()
+        search = SpotifySearch()
+        position = len(ids)
+        while ids:
+            sleep(10)
+            track_id = ids.pop(0)
+            album = search.get_track(track_id)
+            if self.__stop:
+                return
+            if album is None or not album.subitems:
+                position -= 1
+                continue
+            for item in album.subitems:
+                item.mtime = self.__time + position
+            debug("SpotifyCharts::__update_for_url(): %s - %s - %s" % (
+                                                                album.name,
+                                                                album.artists,
+                                                                track_id))
+            web.save_album_thread(album, DbPersistent.CHARTS, [Type.SPOTIFY])
+            position -= 1
+
+    def __get_ids(self, url):
+        """
+            Get track spotify ids
+            @param url as str
+        """
+        ids = []
+        try:
+            f = Lio.File.new_for_uri(url)
+            (status, data, tag) = f.load_contents(self.__cancel)
+            if not status or self._stop:
+                return []
+            for line in data.decode("utf-8").split("\n"):
+                try:  # CSV file is mostly broken
+                    for row in reader([line]):
+                        if not row:
+                            continue
+                        url = row[4]
+                        if url == "URL":
+                            continue
+                        track_id = url.split("/")[-1:][0]
+                        ids.append(track_id)
+                except Exception as e:
+                    print(e)
+        except Exception as e:
+            print("SpotifyCharts::__get_ids:", e)
+        return ids
diff --git a/lollypop/collectionimporter.py b/lollypop/collectionimporter.py
deleted file mode 100644
index eb9261d8..00000000
--- a/lollypop/collectionimporter.py
+++ /dev/null
@@ -1,114 +0,0 @@
-# Copyright (c) 2014-2017 Cedric Bellegarde <cedric.bellegarde@adishatz.org>
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-# GNU General Public License for more details.
-# You should have received a copy of the GNU General Public License
-# along with this program. If not, see <http://www.gnu.org/licenses/>.
-
-from gi.repository import GLib, Gio
-
-from gettext import gettext as _
-
-
-from lollypop.define import Lp
-from lollypop.tagreader import TagReader
-from lollypop.utils import is_audio
-
-
-class CollectionImporter:
-    """
-        Import files to main collection (as files)
-    """
-    def __init__(self):
-        """
-            Init collection scanner
-        """
-        self.__tag_reader = TagReader()
-
-    def add(self, uris):
-        """
-            Add uris to collection
-        """
-        GLib.idle_add(Lp().window.pulse, True)
-        walk_uris = list(uris)
-        while walk_uris:
-            uri = walk_uris.pop(0)
-            if not uri:
-                continue
-            try:
-                f = Gio.File.new_for_uri(uri)
-                file_type = f.query_file_type(Gio.FileQueryInfoFlags.NONE,
-                                              None)
-                if file_type == Gio.FileType.DIRECTORY:
-                    infos = f.enumerate_children(
-                        "standard::name,standard::type,standard::is-hidden",
-                        Gio.FileQueryInfoFlags.NONE,
-                        None)
-                    for info in infos:
-                        f = infos.get_child(info)
-                        child_uri = f.get_uri()
-                        if info.get_is_hidden():
-                            continue
-                        elif info.get_file_type() == Gio.FileType.DIRECTORY:
-                            walk_uris.append(child_uri)
-                        else:
-                            if is_audio(f):
-                                self.__add_file(f)
-                elif is_audio(f):
-                    self.__add_file(f)
-                else:
-                    print("CollectionImporter: not an audio file", uri)
-            except Exception as e:
-                print("CollectionImporter::add():", e)
-        GLib.idle_add(Lp().window.pulse, False)
-
-#######################
-# PRIVATE             #
-#######################
-    def __add_file(self, f):
-        """
-            Add file to collection
-            @param f as Gio.File
-        """
-        try:
-            # We only import to primary collection
-            music_uris = Lp().settings.get_music_uris()
-            if music_uris:
-                music_uri = music_uris[0]
-            else:
-                print("CollectionImporter::__add_file(): No collection")
-                return
-            info = self.__tag_reader.get_info(f.get_uri())
-            tags = info.get_tags()
-            name = f.get_basename()
-            title = self.__tag_reader.get_title(tags, name)
-            artists = self.__tag_reader.get_artists(tags)
-            album_artists = self.__tag_reader.get_album_artist(tags)
-            album_name = self.__tag_reader.get_album_name(tags)
-            tracknumber = self.__tag_reader.get_tracknumber(tags, name)
-            # If no artists tag, use album artist
-            if album_artists == "":
-                album_artists = artists
-            if album_artists == "":
-                album_artists = _("Unknown")
-            extension = f.get_uri().split(".")[-1]
-            dest_dir_uri = "%s/%s/%s" % (music_uri,
-                                         album_artists,
-                                         album_name)
-            dest_dir = Gio.File.new_for_uri(dest_dir_uri)
-            if not dest_dir.query_exists():
-                dest_dir.make_directory_with_parents(None)
-            if tracknumber == 0:
-                dest_uri = "%s/%s.%s" % (dest_dir_uri, title, extension)
-            else:
-                dest_uri = "%s/%02d_%s.%s" % (dest_dir_uri, tracknumber,
-                                              title, extension)
-            dest = Gio.File.new_for_uri(dest_uri)
-            f.copy(dest, Gio.FileCopyFlags.NONE, None, None, None)
-        except Exception as e:
-            print("CollectionImporter::__add_file():", e)
diff --git a/lollypop/collectionscanner.py b/lollypop/collectionscanner.py
index d242f164..2f391a96 100644
--- a/lollypop/collectionscanner.py
+++ b/lollypop/collectionscanner.py
@@ -22,6 +22,7 @@ from lollypop.sqlcursor import SqlCursor
 from lollypop.tagreader import TagReader
 from lollypop.database_history import History
 from lollypop.utils import is_audio, is_pls, debug
+from lollypop.lio import Lio
 
 
 class CollectionScanner(GObject.GObject, TagReader):
@@ -66,6 +67,14 @@ class CollectionScanner(GObject.GObject, TagReader):
             self.__thread.daemon = True
             self.__thread.start()
 
+    def clean_charts(self):
+        """
+            Clean charts in db
+        """
+        self.__thread = Thread(target=self.__clean_charts)
+        self.__thread.daemon = True
+        self.__thread.start()
+
     def is_locked(self):
         """
             Return True if db locked
@@ -81,6 +90,14 @@ class CollectionScanner(GObject.GObject, TagReader):
 #######################
 # PRIVATE             #
 #######################
+    def __clean_charts(self):
+        """
+            Clean charts in db
+        """
+        track_ids = Lp().tracks.get_old_charts_track_ids(int(time()))
+        Lp().db.del_tracks(track_ids)
+        self.stop()
+
     def __get_objects_for_uris(self, uris):
         """
             Return all tracks/dirs for uris
@@ -96,7 +113,7 @@ class CollectionScanner(GObject.GObject, TagReader):
             uri = walk_uris.pop(0)
             empty = True
             try:
-                d = Gio.File.new_for_uri(uri)
+                d = Lio.File.new_for_uri(uri)
                 infos = d.enumerate_children(
                     "standard::name,standard::type,standard::is-hidden",
                     Gio.FileQueryInfoFlags.NONE,
@@ -115,7 +132,7 @@ class CollectionScanner(GObject.GObject, TagReader):
                     walk_uris.append(child_uri)
                 else:
                     try:
-                        f = Gio.File.new_for_uri(child_uri)
+                        f = Lio.File.new_for_uri(child_uri)
                         if is_pls(f):
                             pass
                         elif is_audio(f):
@@ -157,6 +174,7 @@ class CollectionScanner(GObject.GObject, TagReader):
             @param uris as [string], uris to scan
             @thread safe
         """
+        gst_message = None
         if self.__history is None:
             self.__history = History()
         mtimes = Lp().tracks.get_mtimes()
@@ -186,7 +204,7 @@ class CollectionScanner(GObject.GObject, TagReader):
                         return
                     try:
                         GLib.idle_add(self.__update_progress, i, count)
-                        f = Gio.File.new_for_uri(uri)
+                        f = Lio.File.new_for_uri(uri)
                         info = f.query_info("time::modified",
                                             Gio.FileQueryInfoFlags.NONE,
                                             None)
@@ -197,7 +215,7 @@ class CollectionScanner(GObject.GObject, TagReader):
                         if uri in orig_tracks:
                             orig_tracks.remove(uri)
                             i += 1
-                            if mtime <= mtimes.get(uri, mtime + 1):
+                            if mtime <= mtimes[uri]:
                                 i += 1
                                 continue
                             else:
@@ -224,6 +242,10 @@ class CollectionScanner(GObject.GObject, TagReader):
                         self.__add2db(uri, mtime)
                     except Exception as e:
                         print("CollectionScanner::__scan(add):", e, uri)
+                        if e.message != gst_message:
+                            gst_message = e.message
+                            if Lp().notify is not None:
+                                Lp().notify.send(gst_message, uri)
                 sql.commit()
             except Exception as e:
                 print("CollectionScanner::__scan():", e)
@@ -233,12 +255,12 @@ class CollectionScanner(GObject.GObject, TagReader):
 
     def __add2db(self, uri, mtime):
         """
-            Add new file to db with information
+            Add new file to db with informations
             @param uri as string
             @param mtime as int
             @return track id as int
         """
-        f = Gio.File.new_for_uri(uri)
+        f = Lio.File.new_for_uri(uri)
         debug("CollectionScanner::add2db(): Read tags")
         info = self.get_info(uri)
         tags = info.get_tags()
@@ -294,7 +316,7 @@ class CollectionScanner(GObject.GObject, TagReader):
               "%s, %s" % (album_name, album_artist_ids))
         (album_id, new_album) = self.add_album(album_name, album_artist_ids,
                                                uri, loved, album_pop,
-                                               album_rate, mtime)
+                                               album_rate, False)
 
         genre_ids = self.add_genres(genres)
 
@@ -303,12 +325,12 @@ class CollectionScanner(GObject.GObject, TagReader):
         track_id = Lp().tracks.add(title, uri, duration,
                                    tracknumber, discnumber, discname,
                                    album_id, year, track_pop, track_rate,
-                                   track_ltime, mtime)
+                                   track_ltime)
 
-        debug("CollectionScanner::add2db(): Update track")
-        self.update_track(track_id, artist_ids, genre_ids)
-        debug("CollectionScanner::add2db(): Update album")
-        self.update_album(album_id, album_artist_ids, genre_ids, year)
+        debug("CollectionScanner::add2db(): Update tracks")
+        self.update_track(track_id, artist_ids, genre_ids, mtime)
+        self.update_album(album_id, album_artist_ids,
+                          genre_ids, album_mtime, year)
         if new_album:
             with SqlCursor(Lp().db) as sql:
                 sql.commit()
@@ -324,7 +346,7 @@ class CollectionScanner(GObject.GObject, TagReader):
             @param uri as str
         """
         try:
-            f = Gio.File.new_for_uri(uri)
+            f = Lio.File.new_for_uri(uri)
             name = f.get_basename()
             track_id = Lp().tracks.get_id_by_uri(uri)
             album_id = Lp().tracks.get_album_id(track_id)
@@ -334,7 +356,7 @@ class CollectionScanner(GObject.GObject, TagReader):
             popularity = Lp().tracks.get_popularity(track_id)
             rate = Lp().tracks.get_rate(track_id)
             ltime = Lp().tracks.get_ltime(track_id)
-            mtime = Lp().tracks.get_mtime(track_id)
+            mtime = Lp().albums.get_mtime(album_id)
             duration = Lp().tracks.get_duration(track_id)
             album_popularity = Lp().albums.get_popularity(album_id)
             album_rate = Lp().albums.get_rate(album_id)
diff --git a/lollypop/container.py b/lollypop/container.py
index 19a3687f..a030f3cc 100644
--- a/lollypop/container.py
+++ b/lollypop/container.py
@@ -20,6 +20,7 @@ from lollypop.loader import Loader
 from lollypop.selectionlist import SelectionList
 from lollypop.view_container import ViewContainer
 from lollypop.progressbar import ProgressBar
+from lollypop.lio import Lio
 
 
 # This is a multimedia device
@@ -64,7 +65,7 @@ class Container:
         Lp().playlists.connect("playlists-changed",
                                self.__update_playlists)
 
-    def update_db(self, *ignore):
+    def update_db(self):
         """
             Update db at startup only if needed
         """
@@ -259,10 +260,10 @@ class Container:
         dev.id = self.__devices_index
         dev.name = "Android phone"
         dev.uri = "file:///tmp/android/"
-        d = Gio.File.new_for_uri(dev.uri+"Internal Memory")
+        d = Lio.File.new_for_uri(dev.uri+"Internal Memory")
         if not d.query_exists():
             d.make_directory_with_parents()
-        d = Gio.File.new_for_uri(dev.uri+"SD Card")
+        d = Lio.File.new_for_uri(dev.uri+"SD Card")
         if not d.query_exists():
             d.make_directory_with_parents()
         self.__devices[self.__devices_index] = dev
@@ -514,6 +515,25 @@ class Container:
                         on_finished=lambda r: setup(*r))
         loader.start()
 
+    def __update_list_charts(self):
+        """
+            Setup list for charts
+            @thread safe
+        """
+        def load():
+            genres = Lp().genres.get_charts()
+            return genres
+
+        def setup(genres):
+            genres.insert(0, (Type.SEPARATOR, ""))
+            genres.insert(0, (Type.ITUNES, "Itunes"))
+            genres.insert(0, (Type.LASTFM, "Last.fm"))
+            genres.insert(0, (Type.SPOTIFY, "Spotify"))
+            self.__list_two.populate(genres)
+            self.__list_two.mark_as_artists(False)
+        loader = Loader(target=load, view=self.__list_two, on_finished=setup)
+        loader.start()
+
     def __update_list_playlists(self, update):
         """
             Setup list for playlists
@@ -611,10 +631,15 @@ class Container:
                 items = Lp().albums.get_loves()
             elif genre_ids and genre_ids[0] == Type.RECENTS:
                 items = Lp().albums.get_recents()
-            elif genre_ids and genre_ids[0] == Type.NEVER:
-                items = Lp().albums.get_never_listened_to()
             elif genre_ids and genre_ids[0] == Type.RANDOMS:
                 items = Lp().albums.get_randoms()
+            elif genre_ids and genre_ids[0] in [Type.SPOTIFY,
+                                                Type.LASTFM]:
+                items = Lp().tracks.get_charts_ids(genre_ids)
+            elif genre_ids and genre_ids[0] == Type.ITUNES:
+                items = Lp().albums.get_charts_ids(genre_ids)
+            elif artist_ids and artist_ids[0] == Type.CHARTS:
+                items = Lp().albums.get_charts_ids(genre_ids)
             else:
                 if is_compilation or\
                         Lp().settings.get_value("show-compilations"):
@@ -623,11 +648,19 @@ class Container:
                     items += Lp().albums.get_ids([], genre_ids)
             return items
 
-        from lollypop.view_albums import AlbumsView
-        self.__stop_current_view()
-        view = AlbumsView(genre_ids, artist_ids)
-        loader = Loader(target=load, view=view)
-        loader.start()
+        # Spotify albums contains only one tracks, show playlist view
+        if genre_ids and genre_ids[0] in [Type.SPOTIFY,
+                                          Type.LASTFM]:
+            from lollypop.view_playlists import PlaylistsView
+            view = PlaylistsView(genre_ids)
+            loader = Loader(target=load, view=view)
+            loader.start()
+        else:
+            from lollypop.view_albums import AlbumsView
+            self.__stop_current_view()
+            view = AlbumsView(genre_ids, artist_ids)
+            loader = Loader(target=load, view=view)
+            loader.start()
         view.show()
         self.__stack.add(view)
         self.__stack.set_visible_child(view)
@@ -746,10 +779,13 @@ class Container:
             self.__list_two.hide()
             if not self.__list_two.will_be_selected():
                 self.__update_view_device(selected_ids[0])
+        elif selected_ids[0] == Type.CHARTS:
+            self.__list_two.show()
+            self.__update_list_charts()
+            self.__update_view_albums(selected_ids, [])
         elif selected_ids[0] in [Type.POPULARS,
                                  Type.LOVED,
                                  Type.RECENTS,
-                                 Type.NEVER,
                                  Type.RANDOMS]:
             self.__list_two.hide()
             self.__update_view_albums(selected_ids, [])
@@ -790,6 +826,8 @@ class Container:
             return
         if genre_ids[0] == Type.PLAYLISTS:
             self.__update_view_playlists(selected_ids)
+        elif genre_ids[0] == Type.CHARTS:
+            self.__update_view_albums(selected_ids, [Type.CHARTS])
         elif selected_ids[0] == Type.COMPILATIONS:
             self.__update_view_albums(genre_ids, selected_ids)
         else:
@@ -813,6 +851,9 @@ class Container:
             @param genre id as int
             @param add as bool
         """
+        # Ignore static genres, can happend with Charts
+        if genre_id < 0:
+            return
         if self.__show_genres:
             if add:
                 genre_name = Lp().genres.get_name(genre_id)
diff --git a/lollypop/controllers.py b/lollypop/controllers.py
index af0c096f..b152eccb 100644
--- a/lollypop/controllers.py
+++ b/lollypop/controllers.py
@@ -79,8 +79,6 @@ class PlaybackController:
             Update buttons and progress bar
             @param player as Player
         """
-        # GTK bug, should not be needed, see #1214
-        self._play_btn.set_sensitive(True)
         if player.is_playing:
             self.__change_play_btn_status(self._pause_image, _("Pause"))
         else:
diff --git a/lollypop/database.py b/lollypop/database.py
index 5ebfc82c..ed649a92 100644
--- a/lollypop/database.py
+++ b/lollypop/database.py
@@ -20,6 +20,7 @@ from lollypop.database_upgrade import DatabaseUpgrade
 from lollypop.sqlcursor import SqlCursor
 from lollypop.localized import LocalizedCollation
 from lollypop.utils import noaccents
+from lollypop.lio import Lio
 
 
 class Database:
@@ -45,7 +46,6 @@ class Database:
                                               popularity INT NOT NULL,
                                               rate INT NOT NULL,
                                               loved INT NOT NULL,
-                                              mtime INT NOT NULL,
                                               synced INT NOT NULL)"""
     __create_artists = """CREATE TABLE artists (id INTEGER PRIMARY KEY,
                                                name TEXT NOT NULL,
@@ -57,6 +57,7 @@ class Database:
                                                 artist_id INT NOT NULL)"""
     __create_album_genres = """CREATE TABLE album_genres (
                                                 album_id INT NOT NULL,
+                                                mtime INT NOT NULL,
                                                 genre_id INT NOT NULL)"""
     __create_tracks = """CREATE TABLE tracks (id INTEGER PRIMARY KEY,
                                               name TEXT NOT NULL,
@@ -70,13 +71,14 @@ class Database:
                                               popularity INT NOT NULL,
                                               rate INT NOT NULL,
                                               ltime INT NOT NULL,
-                                              mtime INT NOT NULL
+                                              persistent INT NOT NULL DEFAULT 1
                                               )"""
     __create_track_artists = """CREATE TABLE track_artists (
                                                 track_id INT NOT NULL,
                                                 artist_id INT NOT NULL)"""
     __create_track_genres = """CREATE TABLE track_genres (
                                                 track_id INT NOT NULL,
+                                                mtime INT NOT NULL,
                                                 genre_id INT NOT NULL)"""
     __create_album_artists_idx = """CREATE index idx_aa ON album_artists(
                                                 album_id)"""
@@ -91,12 +93,12 @@ class Database:
         """
             Create database tables or manage update if needed
         """
-        f = Gio.File.new_for_path(self.DB_PATH)
+        f = Lio.File.new_for_path(self.DB_PATH)
         if not f.query_exists():
             db_version = Lp().settings.get_value("db-version").get_int32()
             upgrade = DatabaseUpgrade(db_version)
             try:
-                d = Gio.File.new_for_path(self.__LOCAL_PATH)
+                d = Lio.File.new_for_path(self.__LOCAL_PATH)
                 if not d.query_exists():
                     d.make_directory_with_parents()
                 # Create db schema
@@ -125,7 +127,7 @@ class Database:
         """
         db_version = Lp().settings.get_value("db-version").get_int32()
         upgrade = DatabaseUpgrade(db_version)
-        f = Gio.File.new_for_path(self.DB_PATH)
+        f = Lio.File.new_for_path(self.DB_PATH)
         if f.query_exists():
             upgrade.do_db_upgrade()
             Lp().settings.set_value("db-version",
diff --git a/lollypop/database_albums.py b/lollypop/database_albums.py
index 6b1bac38..7ec3bcc1 100644
--- a/lollypop/database_albums.py
+++ b/lollypop/database_albums.py
@@ -16,6 +16,7 @@ import itertools
 from lollypop.sqlcursor import SqlCursor
 from lollypop.define import Lp, Type, OrderBy
 from lollypop.utils import remove_static_genres, noaccents
+from lollypop.utils import get_network_available
 
 
 class AlbumsDatabase:
@@ -30,7 +31,7 @@ class AlbumsDatabase:
         self.__max_count = 1
         self._cached_randoms = []
 
-    def add(self, name, artist_ids, uri, loved, popularity, rate, mtime):
+    def add(self, name, artist_ids, uri, loved, popularity, rate):
         """
             Add a new album to database
             @param Album name as string
@@ -39,17 +40,16 @@ class AlbumsDatabase:
             @param loved as bool
             @param popularity as int
             @param rate as int
-            @param mtime as int
             @return inserted rowid as int
             @warning: commit needed
         """
         with SqlCursor(Lp().db) as sql:
             result = sql.execute("INSERT INTO albums\
                                   (name, no_album_artist,\
-                                  uri, loved, popularity, rate, mtime, synced)\
-                                  VALUES (?, ?, ?, ?, ?, ?, ?, ?)",
+                                  uri, loved, popularity, rate, synced)\
+                                  VALUES (?, ?, ?, ?, ?, ?, ?)",
                                  (name, artist_ids == [],
-                                  uri, loved, popularity, rate, mtime, 0))
+                                  uri, loved, popularity, rate, 0))
             for artist_id in artist_ids:
                 sql.execute("INSERT INTO album_artists\
                              (album_id, artist_id)\
@@ -70,20 +70,42 @@ class AlbumsDatabase:
                             "album_artists (album_id, artist_id)"
                             "VALUES (?, ?)", (album_id, artist_id))
 
-    def add_genre(self, album_id, genre_id):
+    def add_genre(self, album_id, genre_id, mtime):
         """
             Add genre to album
             @param album id as int
             @param genre id as int
+            @param mtime as int
+            @warning: commit needed
+        """
+        with SqlCursor(Lp().db) as sql:
+            # Check if already exists:
+            result = sql.execute("SELECT mtime FROM album_genres\
+                                  WHERE album_id=? AND genre_id=?",
+                                 (album_id, genre_id))
+            v = result.fetchone()
+            if v is not None:
+                sql.execute("UPDATE album_genres\
+                             SET mtime=?\
+                             WHERE album_id=? AND genre_id=?",
+                            (mtime, album_id, genre_id))
+            else:
+                genres = self.get_genre_ids(album_id)
+                if genre_id not in genres:
+                    sql.execute("INSERT INTO\
+                                 album_genres (album_id, genre_id, mtime)\
+                                 VALUES (?, ?, ?)",
+                                (album_id, genre_id, mtime))
+
+    def del_genres(self, album_id):
+        """
+            Delete all genres for album
+            @parma album id as int
             @warning: commit needed
         """
         with SqlCursor(Lp().db) as sql:
-            genres = self.get_genre_ids(album_id)
-            if genre_id not in genres:
-                sql.execute("INSERT INTO\
-                             album_genres (album_id, genre_id)\
-                             VALUES (?, ?)",
-                            (album_id, genre_id))
+            sql.execute("DELETE FROM album_genres "
+                        "WHERE album_id=?", (album_id,))
 
     def set_artist_ids(self, album_id, artist_ids):
         """
@@ -228,10 +250,17 @@ class AlbumsDatabase:
             @param year as str
         """
         with SqlCursor(Lp().db) as sql:
-            filters = (year, )
+            filters = (Type.CHARTS, year)
             request = "SELECT DISTINCT albums.rowid\
-                       FROM albums\
-                       WHERE year=?"
+                       FROM albums, album_genres AS AG\
+                       WHERE ? NOT IN (\
+                            SELECT album_genres.genre_id\
+                            FROM album_genres\
+                            WHERE AG.album_id=album_genres.album_id)\
+                       AND year=?\
+                       AND AG.album_id=albums.rowid"
+            if not get_network_available():
+                request += " AND albums.synced!=%s" % Type.NONE
             result = sql.execute(request, filters)
             return list(itertools.chain(*result))
 
@@ -246,7 +275,35 @@ class AlbumsDatabase:
                                  rowid=?", (album_id,))
 
             v = result.fetchone()
-            if v:
+            if v is not None:
+                return v[0]
+            return Type.NONE
+
+    def get_mtime(self, album_id, genre_ids=[]):
+        """
+            Get modification time, if genre_ids empty, only local albums
+            @param album_id as int
+            @param genre_ids as [int]
+            @return modification time as int
+        """
+        with SqlCursor(Lp().db) as sql:
+            if genre_ids:
+                filters = tuple([album_id] + genre_ids)
+                request = "SELECT mtime FROM album_genres\
+                           WHERE album_id=?"
+                for genre_id in genre_ids:
+                    request += " AND genre_id=?"
+            else:
+                filters = (album_id,)
+                request = "SELECT mtime FROM album_genres AS AG\
+                           WHERE AG.album_id=?\
+                           AND NOT EXISTS (\
+                                SELECT mtime FROM album_genres\
+                                WHERE album_id=AG.album_id\
+                                AND genre_id < 0)"
+            result = sql.execute(request, filters)
+            v = result.fetchone()
+            if v is not None:
                 return v[0]
             return 0
 
@@ -300,11 +357,12 @@ class AlbumsDatabase:
                 return v[0]
             return 5
 
-    def get_id(self, album_name, artist_ids):
+    def get_id(self, album_name, artist_ids, remote):
         """
             Get non compilation album id
             @param Album name as string,
             @param artist ids as [int]
+            @param remote as bool
             @return Album id as int
         """
         with SqlCursor(Lp().db) as sql:
@@ -318,10 +376,18 @@ class AlbumsDatabase:
                 for artist_id in artist_ids:
                     request += "OR artist_id=? "
                 request += ")"
+                if remote:
+                    request += " AND synced=%s" % Type.NONE
+                else:
+                    request += " AND synced!=%s" % Type.NONE
             else:
                 request = "SELECT rowid FROM albums\
                            WHERE name=?\
                            AND no_album_artist=1"
+                if remote:
+                    request += " AND synced=%s" % Type.NONE
+                else:
+                    request += " AND synced!=%s" % Type.NONE
             result = sql.execute(request, filters)
             v = result.fetchone()
             if v is not None:
@@ -464,11 +530,19 @@ class AlbumsDatabase:
             @return array of album ids as int
         """
         with SqlCursor(Lp().db) as sql:
+            filters = (Type.CHARTS, )
             request = "SELECT DISTINCT albums.rowid\
-                       FROM albums\
-                       WHERE rate>=4\
-                       ORDER BY popularity DESC LIMIT ?"
-            result = sql.execute(request, (limit,))
+                       FROM albums, album_genres as AG\
+                       WHERE ? NOT IN (\
+                            SELECT album_genres.genre_id\
+                            FROM album_genres\
+                            WHERE AG.album_id=album_genres.album_id)\
+                       AND rate>=4\
+                       AND AG.album_id=albums.rowid"
+            if not get_network_available():
+                request += " AND albums.synced!=%s" % Type.NONE
+            request += " ORDER BY popularity DESC LIMIT %s" % limit
+            result = sql.execute(request, filters)
             return list(itertools.chain(*result))
 
     def get_populars(self, limit=100):
@@ -478,11 +552,19 @@ class AlbumsDatabase:
             @return array of album ids as int
         """
         with SqlCursor(Lp().db) as sql:
+            filters = (Type.CHARTS, )
             request = "SELECT DISTINCT albums.rowid\
-                       FROM albums\
-                       WHERE popularity!=0\
-                       ORDER BY popularity DESC LIMIT ?"
-            result = sql.execute(request, (limit,))
+                       FROM albums, album_genres as AG\
+                       WHERE ? NOT IN (\
+                            SELECT album_genres.genre_id\
+                            FROM album_genres\
+                            WHERE AG.album_id=album_genres.album_id)\
+                       AND popularity!=0\
+                       AND AG.album_id=albums.rowid"
+            if not get_network_available():
+                request += " AND albums.synced!=%s" % Type.NONE
+            request += " ORDER BY popularity DESC LIMIT %s" % limit
+            result = sql.execute(request, filters)
             return list(itertools.chain(*result))
 
     def get_loves(self):
@@ -491,11 +573,19 @@ class AlbumsDatabase:
             @return array of album ids as int
         """
         with SqlCursor(Lp().db) as sql:
+            filters = (Type.CHARTS, )
             request = "SELECT DISTINCT albums.rowid\
-                       FROM albums\
-                       WHERE loved=1\
-                       ORDER BY popularity DESC"
-            result = sql.execute(request)
+                       FROM albums, album_genres as AG\
+                       WHERE ? NOT IN (\
+                            SELECT album_genres.genre_id\
+                            FROM album_genres\
+                            WHERE AG.album_id=album_genres.album_id)\
+                       AND loved=1\
+                       AND AG.album_id=albums.rowid"
+            if not get_network_available():
+                request += " AND albums.synced!=%s" % Type.NONE
+            request += " ORDER BY popularity DESC"
+            result = sql.execute(request, filters)
             return list(itertools.chain(*result))
 
     def get_recents(self):
@@ -504,10 +594,18 @@ class AlbumsDatabase:
             @return array of albums ids as int
         """
         with SqlCursor(Lp().db) as sql:
+            filters = (Type.CHARTS, )
             request = "SELECT DISTINCT albums.rowid\
-                       FROM albums\
-                       ORDER BY mtime DESC LIMIT 100"
-            result = sql.execute(request)
+                       FROM albums, album_genres as AG\
+                       WHERE ? NOT IN (\
+                            SELECT album_genres.genre_id\
+                            FROM album_genres\
+                            WHERE AG.album_id=album_genres.album_id)\
+                       AND AG.album_id=albums.rowid"
+            if not get_network_available():
+                request += " AND albums.synced!=%s" % Type.NONE
+            request += " ORDER BY mtime DESC LIMIT 100"
+            result = sql.execute(request, filters)
             return list(itertools.chain(*result))
 
     def get_randoms(self):
@@ -517,9 +615,18 @@ class AlbumsDatabase:
         """
         with SqlCursor(Lp().db) as sql:
             albums = []
+            filters = (Type.CHARTS, )
             request = "SELECT DISTINCT albums.rowid\
-                       FROM albums ORDER BY random() LIMIT 100"
-            result = sql.execute(request)
+                       FROM albums, album_genres as AG\
+                       WHERE ? NOT IN (\
+                            SELECT album_genres.genre_id\
+                            FROM album_genres\
+                            WHERE AG.album_id=album_genres.album_id)\
+                       AND AG.album_id=albums.rowid"
+            if not get_network_available():
+                request += " AND albums.synced!=%s" % Type.NONE
+            request += " ORDER BY random() LIMIT 100"
+            result = sql.execute(request, filters)
             albums = list(itertools.chain(*result))
             self._cached_randoms = list(albums)
             return albums
@@ -731,6 +838,43 @@ class AlbumsDatabase:
                 return v[0]
             return 0
 
+    def get_charts_ids(self, genre_ids=[]):
+        """
+            Get charts album ids
+            @param genre ids as [int]
+            @return albums ids as [int]
+        """
+        result = []
+        if genre_ids:
+            order = " ORDER BY mtime DESC,"
+        else:
+            order = " ORDER BY"
+        order += " artists.sortname\
+                   COLLATE NOCASE COLLATE LOCALIZED,\
+                   albums.year,\
+                   albums.name\
+                   COLLATE NOCASE COLLATE LOCALIZED"
+        with SqlCursor(Lp().db) as sql:
+            filters = tuple([Type.CHARTS] + genre_ids)
+            request = "SELECT DISTINCT albums.rowid FROM albums,\
+                       album_genres, artists, album_artists\
+                       WHERE EXISTS (\
+                            SELECT album_genres.album_id\
+                            FROM album_genres\
+                            WHERE albums.rowid = album_genres.album_id\
+                            AND album_genres.genre_id=?)\
+                       AND artists.rowid=album_artists.artist_id\
+                       AND albums.rowid=album_artists.album_id\
+                       AND album_genres.album_id=albums.rowid AND ("
+            for genre_id in genre_ids:
+                request += "album_genres.genre_id=? OR "
+            request += "1=0)"
+            if not get_network_available():
+                request += " AND albums.synced!=%s" % Type.NONE
+            request += order
+            result = sql.execute(request, filters)
+            return list(itertools.chain(*result))
+
     def get_ids(self, artist_ids=[], genre_ids=[]):
         """
             Get albums ids
@@ -762,52 +906,89 @@ class AlbumsDatabase:
             result = []
             # Get albums for all artists
             if not artist_ids and not genre_ids:
+                filters = (Type.CHARTS,)
                 request = "SELECT DISTINCT albums.rowid\
-                           FROM albums, album_artists, artists\
-                           WHERE albums.rowid = album_artists.album_id AND\
-                           artists.rowid = album_artists.artist_id"
+                           FROM albums, artists,\
+                           album_artists, album_genres as AG\
+                           WHERE artists.rowid=album_artists.artist_id\
+                           AND ? NOT IN (\
+                                SELECT album_genres.genre_id\
+                                FROM album_genres\
+                                WHERE AG.album_id=album_genres.album_id)\
+                           AND AG.album_id=albums.rowid\
+                           AND albums.rowid=album_artists.album_id"
+                if not get_network_available():
+                    request += " AND albums.synced!=%s" % Type.NONE
                 request += order
-                result = sql.execute(request)
-            # Get albums for genres
+                result = sql.execute(request, filters)
+            # Get albums for genre
             elif not artist_ids:
-                filters = tuple(genre_ids)
+                # Only show charts if wanted
+                if Type.CHARTS in genre_ids:
+                    filters = tuple(genre_ids)
+                else:
+                    filters = (Type.CHARTS,) + tuple(genre_ids)
                 request = "SELECT DISTINCT albums.rowid FROM albums,\
-                           album_genres, album_artists, artists\
-                           WHERE albums.rowid = album_artists.album_id AND\
-                           artists.rowid = album_artists.artist_id AND\
-                           album_genres.album_id=albums.rowid AND ( "
+                           album_genres as AG, artists, album_artists\
+                           WHERE artists.rowid=album_artists.artist_id\
+                           AND albums.rowid=album_artists.album_id "
+                if Type.CHARTS not in genre_ids:
+                    request += "AND ? NOT IN (\
+                                  SELECT album_genres.genre_id\
+                                  FROM album_genres\
+                                  WHERE AG.album_id=album_genres.album_id)"
+                request += " AND AG.album_id=albums.rowid AND ( "
                 for genre_id in genre_ids:
-                    request += "album_genres.genre_id=? OR "
+                    request += "AG.genre_id=? OR "
                 request += "1=0)"
+                if not get_network_available():
+                    request += " AND albums.synced!=%s" % Type.NONE
                 request += order
                 result = sql.execute(request, filters)
             # Get albums for artist
             elif not genre_ids:
-                filters = tuple(artist_ids)
+                filters = (Type.CHARTS,)
+                filters += tuple(artist_ids)
                 request = "SELECT DISTINCT albums.rowid\
-                           FROM albums, album_artists, artists\
-                           WHERE album_artists.album_id=albums.rowid AND\
-                           artists.rowid = album_artists.artist_id AND ("
+                           FROM albums, artists,\
+                           album_artists, album_genres as AG\
+                           WHERE artists.rowid=album_artists.artist_id\
+                           AND ? NOT IN (\
+                                SELECT album_genres.genre_id\
+                                FROM album_genres\
+                                WHERE AG.album_id=album_genres.album_id)\
+                           AND AG.album_id=albums.rowid\
+                           AND album_artists.album_id=albums.rowid AND ("
                 for artist_id in artist_ids:
-                    request += "artists.rowid=? OR "
+                    request += "album_artists.artist_id=? OR "
                 request += "1=0)"
+                if not get_network_available():
+                    request += " AND albums.synced!=%s" % Type.NONE
                 request += order
                 result = sql.execute(request, filters)
             # Get albums for artist id and genre id
             else:
-                filters = tuple(artist_ids)
+                filters = (Type.CHARTS,)
+                filters += tuple(artist_ids)
                 filters += tuple(genre_ids)
                 request = "SELECT DISTINCT albums.rowid\
-                           FROM albums, album_genres, album_artists, artists\
-                           WHERE album_genres.album_id=albums.rowid AND\
-                           artists.rowid = album_artists.artist_id AND\
-                           album_artists.album_id=albums.rowid AND ("
+                           FROM albums, album_genres as AG,\
+                           artists, album_artists\
+                           WHERE AG.album_id=albums.rowid\
+                           AND artists.rowid=album_artists.artist_id\
+                           AND ? NOT IN (\
+                                SELECT album_genres.genre_id\
+                                FROM album_genres\
+                                WHERE AG.album_id=album_genres.album_id)\
+                           AND album_artists.album_id=albums.rowid AND ("
                 for artist_id in artist_ids:
-                    request += "artists.rowid=? OR "
+                    request += "album_artists.artist_id=? OR "
                 request += "1=0) AND ("
                 for genre_id in genre_ids:
-                    request += "album_genres.genre_id=? OR "
+                    request += "AG.genre_id=? OR "
                 request += "1=0)"
+                if not get_network_available():
+                    request += " AND albums.synced!=%s" % Type.NONE
                 request += order
                 result = sql.execute(request, filters)
             return list(itertools.chain(*result))
@@ -883,20 +1064,6 @@ class AlbumsDatabase:
                                  (album_id,))
             return list(itertools.chain(*result))
 
-    def get_never_listened_to(self):
-        """
-            Return random albums never listened to
-            @return album ids as [int]
-        """
-        with SqlCursor(Lp().db) as sql:
-            result = sql.execute("SELECT DISTINCT albums.rowid\
-                                  FROM albums, tracks\
-                                  WHERE tracks.ltime=0 AND\
-                                  albums.rowid=tracks.album_id\
-                                  AND albums.popularity < 10\
-                                  ORDER BY random() LIMIT 100")
-            return list(itertools.chain(*result))
-
     def has_loves(self):
         """
             True if db has loved albums
@@ -907,6 +1074,9 @@ class AlbumsDatabase:
             request = "SELECT albums.rowid\
                        FROM albums\
                        WHERE loved=1"
+            if not get_network_available():
+                request += " AND albums.synced!=?"
+                filters = (Type.NONE, )
             request += " LIMIT 1"
             result = sql.execute(request, filters)
             return list(itertools.chain(*result)) != []
@@ -920,12 +1090,17 @@ class AlbumsDatabase:
         """
         with SqlCursor(Lp().db) as sql:
             if limit is None:
-                filters = ("%" + noaccents(string) + "%",)
+                filters = ("%" + noaccents(string) + "%", Type.CHARTS)
             else:
-                filters = ("%" + noaccents(string) + "%", limit)
+                filters = ("%" + noaccents(string) + "%", Type.CHARTS, limit)
             request = ("SELECT albums.rowid\
-                       FROM albums\
-                       WHERE noaccents(name) LIKE ?")
+                       FROM albums, album_genres AS AG\
+                       WHERE noaccents(name) LIKE ?\
+                       AND ? NOT IN (\
+                                SELECT album_genres.genre_id\
+                                FROM album_genres\
+                                WHERE AG.album_id=album_genres.album_id)\
+                       AND AG.album_id=albums.rowid")
             if limit is not None:
                 request += " LIMIT ?"
             result = sql.execute(request, filters)
@@ -958,7 +1133,11 @@ class AlbumsDatabase:
             @return int
         """
         with SqlCursor(Lp().db) as sql:
-            result = sql.execute("SELECT COUNT(1) FROM albums")
+            result = sql.execute("SELECT COUNT(1)\
+                                  FROM albums, album_genres\
+                                  WHERE album_genres.genre_id!=?\
+                                  AND album_genres.album_id=albums.rowid",
+                                 (Type.CHARTS,))
             v = result.fetchone()
             if v is not None:
                 return v[0]
diff --git a/lollypop/database_artists.py b/lollypop/database_artists.py
index b08838b6..b698699d 100644
--- a/lollypop/database_artists.py
+++ b/lollypop/database_artists.py
@@ -110,8 +110,11 @@ class ArtistsDatabase:
         """
         with SqlCursor(Lp().db) as sql:
             request = "SELECT DISTINCT albums.rowid\
-                       FROM album_artists, albums\
-                       WHERE albums.rowid=album_artists.album_id AND(1=0 "
+                       FROM album_artists, albums, album_genres\
+                       WHERE albums.rowid=album_artists.album_id AND\
+                       album_genres.genre_id!=%s AND\
+                       albums.rowid=album_genres.album_id AND\
+                       (1=0 " % Type.CHARTS
             for artist_id in artist_ids:
                 request += "OR album_artists.artist_id=%s " % artist_id
             request += ") ORDER BY year"
@@ -150,21 +153,33 @@ class ArtistsDatabase:
                 result = sql.execute(
                                  "SELECT DISTINCT artists.rowid,\
                                   artists.name, artists.sortname\
-                                  FROM artists, albums, album_artists\
+                                  FROM artists, albums,\
+                                  album_genres AS AG, album_artists\
                                   WHERE album_artists.artist_id=artists.rowid\
                                   AND album_artists.album_id=albums.rowid\
+                                  AND AG.album_id=albums.rowid\
+                                  AND ? NOT IN (\
+                                    SELECT album_genres.genre_id\
+                                    FROM album_genres\
+                                    WHERE AG.album_id=album_genres.album_id)\
                                   ORDER BY artists.sortname\
-                                  COLLATE NOCASE COLLATE LOCALIZED")
+                                  COLLATE NOCASE COLLATE LOCALIZED",
+                                 (Type.CHARTS,))
             else:
-                genres = tuple(genre_ids)
+                genres = (Type.CHARTS,) + tuple(genre_ids)
                 request = "SELECT DISTINCT artists.rowid,\
                            artists.name, artists.sortname\
-                           FROM artists, albums, album_genres, album_artists\
+                           FROM artists, albums, album_genres AS AG,\
+                           album_artists\
                            WHERE artists.rowid=album_artists.artist_id\
+                           AND ? NOT IN (\
+                                    SELECT album_genres.genre_id\
+                                    FROM album_genres\
+                                    WHERE AG.album_id=album_genres.album_id)\
                            AND albums.rowid=album_artists.album_id\
-                           AND album_genres.album_id=albums.rowid AND ("
+                           AND AG.album_id=albums.rowid AND ("
                 for genre_id in genre_ids:
-                    request += "album_genres.genre_id=? OR "
+                    request += "AG.genre_id=? OR "
                 request += "1=0) ORDER BY artists.sortname\
                             COLLATE NOCASE COLLATE LOCALIZED"
                 result = sql.execute(request, genres)
@@ -201,11 +216,15 @@ class ArtistsDatabase:
                 # Only artist that really have an album
                 result = sql.execute(
                                  "SELECT DISTINCT artists.rowid\
-                                  FROM artists, albums, album_artists\
+                                  FROM artists, albums,\
+                                  album_genres, album_artists\
                                   WHERE album_artists.artist_id=artists.rowid\
                                   AND album_artists.album_id=albums.rowid\
+                                  AND album_genres.album_id=albums.rowid\
+                                  AND album_genres.genre_id!=?\
                                   ORDER BY artists.sortname\
-                                  COLLATE NOCASE COLLATE LOCALIZED")
+                                  COLLATE NOCASE COLLATE LOCALIZED",
+                                 (Type.CHARTS,))
             else:
                 genres = tuple(genre_ids)
                 request = "SELECT DISTINCT artists.rowid\
@@ -241,11 +260,17 @@ class ArtistsDatabase:
         """
         with SqlCursor(Lp().db) as sql:
             result = sql.execute("SELECT artists.rowid FROM artists, albums,\
-                                  album_artists\
+                                  album_genres AS AG, album_artists\
                                   WHERE noaccents(artists.name) LIKE ?\
                                   AND album_artists.artist_id=artists.rowid\
                                   AND album_artists.album_id=albums.rowid\
-                                  LIMIT 25", ("%" + noaccents(string) + "%",))
+                                  AND AG.album_id=albums.rowid\
+                                  AND ? NOT IN (\
+                                    SELECT album_genres.genre_id\
+                                    FROM album_genres\
+                                    WHERE AG.album_id=album_genres.album_id)\
+                                  LIMIT 25", ("%" + noaccents(string) + "%",
+                                              Type.CHARTS))
             return list(itertools.chain(*result))
 
     def count(self):
@@ -255,9 +280,13 @@ class ArtistsDatabase:
         """
         with SqlCursor(Lp().db) as sql:
             result = sql.execute("SELECT COUNT(DISTINCT artists.rowid)\
-                                  FROM artists, album_artists, albums\
+                                  FROM artists, album_artists,\
+                                  album_genres, albums\
                                   WHERE album_artists.album_id=albums.rowid\
-                                  AND artists.rowid=album_artists.artist_id")
+                                  AND artists.rowid=album_artists.artist_id\
+                                  AND album_genres.album_id=albums.rowid\
+                                  AND album_genres.genre_id!=?",
+                                 (Type.CHARTS,))
             v = result.fetchone()
             if v is not None:
                 return v[0]
diff --git a/lollypop/database_genres.py b/lollypop/database_genres.py
index 42db83b2..b26da2a7 100644
--- a/lollypop/database_genres.py
+++ b/lollypop/database_genres.py
@@ -104,9 +104,15 @@ class GenresDatabase:
         """
         with SqlCursor(Lp().db) as sql:
             result = sql.execute("SELECT DISTINCT genres.rowid, genres.name\
-                                  FROM genres\
+                                  FROM genres,album_genres AS AG\
+                                  WHERE AG.genre_id=genres.rowid\
+                                  AND ? NOT IN (\
+                                    SELECT album_genres.genre_id\
+                                    FROM album_genres\
+                                    WHERE AG.album_id=album_genres.album_id)\
                                   ORDER BY genres.name\
-                                  COLLATE NOCASE COLLATE LOCALIZED")
+                                  COLLATE NOCASE COLLATE LOCALIZED",
+                                 (Type.CHARTS,))
             return list(result)
 
     def get_ids(self):
@@ -116,11 +122,36 @@ class GenresDatabase:
         """
         with SqlCursor(Lp().db) as sql:
             result = sql.execute("SELECT DISTINCT genres.rowid\
-                                  FROM genres\
+                                  FROM genres,album_genres AS AG\
+                                  WHERE AG.genre_id=genres.rowid\
+                                  AND ? NOT IN (\
+                                    SELECT album_genres.genre_id\
+                                    FROM album_genres\
+                                    WHERE AG.album_id=album_genres.album_id)\
                                   ORDER BY genres.name\
-                                  COLLATE NOCASE COLLATE LOCALIZED")
+                                  COLLATE NOCASE COLLATE LOCALIZED",
+                                 (Type.CHARTS,))
             return list(itertools.chain(*result))
 
+    def get_charts(self, filter=Type.CHARTS):
+        """
+            Get genre for charts
+            @param filter as Type
+            @return [(id as int, name as string)]
+        """
+        with SqlCursor(Lp().db) as sql:
+            result = sql.execute("SELECT DISTINCT genres.rowid, genres.name\
+                                  FROM genres,album_genres AS AG\
+                                  WHERE AG.genre_id=genres.rowid\
+                                  AND ? IN (\
+                                    SELECT album_genres.genre_id\
+                                    FROM album_genres\
+                                    WHERE AG.album_id=album_genres.album_id)\
+                                  ORDER BY genres.name\
+                                  COLLATE NOCASE COLLATE LOCALIZED",
+                                 (filter,))
+            return list(result)
+
     def clean(self, genre_id):
         """
             Clean database for genre id
diff --git a/lollypop/database_tracks.py b/lollypop/database_tracks.py
index 8eba1f13..bb2642da 100644
--- a/lollypop/database_tracks.py
+++ b/lollypop/database_tracks.py
@@ -15,8 +15,8 @@ from gettext import gettext as _
 import itertools
 
 from lollypop.sqlcursor import SqlCursor
-from lollypop.define import Lp
-from lollypop.utils import noaccents
+from lollypop.define import Lp, Type, DbPersistent
+from lollypop.utils import noaccents, get_network_available
 
 
 class TracksDatabase:
@@ -32,7 +32,8 @@ class TracksDatabase:
         pass
 
     def add(self, name, uri, duration, tracknumber, discnumber,
-            discname, album_id, year, popularity, rate, ltime, mtime):
+            discname, album_id, year, popularity, rate, ltime,
+            persistent=DbPersistent.INTERNAL):
         """
             Add a new track to database
             @param name as string
@@ -47,7 +48,7 @@ class TracksDatabase:
             @param popularity as int
             @param rate as int
             @param ltime as int
-            @param mtime as int
+            @param persistent as int
             @return inserted rowid as int
             @warning: commit needed
         """
@@ -55,7 +56,7 @@ class TracksDatabase:
             result = sql.execute(
                 "INSERT INTO tracks (name, uri, duration, tracknumber,\
                 discnumber, discname, album_id,\
-                year, popularity, rate, ltime, mtime) VALUES\
+                year, popularity, rate, ltime, persistent) VALUES\
                 (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)", (
                                                         name,
                                                         uri,
@@ -68,7 +69,7 @@ class TracksDatabase:
                                                         popularity,
                                                         rate,
                                                         ltime,
-                                                        mtime))
+                                                        persistent))
             return result.lastrowid
 
     def add_artist(self, track_id, artist_id):
@@ -85,20 +86,42 @@ class TracksDatabase:
                             "track_artists (track_id, artist_id)"
                             "VALUES (?, ?)", (track_id, artist_id))
 
-    def add_genre(self, track_id, genre_id):
+    def add_genre(self, track_id, genre_id, mtime):
         """
             Add genre to track
             @param track id as int
             @param genre id as int
+            @param mtime as int
+            @warning: commit needed
+        """
+        with SqlCursor(Lp().db) as sql:
+            # Check if already exists:
+            result = sql.execute("SELECT mtime FROM track_genres\
+                                  WHERE track_id=? AND genre_id=?",
+                                 (track_id, genre_id))
+            v = result.fetchone()
+            if v is not None:
+                sql.execute("UPDATE track_genres\
+                             SET mtime=?\
+                             WHERE track_id=? AND genre_id=?",
+                            (mtime, track_id, genre_id))
+            else:
+                genres = self.get_genre_ids(track_id)
+                if genre_id not in genres:
+                    sql.execute("INSERT INTO\
+                                 track_genres (track_id, genre_id, mtime)\
+                                 VALUES (?, ?, ?)",
+                                (track_id, genre_id, mtime))
+
+    def del_genres(self, track_id):
+        """
+            Delete all genres for track
+            @parma album id as int
             @warning: commit needed
         """
         with SqlCursor(Lp().db) as sql:
-            genres = self.get_genre_ids(track_id)
-            if genre_id not in genres:
-                sql.execute("INSERT INTO\
-                             track_genres (track_id, genre_id)\
-                             VALUES (?, ?)",
-                            (track_id, genre_id))
+            sql.execute("DELETE FROM track_genres "
+                        "WHERE track_id=?", (track_id,))
 
     def get_ids(self):
         """
@@ -106,7 +129,9 @@ class TracksDatabase:
             @return track ids as [int]
         """
         with SqlCursor(Lp().db) as sql:
-            result = sql.execute("SELECT rowid FROM tracks")
+            result = sql.execute("SELECT rowid FROM tracks\
+                                  WHERE persistent=?",
+                                 (DbPersistent.INTERNAL,))
             return list(itertools.chain(*result))
 
     def get_ids_for_name(self, name):
@@ -122,6 +147,40 @@ class TracksDatabase:
                                  (name,))
             return list(itertools.chain(*result))
 
+    def get_charts_ids(self, genre_ids=[]):
+        """
+            Get charts track ids
+            @param genre ids as [int]
+            @return albums ids as [int]
+        """
+        result = []
+        order = " ORDER BY mtime DESC,\
+                 artists.sortname\
+                 COLLATE NOCASE COLLATE LOCALIZED,\
+                 tracks.year,\
+                 tracks.name\
+                 COLLATE NOCASE COLLATE LOCALIZED"
+        with SqlCursor(Lp().db) as sql:
+            filters = tuple([Type.CHARTS] + genre_ids)
+            request = "SELECT DISTINCT tracks.rowid FROM tracks,\
+                       track_genres, artists, track_artists\
+                       WHERE EXISTS (\
+                            SELECT track_genres.track_id\
+                            FROM track_genres\
+                            WHERE tracks.rowid = track_genres.track_id\
+                            AND track_genres.genre_id=?)\
+                       AND artists.rowid=track_artists.artist_id\
+                       AND tracks.rowid=track_artists.track_id\
+                       AND track_genres.track_id=tracks.rowid AND ("
+            for genre_id in genre_ids:
+                request += "track_genres.genre_id=? OR "
+            request += "1=0)"
+            if not get_network_available():
+                request += " AND tracks.persistent=%s" % DbPersistent.NONE
+            request += order
+            result = sql.execute(request, filters)
+            return list(itertools.chain(*result))
+
     def get_id_by_uri(self, uri):
         """
             Return track id for uri
@@ -200,9 +259,9 @@ class TracksDatabase:
             result = sql.execute("SELECT rate FROM tracks WHERE rowid=?",
                                  (track_id,))
             v = result.fetchone()
-            if v:
+            if v and v[0]:
                 return v[0]
-            return 0
+            return Type.NONE
 
     def get_uri(self, track_id):
         """
@@ -330,8 +389,11 @@ class TracksDatabase:
         """
         with SqlCursor(Lp().db) as sql:
             mtimes = {}
-            result = sql.execute("SELECT DISTINCT uri, mtime\
-                                  FROM tracks")
+            result = sql.execute("SELECT DISTINCT tracks.uri, TG.mtime\
+                                  FROM tracks, track_genres AS TG\
+                                  WHERE tracks.rowid=TG.track_id\
+                                  AND tracks.persistent=?",
+                                 (DbPersistent.INTERNAL,))
             for row in result:
                 mtimes.update((row,))
             return mtimes
@@ -343,11 +405,11 @@ class TracksDatabase:
             @return Array of uri as string
         """
         with SqlCursor(Lp().db) as sql:
-            filters = ()
+            filters = (DbPersistent.INTERNAL,)
             for e in exclude:
                 filters += ("%" + e + "%",)
             request = "SELECT uri FROM tracks\
-                       WHERE 1=1"
+                       WHERE persistent=?"
             for e in exclude:
                 request += " AND uri not like ?"
             result = sql.execute(request, filters)
@@ -412,16 +474,19 @@ class TracksDatabase:
         """
         with SqlCursor(Lp().db) as sql:
             result = sql.execute("SELECT tracks.rowid, tracks.name\
-                                 FROM tracks, track_artists, album_artists\
+                                 FROM tracks, track_artists,\
+                                 track_genres, album_artists\
                                  WHERE album_artists.album_id=tracks.album_id\
                                  AND track_artists.artist_id=?\
                                  AND track_artists.track_id=tracks.rowid\
+                                 AND track_genres.track_id=tracks.rowid\
+                                 AND track_genres.genre_id!=?\
                                  AND NOT EXISTS (\
                                   SELECT artist_id\
                                   FROM album_artists\
                                   WHERE artist_id=track_artists.artist_id\
                                   AND album_id=tracks.album_id)",
-                                 (artist_id,))
+                                 (artist_id, Type.CHARTS))
             return list(result)
 
     def get_rated(self, limit=100):
@@ -502,9 +567,12 @@ class TracksDatabase:
         """
         with SqlCursor(Lp().db) as sql:
             result = sql.execute("SELECT tracks.rowid\
-                                  FROM tracks\
+                                  FROM tracks, track_genres\
                                   WHERE ltime=0\
-                                  ORDER BY random() LIMIT 100")
+                                  AND track_genres.genre_id!=?\
+                                  AND track_genres.track_id=tracks.rowid\
+                                  ORDER BY random() LIMIT 100",
+                                 (Type.CHARTS,))
             return list(itertools.chain(*result))
 
     def get_recently_listened_to(self):
@@ -514,9 +582,12 @@ class TracksDatabase:
         """
         with SqlCursor(Lp().db) as sql:
             result = sql.execute("SELECT tracks.rowid\
-                                  FROM tracks\
+                                  FROM tracks, track_genres\
                                   WHERE ltime!=0\
-                                  ORDER BY ltime DESC LIMIT 100")
+                                  AND track_genres.genre_id!=?\
+                                  AND track_genres.track_id=tracks.rowid\
+                                  ORDER BY ltime DESC LIMIT 100",
+                                 (Type.CHARTS,))
             return list(itertools.chain(*result))
 
     def get_persistent(self, track_id):
@@ -545,6 +616,17 @@ class TracksDatabase:
                          WHERE rowid=?", (persistent, track_id,))
             sql.commit()
 
+    def get_non_persistent(self):
+        """
+            Return non persistent tracks
+            @return track ids as [int]
+        """
+        with SqlCursor(Lp().db) as sql:
+            # First tracks loaded by play on search
+            result = sql.execute("SELECT rowid FROM tracks\
+                                  WHERE persistent=0")
+            return list(itertools.chain(*result))
+
     def get_randoms(self):
         """
             Return random tracks
@@ -552,8 +634,10 @@ class TracksDatabase:
         """
         with SqlCursor(Lp().db) as sql:
             result = sql.execute("SELECT tracks.rowid\
-                                  FROM tracks\
-                                  ORDER BY random() LIMIT 100")
+                                  FROM tracks, track_genres\
+                                  WHERE track_genres.genre_id!=?\
+                                  AND track_genres.track_id=tracks.rowid\
+                                  ORDER BY random() LIMIT 100", (Type.CHARTS,))
             return list(itertools.chain(*result))
 
     def set_popularity(self, track_id, popularity, commit=False):
@@ -573,9 +657,7 @@ class TracksDatabase:
                 pass
 
     def get_popularity(self, track_id):
-        """ème a déjà été remonté en début de semaine et semble ancien.
-Nous traitons le problème dès que possible (salle très occupée).
-
+        """
             Get popularity
             @param track id  as int
             @return popularity as int
@@ -602,28 +684,79 @@ Nous traitons le problème dès que possible (salle très occupée).
                 return v[0]
             return 0
 
-    def get_mtime(self, track_id):
+    def get_mtime(self, track_id, genre_ids=[]):
         """
             Get modification time, if genre_ids empty, only local tracks
             @param track_id as int
+            @param genre_ids as [int]
             @return modification time as int
         """
         with SqlCursor(Lp().db) as sql:
-            request = "SELECT mtime FROM tracks\
-                       WHERE tracks.rowid=?"
-            result = sql.execute(request, (track_id,))
+            if genre_ids:
+                filters = tuple([track_id] + genre_ids)
+                request = "SELECT mtime FROM track_genres\
+                           WHERE track_id=?"
+                for genre_id in genre_ids:
+                    request += " AND genre_id=?"
+            else:
+                filters = (track_id,)
+                request = "SELECT mtime FROM track_genres AS TG\
+                           WHERE TG.track_id=?\
+                           AND NOT EXISTS (\
+                                SELECT mtime FROM track_genres\
+                                WHERE track_id=TG.track_id\
+                                AND genre_id < 0)"
+            result = sql.execute(request, filters)
             v = result.fetchone()
             if v is not None:
                 return v[0]
             return 0
 
+    def get_old_charts_track_ids(self, time):
+        """
+            Return old tracks from charts
+            @param time as int
+            @return track ids as [int]
+        """
+        with SqlCursor(Lp().db) as sql:
+            # First tracks loaded by play on search
+            result = sql.execute("SELECT tracks.rowid\
+                                  FROM tracks, track_genres\
+                                  WHERE track_genres.track_id=tracks.rowid\
+                                  AND track_genres.genre_id=?\
+                                  AND track_genres.mtime < ?",
+                                 (Type.CHARTS, time))
+            return list(itertools.chain(*result))
+
+    def set_mtime(self, track_id, genre_ids, mtime):
+        """
+            Get modification time
+            @param track id  as int
+            @param mtime as int
+        """
+        with SqlCursor(Lp().db) as sql:
+            filters = (mtime, track_id,) + tuple(genre_ids)
+            request = "UPDATE track_genres\
+                       SET mtime=?\
+                       WHERE track_id=?\
+                       AND ("
+            for genre_id in genre_ids:
+                request += "genre_id=? OR "
+            request += "1=0)"
+            sql.execute(request, filters)
+            sql.commit()
+
     def count(self):
         """
             Count albums
             @return int
         """
         with SqlCursor(Lp().db) as sql:
-            result = sql.execute("SELECT COUNT(1) FROM tracks")
+            result = sql.execute("SELECT COUNT(1)\
+                                  FROM tracks, track_genres\
+                                  WHERE tracks.rowid = track_genres.track_id\
+                                  AND track_genres.genre_id!=?",
+                                 (Type.CHARTS,))
             v = result.fetchone()
             if v is not None:
                 return v[0]
@@ -649,9 +782,16 @@ Nous traitons le problème dès que possible (salle très occupée).
         """
         with SqlCursor(Lp().db) as sql:
             result = sql.execute("SELECT tracks.rowid, tracks.name\
-                                  FROM tracks\
-                                  WHERE noaccents(name) LIKE ? LIMIT 25",
-                                 ("%" + noaccents(searched) + "%",))
+                                  FROM tracks, track_genres AS TG\
+                                  WHERE noaccents(name) LIKE ?\
+                                  AND tracks.rowid=TG.track_id\
+                                  AND ? NOT IN (\
+                                    SELECT track_genres.genre_id\
+                                    FROM track_genres\
+                                    WHERE TG.track_id=track_genres.track_id)\
+                                  LIMIT 25",
+                                 ("%" + noaccents(searched) + "%",
+                                  Type.CHARTS))
             return list(result)
 
     def search_track(self, artist, title):
diff --git a/lollypop/database_upgrade.py b/lollypop/database_upgrade.py
index cc40cfdf..604d3afd 100644
--- a/lollypop/database_upgrade.py
+++ b/lollypop/database_upgrade.py
@@ -57,8 +57,6 @@ class DatabaseUpgrade:
             19: self.__upgrade_19,
             20: self.__upgrade_20,
             21: self.__upgrade_21,
-            22: self.__upgrade_22,
-            23: self.__upgrade_23,
                          }
 
     """
@@ -407,6 +405,8 @@ class DatabaseUpgrade:
                                    persistent FROM backup")
             sql.execute("DROP TABLE backup")
             sql.commit()
+        # Clean all charts
+        Lp().db.del_tracks(Lp().tracks.get_old_charts_track_ids(mtime*2))
 
     def __upgrade_21(self):
         """
@@ -416,108 +416,3 @@ class DatabaseUpgrade:
             sql.execute("ALTER TABLE radios ADD rate\
                          INT NOT NULL DEFAULT -1")
             sql.commit()
-
-    def __upgrade_22(self):
-        """
-            Remove Charts/Web entries
-        """
-        with SqlCursor(Lp().db) as sql:
-            result = sql.execute("SELECT rowid FROM tracks\
-                                  WHERE persistent=0 OR\
-                                  persistent=2 OR\
-                                  persistent=3")
-            track_ids = list(itertools.chain(*result))
-            Lp().db.del_tracks(track_ids)
-            # Remove persistent from tracks table
-            sql.execute("CREATE TEMPORARY TABLE backup(\
-                                          id INTEGER PRIMARY KEY,\
-                                          name TEXT NOT NULL,\
-                                          uri TEXT NOT NULL,\
-                                          duration INT,\
-                                          tracknumber INT,\
-                                          discnumber INT,\
-                                          discname TEXT,\
-                                          album_id INT NOT NULL,\
-                                          year INT,\
-                                          popularity INT NOT NULL,\
-                                          rate INT NOT NULL,\
-                                          ltime INT NOT NULL)")
-            sql.execute("INSERT INTO backup\
-                            SELECT id,\
-                                   name,\
-                                   uri,\
-                                   duration,\
-                                   tracknumber,\
-                                   discnumber,\
-                                   discname,\
-                                   album_id,\
-                                   year,\
-                                   popularity,\
-                                   rate,\
-                                   ltime FROM tracks")
-            sql.execute("DROP TABLE tracks")
-            sql.execute("CREATE TABLE tracks(\
-                                          id INTEGER PRIMARY KEY,\
-                                          name TEXT NOT NULL,\
-                                          uri TEXT NOT NULL,\
-                                          duration INT,\
-                                          tracknumber INT,\
-                                          discnumber INT,\
-                                          discname TEXT,\
-                                          album_id INT NOT NULL,\
-                                          year INT,\
-                                          popularity INT NOT NULL,\
-                                          rate INT NOT NULL,\
-                                          ltime INT NOT NULL)")
-            sql.execute("INSERT INTO tracks\
-                            SELECT id,\
-                                   name,\
-                                   uri,\
-                                   duration,\
-                                   tracknumber,\
-                                   discnumber,\
-                                   discname,\
-                                   album_id,\
-                                   year,\
-                                   popularity,\
-                                   rate,\
-                                   ltime FROM backup")
-            sql.execute("DROP TABLE backup")
-            sql.commit()
-
-    def __upgrade_23(self):
-        """
-            Restore back mtime in tracks
-        """
-        with SqlCursor(Lp().db) as sql:
-            sql.execute("ALTER TABLE tracks ADD mtime INT")
-            sql.execute("ALTER TABLE albums ADD mtime INT")
-
-            sql.execute("UPDATE tracks SET mtime = (\
-                            SELECT mtime FROM track_genres\
-                            WHERE track_genres.track_id=tracks.rowid)")
-
-            sql.execute("UPDATE albums SET mtime = (\
-                            SELECT mtime FROM album_genres\
-                            WHERE album_genres.album_id=albums.rowid)")
-            sql.commit()
-            # Remove mtime from album_genres table
-            sql.execute("CREATE TABLE album_genres2 (\
-                                                album_id INT NOT NULL,\
-                                                genre_id INT NOT NULL)")
-            sql.execute("INSERT INTO album_genres2\
-                            SELECT album_id,\
-                                   genre_id FROM album_genres")
-            sql.execute("DROP TABLE album_genres")
-            sql.execute("ALTER TABLE album_genres2 RENAME TO album_genres")
-
-            # Remove mtime from track_genres table
-            sql.execute("CREATE TABLE track_genres2 (\
-                                                track_id INT NOT NULL,\
-                                                genre_id INT NOT NULL)")
-            sql.execute("INSERT INTO track_genres2\
-                            SELECT track_id,\
-                                   genre_id FROM track_genres")
-            sql.execute("DROP TABLE track_genres")
-            sql.execute("ALTER TABLE track_genres2 RENAME TO track_genres")
-            sql.commit()
diff --git a/lollypop/define.py b/lollypop/define.py
index 972c2332..e1187a59 100644
--- a/lollypop/define.py
+++ b/lollypop/define.py
@@ -17,6 +17,20 @@ from gi.repository import Gio
 
 from os import path
 
+try:
+    from gi.repository import Secret
+
+    SecretSchema = {
+        "org.gnome.Lollypop.lastfm.login": Secret.SchemaAttributeType.STRING
+    }
+    SecretAttributes = {
+        "org.gnome.Lollypop.lastfm.login": "Last.fm login"
+    }
+except:
+    Secret = None
+    SecretSchema = None
+    SecretAttributes = None
+
 DataPath = path.expanduser("~") + "/.local/share/lollypop"
 
 Lp = Gio.Application.get_default
@@ -33,6 +47,13 @@ class NextContext:
     STOP = 2             # Stop after track/album/artist
 
 
+class DbPersistent:
+    NONE = 0
+    INTERNAL = 1
+    EXTERNAL = 2
+    CHARTS = 3
+
+
 class OpenLink:
     NONE = 0
     OPEN = 1
@@ -78,13 +99,6 @@ class Shuffle:
     ALBUMS = 2           # Shuffle by albums on genre
 
 
-class PowerManagement:
-    NONE = 0             # Use OS defaults
-    IDLE = 1             # Inhibit screensaver
-    SUSPEND = 2          # Inhibit suspend
-    BOTH = 3             # Inhibit screensaver and suspend
-
-
 class WindowSize:
     SMALL = 400
     MEDIUM = 500
@@ -109,9 +123,13 @@ class Type:
     RADIOS = -6
     EXTERNALS = -7
     SEARCH = -8
-    NOPARTY = -9
-    ALBUMS = -10
-    ALL = -11
+    CHARTS = -9
+    SPOTIFY = -10
+    ITUNES = -11
+    LASTFM = -12
+    NOPARTY = -13
+    ALBUMS = -14
+    ALL = -15
     LOVED = -997
     NEVER = -998
     DEVICES = -1000
diff --git a/lollypop/downloader.py b/lollypop/downloader.py
index 92ffff9f..7f82d1f3 100644
--- a/lollypop/downloader.py
+++ b/lollypop/downloader.py
@@ -10,16 +10,15 @@
 # You should have received a copy of the GNU General Public License
 # along with this program. If not, see <http://www.gnu.org/licenses/>.
 
-from gi.repository import GLib, Soup
+from gi.repository import GLib
 
+from threading import Thread
 import json
-from base64 import b64encode
 
 from lollypop.cache import InfoCache
 from lollypop.define import Lp, GOOGLE_API_ID, Type
-from lollypop.define import SPOTIFY_CLIENT_ID, SPOTIFY_SECRET
 from lollypop.utils import debug, get_network_available
-from lollypop.helper_task import TaskHelper
+from lollypop.lio import Lio
 
 
 class Downloader:
@@ -50,8 +49,9 @@ class Downloader:
         if get_network_available():
             self.__albums_queue.append(album_id)
             if not self.__in_albums_download:
-                helper = TaskHelper()
-                helper.run(self.__cache_albums_art)
+                t = Thread(target=self.__cache_albums_art)
+                t.daemon = True
+                t.start()
 
     def cache_artists_info(self):
         """
@@ -60,39 +60,44 @@ class Downloader:
         if self.__cache_artists_running:
             return
         self.__cache_artists_running = True
-        helper = TaskHelper()
-        helper.run(self.__cache_artists_info)
+        t = Thread(target=self.__cache_artists_info)
+        t.daemon = True
+        t.start()
 
-    def get_google_search_uri(self, search):
+    def get_google_arts(self, search):
         """
-            Get google uri for search
-            @param search as str
-        """
-        key = Lp().settings.get_value("cs-api-key").get_string() or\
-            Lp().settings.get_default_value("cs-api-key").get_string()
-        uri = "https://www.googleapis.com/" +\
-              "customsearch/v1?key=%s&cx=%s" % (key, GOOGLE_API_ID) +\
-              "&q=%s&searchType=image" % GLib.uri_escape_string(search,
-                                                                "",
-                                                                False)
-        return uri
-
-    def get_google_artwork(self, content):
-        """
-            Get artwork from Google search content
-            @param content as bytes
+            Get arts on duck image corresponding to search
+            @param search words as string
             @return [urls as string]
         """
-        uris = []
+        data = None
+        urls = []
+
+        if not get_network_available():
+            return []
+
+        cs_api_key = Lp().settings.get_value("cs-api-key").get_string()
+
         try:
-            decode = json.loads(content.decode("utf-8"))
-            if decode is None:
-                return uris
-            for item in decode["items"]:
-                uris.append(item["link"])
+            f = Lio.File.new_for_uri("https://www.googleapis.com/"
+                                     "customsearch/v1?key=%s&cx=%s"
+                                     "&q=%s&searchType=image" %
+                                     (cs_api_key,
+                                      GOOGLE_API_ID,
+                                      GLib.uri_escape_string(search,
+                                                             "",
+                                                             False)))
+
+            (status, data, tag) = f.load_contents()
+            if status:
+                decode = json.loads(data.decode("utf-8"))
+                if decode is None:
+                    return urls
+                for item in decode["items"]:
+                    urls.append(item["link"])
         except Exception as e:
-            print("Downloader::get_google_artwork():", e)
-        return uris or None
+            print(e)
+        return urls
 
 #######################
 # PROTECTED           #
@@ -129,10 +134,10 @@ class Downloader:
         try:
             artist_formated = GLib.uri_escape_string(
                                 artist, None, True).replace(" ", "+")
-            uri = "https://api.deezer.com/search/artist/?" +\
-                  "q=%s&output=json&index=0&limit=1&" % artist_formated
-            helper = TaskHelper()
-            (status, data) = helper.load_uri_content_sync(uri, None)
+            s = Lio.File.new_for_uri("https://api.deezer.com/search/artist/?"
+                                     "q=%s&output=json&index=0&limit=1&" %
+                                     artist_formated)
+            (status, data, tag) = s.load_contents()
             if status:
                 decode = json.loads(data.decode("utf-8"))
                 return (decode["data"][0]["picture_xl"], None)
@@ -148,14 +153,13 @@ class Downloader:
             @return (url as str/None, content as None)
         """
         try:
+            from lollypop.search_spotify import SpotifySearch
             artist_formated = GLib.uri_escape_string(
                                 artist, None, True).replace(" ", "+")
-            uri = "https://api.spotify.com/v1/search?q=%s" % artist_formated +\
-                  "&type=artist"
-            token = "Bearer %s" % self.__get_spotify_token(None)
-            helper = TaskHelper()
-            helper.add_header("Authorization", token)
-            (status, data) = helper.load_uri_content_sync(uri, None)
+            s = Lio.File.new_for_uri("https://api.spotify.com/v1/search?q=%s"
+                                     "&type=artist" % artist_formated)
+            s.add_spotify_headers(SpotifySearch.get_token(None))
+            (status, data, tag) = s.load_contents()
             if status:
                 decode = json.loads(data.decode("utf-8"))
                 for item in decode["artists"]["items"]:
@@ -177,19 +181,20 @@ class Downloader:
         image = None
         try:
             album_formated = GLib.uri_escape_string(album, None, True)
-            uri = "https://api.deezer.com/search/album/?" +\
-                  "q=%s&output=json" % album_formated
-            helper = TaskHelper()
-            (status, data) = helper.load_uri_content_sync(uri, None)
+            s = Lio.File.new_for_uri("https://api.deezer.com/search/album/?"
+                                     "q=%s&output=json" %
+                                     album_formated)
+            (status, data, tag) = s.load_contents()
             if status:
                 decode = json.loads(data.decode("utf-8"))
-                uri = None
+                url = None
                 for item in decode["data"]:
                     if item["artist"]["name"].lower() == artist.lower():
-                        uri = item["cover_xl"]
+                        url = item["cover_xl"]
                         break
-                if uri is not None:
-                    (status, image) = helper.load_uri_content_sync(uri, None)
+                if url is not None:
+                    s = Lio.File.new_for_uri(url)
+                    (status, image, tag) = s.load_contents()
         except Exception as e:
             print("Downloader::__get_deezer_album_artwork: %s" % e)
         return image
@@ -205,34 +210,35 @@ class Downloader:
         image = None
         artists_spotify_ids = []
         try:
-            token = self.__get_spotify_token(None)
+            from lollypop.search_spotify import SpotifySearch
+            token = SpotifySearch.get_token(None)
             artist_formated = GLib.uri_escape_string(
                                 artist, None, True).replace(" ", "+")
-            uri = "https://api.spotify.com/v1/search?q=%s" % artist_formated +\
-                  "&type=artist"
-            token = "Bearer %s" % token
-            helper = TaskHelper()
-            helper.add_header("Authorization", token)
-            (status, data) = helper.load_uri_content_sync(uri, None)
+            s = Lio.File.new_for_uri("https://api.spotify.com/v1/search?q=%s"
+                                     "&type=artist" % artist_formated)
+            s.add_spotify_headers(token)
+            (status, data, tag) = s.load_contents()
             if status:
                 decode = json.loads(data.decode("utf-8"))
                 for item in decode["artists"]["items"]:
                     artists_spotify_ids.append(item["id"])
 
             for artist_spotify_id in artists_spotify_ids:
-                uri = "https://api.spotify.com/v1/artists/" +\
-                      "%s/albums" % artist_spotify_id
-                (status, data) = helper.load_uri_content_sync(uri, None)
+                s = Lio.File.new_for_uri("https://api.spotify.com/v1/artists/"
+                                         "%s/albums" % artist_spotify_id)
+                s.add_spotify_headers(token)
+                (status, data, tag) = s.load_contents()
                 if status:
                     decode = json.loads(data.decode("utf-8"))
-                    uri = None
+                    url = None
                     for item in decode["items"]:
                         if item["name"] == album:
-                            uri = item["images"][0]["url"]
+                            url = item["images"][0]["url"]
                             break
-                    if uri is not None:
-                        (status, image) = helper.load_uri_content_sync(uri,
-                                                                       None)
+
+                    if url is not None:
+                        s = Lio.File.new_for_uri(url)
+                        (status, image, tag) = s.load_contents()
                     break
         except Exception as e:
             print("Downloader::_get_album_art_spotify: %s [%s/%s]" %
@@ -251,18 +257,17 @@ class Downloader:
         try:
             album_formated = GLib.uri_escape_string(
                                 album, None, True).replace(" ", "+")
-            uri = "https://itunes.apple.com/search" +\
-                  "?entity=album&term=%s" % album_formated
-            helper = TaskHelper()
-            (status, data) = helper.load_uri_content_sync(uri, None)
+            s = Lio.File.new_for_uri("https://itunes.apple.com/search"
+                                     "?entity=album&term=%s" % album_formated)
+            (status, data, tag) = s.load_contents()
             if status:
                 decode = json.loads(data.decode("utf-8"))
                 for item in decode["results"]:
                     if item["artistName"].lower() == artist.lower():
-                        uri = item["artworkUrl60"].replace("60x60",
+                        url = item["artworkUrl60"].replace("60x60",
                                                            "512x512")
-                        (status, image) = helper.load_uri_content_sync(uri,
-                                                                       None)
+                        s = Lio.File.new_for_uri(url)
+                        (status, image, tag) = s.load_contents()
                         break
         except Exception as e:
             print("Downloader::_get_album_art_itunes: %s [%s/%s]" %
@@ -280,11 +285,11 @@ class Downloader:
         image = None
         if Lp().lastfm is not None:
             try:
-                helper = TaskHelper()
                 last_album = Lp().lastfm.get_album(artist, album)
-                uri = last_album.get_cover_image(4)
-                if uri is not None:
-                    (status, image) = helper.load_uri_content_sync(uri, None)
+                url = last_album.get_cover_image(4)
+                if url is not None:
+                    s = Lio.File.new_for_uri(url)
+                    (status, image, tag) = s.load_contents()
             except Exception as e:
                 print("Downloader::_get_album_art_lastfm: %s [%s/%s]" %
                       (e, artist, album))
@@ -293,31 +298,6 @@ class Downloader:
 #######################
 # PRIVATE             #
 #######################
-    def __get_spotify_token(self, cancellable):
-        """
-            Get a new auth token
-            @param cancellable as Gio.Cancellable
-            @return str
-        """
-        try:
-            token_uri = "https://accounts.spotify.com/api/token"
-            credentials = "%s:%s" % (SPOTIFY_CLIENT_ID, SPOTIFY_SECRET)
-            encoded = b64encode(credentials.encode("utf-8"))
-            credentials = encoded.decode("utf-8")
-            session = Soup.Session.new()
-            data = {"grant_type": "client_credentials"}
-            msg = Soup.form_request_new_from_hash("POST", token_uri, data)
-            msg.request_headers.append("Authorization",
-                                       "Basic %s" % credentials)
-            status = session.send_message(msg)
-            if status == 200:
-                body = msg.get_property("response-body")
-                data = body.flatten().get_data()
-                decode = json.loads(data.decode("utf-8"))
-                return decode["access_token"]
-        except:
-            return ""
-
     def __cache_artists_info(self):
         """
             Cache info for all artists
@@ -337,16 +317,15 @@ class Downloader:
                     continue
                 try:
                     method = getattr(self, helper)
-                    (uri, content) = method(artist)
-                    if uri is not None:
-                        (status, data) = TaskHelper().load_uri_content_sync(
-                                                                      uri,
-                                                                      None)
+                    (url, content) = method(artist)
+                    if url is not None:
+                        s = Lio.File.new_for_uri(url)
+                        (status, data, tag) = s.load_contents()
                         if status:
                             artwork_set = True
                             InfoCache.add(artist, content, data, api)
                             debug("Downloader::__cache_artists_info(): %s"
-                                  % uri)
+                                  % url)
                         else:
                             InfoCache.add(artist, None, None, api)
                 except Exception as e:
@@ -379,9 +358,11 @@ class Downloader:
                     method = getattr(self, helper)
                     data = method(artist, album)
                     if data is not None:
-                        self.__albums_history.append(album_id)
-                        Lp().art.save_album_artwork(data, album_id)
                         break
+                if data is None:
+                    self.__albums_history.append(album_id)
+                    continue
+                Lp().art.save_album_artwork(data, album_id)
         except Exception as e:
             print("Downloader::__cache_albums_art: %s" % e)
         self.__albums_history.append(album_id)
diff --git a/lollypop/fullscreen.py b/lollypop/fullscreen.py
index f4d286ea..3fef77d6 100644
--- a/lollypop/fullscreen.py
+++ b/lollypop/fullscreen.py
@@ -10,7 +10,7 @@
 # You should have received a copy of the GNU General Public License
 # along with this program. If not, see <http://www.gnu.org/licenses/>.
 
-from gi.repository import Gtk, Gdk, GLib, Gio, Gst
+from gi.repository import Gtk, Gdk, GLib, Gio
 
 from datetime import datetime
 
@@ -58,7 +58,7 @@ class FullScreen(Gtk.Window, InfoController,
         else:
             artsize = int(ArtSize.FULLSCREEN*geometry.height/1920)
         InfoController.__init__(self, artsize)
-        widget = builder.get_object("widget")
+
         self._play_btn = builder.get_object("play_btn")
         self._next_btn = builder.get_object("next_btn")
         self._prev_btn = builder.get_object("prev_btn")
@@ -67,14 +67,7 @@ class FullScreen(Gtk.Window, InfoController,
         self._play_image = builder.get_object("play_image")
         self._pause_image = builder.get_object("pause_image")
         close_btn = builder.get_object("close_btn")
-        preferences = Gio.Settings.new("org.gnome.desktop.wm.preferences")
-        layout = preferences.get_value("button-layout").get_string()
-        if layout.split(":")[0] == "close":
-            widget.attach(close_btn, 0, 0, 1, 1)
-            close_btn.set_property("halign", Gtk.Align.START)
-        else:
-            widget.attach(close_btn, 2, 0, 1, 1)
-            close_btn.set_property("halign", Gtk.Align.END)
+        close_btn.connect("clicked", self.__destroy)
         self._cover = builder.get_object("cover")
         self._title_label = builder.get_object("title")
         self._artist_label = builder.get_object("artist")
@@ -86,7 +79,7 @@ class FullScreen(Gtk.Window, InfoController,
         self._timelabel = builder.get_object("playback")
         self._total_time_label = builder.get_object("duration")
         self.connect("key-release-event", self.__on_key_release_event)
-        self.add(widget)
+        self.add(builder.get_object("widget"))
 
     def do_show(self):
         """
@@ -116,14 +109,15 @@ class FullScreen(Gtk.Window, InfoController,
             self.__timeout2 = GLib.timeout_add(1000,
                                                self.__update_datetime,
                                                show_seconds)
-        self._update_position(Lp().player.position/Gst.SECOND)
+        self._update_position(Lp().player.position/1000000)
         self.fullscreen()
         self._next_popover.set_relative_to(self._album_label)
         if Lp().player.next_track.id != Type.RADIOS:
             self._next_popover.show()
-
-        # Disable screensaver (idle)
-        Lp().inhibitor.manual_inhibit(suspend=False, idle=True)
+        # Disable idle
+        self.__cookie = Lp().inhibit(Lp().window,
+                                     Gtk.ApplicationInhibitFlags.IDLE,
+                                     None)
 
     def do_hide(self):
         """
@@ -145,7 +139,7 @@ class FullScreen(Gtk.Window, InfoController,
             GLib.source_remove(self.__timeout2)
         self._next_popover.set_relative_to(None)
         self._next_popover.hide()
-        Lp().inhibitor.manual_uninhibit()
+        Lp().uninhibit(self.__cookie)
 
     def show_hide_volume_control(self):
         """
@@ -174,16 +168,6 @@ class FullScreen(Gtk.Window, InfoController,
         else:
             self._next_popover.hide()
 
-#######################
-# PROTECTED           #
-#######################
-    def _on_close_button_clicked(self, widget):
-        """
-            Destroy self
-            @param widget as Gtk.Button
-        """
-        self.destroy()
-
 #######################
 # PRIVATE             #
 #######################
@@ -202,6 +186,13 @@ class FullScreen(Gtk.Window, InfoController,
             return False
         return True
 
+    def __destroy(self, widget):
+        """
+            Destroy self
+            @param widget as Gtk.Button
+        """
+        self.destroy()
+
     def __on_key_release_event(self, widget, event):
         """
             Destroy window if Esc
diff --git a/lollypop/helper_passwords.py b/lollypop/helper_passwords.py
deleted file mode 100644
index a18cbce0..00000000
--- a/lollypop/helper_passwords.py
+++ /dev/null
@@ -1,213 +0,0 @@
-# Copyright (c) 2017 Cedric Bellegarde <cedric.bellegarde@adishatz.org>
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-# GNU General Public License for more details.
-# You should have received a copy of the GNU General Public License
-# along with this program. If not, see <http://www.gnu.org/licenses/>.
-
-import gi
-gi.require_version('Secret', '1')
-from gi.repository import Secret, GLib
-
-from lollypop.utils import debug
-
-
-class PasswordsHelper:
-    """
-        Simpler helper for Secret
-    """
-
-    def __init__(self):
-        """
-            Init helper
-        """
-        self.__secret = None
-        Secret.Service.get(Secret.ServiceFlags.NONE, None,
-                           self.__on_get_secret)
-
-    def get(self, service, callback, *args):
-        """
-            Call function
-            @param service as str
-            @param callback as function
-            @param args
-        """
-        try:
-            self.__wait_for_secret(self.get, service, callback, *args)
-            SecretSchema = {
-                "service": Secret.SchemaAttributeType.STRING
-            }
-            SecretAttributes = {
-                "service": service
-            }
-            schema = Secret.Schema.new("org.gnome.Lollypop",
-                                       Secret.SchemaFlags.NONE,
-                                       SecretSchema)
-            self.__secret.search(schema, SecretAttributes,
-                                 Secret.SearchFlags.ALL,
-                                 None,
-                                 self.__on_secret_search,
-                                 service,
-                                 callback,
-                                 *args)
-        except Exception as e:
-            debug("PasswordsHelper::get(): %s" % e)
-
-    def store(self, service, login, password, callback, *args):
-        """
-            Store password
-            @param service as str
-            @param login as str
-            @param password as str
-            @param callback as function
-        """
-        try:
-            self.__wait_for_secret(self.store,
-                                   service,
-                                   login,
-                                   password,
-                                   callback,
-                                   *args)
-            schema_string = "org.gnome.Lollypop: %s@%s" % (service, login)
-            SecretSchema = {
-                "service": Secret.SchemaAttributeType.STRING,
-                "login": Secret.SchemaAttributeType.STRING,
-            }
-            SecretAttributes = {
-                "service": service,
-                "login": login
-            }
-            schema = Secret.Schema.new("org.gnome.Lollypop",
-                                       Secret.SchemaFlags.NONE,
-                                       SecretSchema)
-            Secret.password_store(schema, SecretAttributes,
-                                  Secret.COLLECTION_DEFAULT,
-                                  schema_string,
-                                  password,
-                                  None,
-                                  callback,
-                                  *args)
-        except Exception as e:
-            debug("PasswordsHelper::store(): %s" % e)
-
-    def clear(self, service, callback=None, *args):
-        """
-            Clear password
-            @param service as str
-            @param callback as function
-        """
-        try:
-            self.__wait_for_secret(self.clear, service, callback, *args)
-            SecretSchema = {
-                "service": Secret.SchemaAttributeType.STRING
-            }
-            SecretAttributes = {
-                "service": service
-            }
-            schema = Secret.Schema.new("org.gnome.Lollypop",
-                                       Secret.SchemaFlags.NONE,
-                                       SecretSchema)
-            self.__secret.search(schema,
-                                 SecretAttributes,
-                                 Secret.SearchFlags.ALL,
-                                 None,
-                                 self.__on_clear_search,
-                                 callback,
-                                 *args)
-        except Exception as e:
-            debug("PasswordsHelper::clear(): %s" % e)
-
-#######################
-# PRIVATE             #
-#######################
-    def __wait_for_secret(self, call, *args):
-        """
-            Wait for secret
-            @param call as function to call
-            @param args
-            @raise exception if waiting
-        """
-        # Wait for secret
-        if self.__secret is None:
-            GLib.timeout_add(250, call, *args)
-        if self.__secret in [None, -1]:
-            raise Exception("Waiting Secret service")
-
-    def __on_clear_search(self, source, result, callback=None, *args):
-        """
-            Clear passwords
-            @param source as GObject.Object
-            @param result as Gio.AsyncResult
-        """
-        try:
-            if result is not None:
-                items = source.search_finish(result)
-                for item in items:
-                    item.delete(None, None)
-            if callback is not None:
-                callback(*args)
-        except Exception as e:
-            debug("PasswordsHelper::__on_clear_search(): %s" % e)
-
-    def __on_load_secret(self, source, result, service, callback, *args):
-        """
-            Set userservice/password input
-            @param source as GObject.Object
-            @param result as Gio.AsyncResult
-            @param service as str
-            @param index as int
-            @param count as int
-            @param callback as function
-            @param args
-        """
-        secret = source.get_secret()
-        if secret is not None:
-            callback(source.get_attributes(),
-                     secret.get().decode('utf-8'),
-                     service,
-                     *args)
-        else:
-            callback(None, None, service, *args)
-
-    def __on_secret_search(self, source, result, service, callback, *args):
-        """
-            Set userservice/password input
-            @param source as GObject.Object
-            @param result as Gio.AsyncResult
-            @param service as str/None
-            @param callback as function
-            @param args
-        """
-        try:
-            if result is not None:
-                items = self.__secret.search_finish(result)
-                for item in items:
-                    item.load_secret(None,
-                                     self.__on_load_secret,
-                                     service,
-                                     callback,
-                                     *args)
-                if not items:
-                    callback(None, None, service, *args)
-            else:
-                callback(None, None, service, *args)
-        except Exception as e:
-            debug("PasswordsHelper::__on_secret_search(): %s" % e)
-            callback(None, None, service, *args)
-
-    def __on_get_secret(self, source, result):
-        """
-            Store secret proxy
-            @param source as GObject.Object
-            @param result as Gio.AsyncResult
-        """
-        try:
-            self.__secret = Secret.Service.get_finish(result)
-        except Exception as e:
-            self.__secret = -1
-            debug("PasswordsHelper::__on_get_secret(): %s" % e)
diff --git a/lollypop/helper_task.py b/lollypop/helper_task.py
deleted file mode 100644
index 69a2dd69..00000000
--- a/lollypop/helper_task.py
+++ /dev/null
@@ -1,173 +0,0 @@
-# Copyright (c) 2017 Cedric Bellegarde <cedric.bellegarde@adishatz.org>
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-# GNU General Public License for more details.
-# You should have received a copy of the GNU General Public License
-# along with this program. If not, see <http://www.gnu.org/licenses/>.
-
-import gi
-gi.require_version("Soup", "2.4")
-from gi.repository import GLib, Soup
-
-from threading import Thread
-
-
-class TaskHelper:
-    """
-        Simple helper for running a task in background
-    """
-
-    def __init__(self):
-        """
-            Init helper
-        """
-        self.__signals = {}
-        self.__headers = []
-
-    def add_header(self, name, value):
-        """
-            Add header
-            @param name as str
-            @param value as str
-        """
-        self.__headers.append((name, value))
-
-    def run(self, command, *args, **kwd):
-        """
-            run command with params and return to callback
-            @param command as function
-            @param *args as command arguments
-            @param **kwd as { "callback": (function, *args) }
-        """
-        thread = Thread(target=self.__run,
-                        args=(command, kwd, *args))
-        thread.daemon = True
-        thread.start()
-
-    def load_uri_content(self, uri, cancellable, callback, *args):
-        """
-            Load uri with libsoup (better performance than Gio)
-            @param uri as str
-            @param cancellable as Gio.Cancellable
-            @param callback as a function
-            @callback (uri as str, status as bool, content as bytes, args)
-        """
-        try:
-            session = Soup.Session.new()
-            session.set_property('accept-language-auto', True)
-            request = session.request(uri)
-            request.send_async(cancellable,
-                               self.__on_request_send_async,
-                               callback,
-                               cancellable,
-                               uri,
-                               *args)
-        except Exception as e:
-            print("HelperTask::load_uri_content():",  e)
-            callback(None, False, b"", *args)
-
-    def load_uri_content_sync(self, uri, cancellable=None):
-            """
-                Load uri
-                @param uri as str
-                @param cancellable as Gio.Cancellable
-                @return (loaded as bool, content as bytes)
-            """
-            try:
-                session = Soup.Session.new()
-                # Post message
-                if self.__headers:
-                    msg = Soup.Message.new("GET", uri)
-                    headers = msg.get_property("request-headers")
-                    for header in self.__headers:
-                        headers.append(header[0],
-                                       header[1])
-                    session.send_message(msg)
-                    body = msg.get_property("response-body")
-                    bytes = body.flatten().get_data()
-                # Get message
-                else:
-                    request = session.request(uri)
-                    stream = request.send(cancellable)
-                    bytes = bytearray(0)
-                    buf = stream.read_bytes(1024, cancellable).get_data()
-                    while buf:
-                        bytes += buf
-                        buf = stream.read_bytes(1024, cancellable).get_data()
-                    stream.close()
-                return (True, bytes)
-            except Exception as e:
-                print("TaskHelper::load_uri_content_sync():",  e)
-                return (False, b"")
-
-#######################
-# PRIVATE             #
-#######################
-    def __run(self, command, kwd, *args):
-        """
-            Pass command result to callback
-            @param command as function
-            @param *args as command arguments
-            @param kwd as { "callback": (function, *args) }
-        """
-        try:
-            result = command(*args)
-            if "callback" in kwd.keys():
-                (callback, *callback_args) = kwd["callback"]
-                if callback is not None:
-                    GLib.idle_add(callback, result, *callback_args)
-        except Exception as e:
-            print("TaskHelper::__run():", e)
-
-    def __on_read_bytes_async(self, stream, result, content,
-                              cancellable, callback, uri, *args):
-        """
-            Read data from stream, when finished, pass to callback
-            @param stream as Gio.InputStream
-            @param result as Gio.AsyncResult
-            @param cancellable as Gio.Cancellable
-            @param content as bytes
-            @param callback as function
-            @param uri as str
-        """
-        try:
-            content_result = stream.read_bytes_finish(result)
-            content_bytes = content_result.get_data()
-            if content_bytes:
-                content += content_bytes
-                stream.read_bytes_async(4096, GLib.PRIORITY_LOW,
-                                        cancellable,
-                                        self.__on_read_bytes_async,
-                                        content, cancellable, callback,
-                                        uri, *args)
-            else:
-                callback(uri, True, bytes(content), *args)
-        except Exception as e:
-            print("TaskHelper::__on_read_bytes_async():", e)
-            callback(None, False, b"", *args)
-
-    def __on_request_send_async(self, source, result, callback,
-                                cancellable, uri, *args):
-        """
-            Get stream and start reading from it
-            @param source as Soup.Session
-            @param result as Gio.AsyncResult
-            @param cancellable as Gio.Cancellable
-            @param callback as a function
-            @param uri as str
-        """
-        try:
-            stream = source.send_finish(result)
-            # We use a bytearray here as seems that bytes += is really slow
-            stream.read_bytes_async(4096, GLib.PRIORITY_LOW,
-                                    cancellable, self.__on_read_bytes_async,
-                                    bytearray(0), cancellable, callback, uri,
-                                    *args)
-        except Exception as e:
-            print("TaskHelper::__on_soup_msg_finished():",  e)
-            callback(None, False, b"", *args)
diff --git a/lollypop/inhibitor.py b/lollypop/inhibitor.py
deleted file mode 100644
index 7aae2ff6..00000000
--- a/lollypop/inhibitor.py
+++ /dev/null
@@ -1,153 +0,0 @@
-# Copyright (C) 2017 Jason Gray <jasonlevigray3@gmail.com>
-# Copyright (C) 2017 Franz Dietrich <dietrich@teilgedanken.de>
-# This program is free software: you can redistribute it and/or modify it
-# under the terms of the GNU General Public License version 3, as published
-# by the Free Software Foundation.
-#
-# This program is distributed in the hope that it will be useful, but
-# WITHOUT ANY WARRANTY; without even the implied warranties of
-# MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR
-# PURPOSE.  See the GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License along
-# with this program.  If not, see <http://www.gnu.org/licenses/>.
-# END LICENSE
-
-from gi.repository import Gtk, Gst
-
-from lollypop.define import Lp, PowerManagement
-
-
-class Inhibitor:
-    def __init__(self):
-        self.__cookie_suspend = 0
-        self.__cookie_idle = 0
-        self.__status_handler_id = None      # The playback listener
-        self.__current_player_state = None
-        self.__manual_inhibit = False
-
-        # Load and apply the inhibit settings
-        self.__on_powermanagement_setting_changed(Lp().settings)
-        # Register to settings changes
-        Lp().settings.connect(
-            "changed::power-management",
-            self.__on_powermanagement_setting_changed,
-        )
-
-    def __on_powermanagement_setting_changed(self, settings, name=None):
-        """
-            Register to playback status changes so that standby/idle is only
-            inhibited while playing
-        """
-        if settings.get_enum("power-management") > 0:
-            self.__enable_react_to_playback()
-        else:
-            self.__disable_react_to_playback()
-            self.__uninhibit()
-        # Update the flags according to the settings.
-        self.__update_flags_settings()
-
-    def __disable_react_to_playback(self):
-        if self.__status_handler_id is not None:
-            Lp().player.disconnect(self.__status_handler_id)
-
-    def __enable_react_to_playback(self):
-        self.__on_status_changed(Lp().player)
-        if self.__status_handler_id is None:
-            self.__status_handler_id = Lp().player.connect(
-                "status-changed",
-                self.__on_status_changed,
-            )
-
-    def __on_status_changed(self, player):
-        """
-            React to a change of playback state
-        """
-        new_state = player.get_status()
-        if self.__current_player_state != new_state:
-            self.__current_player_state = new_state
-            if self.__current_player_state == Gst.State.PLAYING:
-                self.__update_flags_settings()
-            else:
-                self.__uninhibit()
-
-    def __update_flags_settings(self):
-        """
-            Update the inhibit flags according to the settings in dconf
-        """
-        power_management = Lp().settings.get_enum("power-management")
-
-        if power_management in [PowerManagement.SUSPEND, PowerManagement.BOTH]:
-            self.__inhibit_suspend()
-        if power_management in [PowerManagement.IDLE, PowerManagement.BOTH]:
-            self.__inhibit_idle()
-
-    def __inhibit_suspend(self):
-        """
-            Disable the suspend behaviour of the OS
-        """
-        if self.__manual_inhibit:
-            # temporary blocked inhibit changes
-            return
-        if not self.__cookie_suspend:
-            self.__cookie_suspend = Lp().inhibit(
-                Lp().window,
-                Gtk.ApplicationInhibitFlags.SUSPEND,
-                "Playing music")
-
-    def __inhibit_idle(self):
-        """
-            Disable the screensaver (idle)
-        """
-        if self.__manual_inhibit:
-            # temporary blocked inhibit changes
-            return
-        if not self.__cookie_idle:
-            self.__cookie_idle = Lp().inhibit(
-                Lp().window,
-                Gtk.ApplicationInhibitFlags.IDLE,
-                "Playing music")
-
-    def __uninhibit(self):
-        """
-            Remove all the powermanagement settings
-        """
-        if self.__manual_inhibit:
-            # temporary blocked inhibit changes
-            return
-        if self.__cookie_suspend and self.__cookie_suspend != 0:
-            Lp().uninhibit(self.__cookie_suspend)
-            self.__cookie_suspend = 0
-        if self.__cookie_idle and self.__cookie_idle != 0:
-            Lp().uninhibit(self.__cookie_idle)
-            self.__cookie_idle = 0
-
-        self.__current_player_state = None
-
-    def manual_inhibit(self, suspend, idle):
-        """
-            Inhibit suspend or idle manually.
-            The settings values from dconf are not applied while a
-            manual_inhibt() call is active. Disable the manual override with
-            manual_uninhibit().
-            By giving manual_inhibit(False, False) screensaver and suspend are
-            activated (with their timeouts) despite other settings in dconf.
-
-            @param suspend as bool
-            @param idle as bool
-        """
-        self.__uninhibit()
-        if suspend:
-            self.__inhibit_suspend()
-        if idle:
-            self.__inhibit_idle()
-        self.__manual_inhibit = True
-
-    def manual_uninhibit(self):
-        """
-            removing the manual inhibited state and restore the settings from
-            dconf
-        """
-        self.__manual_inhibit = False
-        self.__uninhibit()
-        self.__update_flags_settings()
diff --git a/lollypop/inotify.py b/lollypop/inotify.py
index dbc05dad..12df5d5f 100644
--- a/lollypop/inotify.py
+++ b/lollypop/inotify.py
@@ -14,6 +14,7 @@ from gi.repository import Gio, GLib
 
 from lollypop.define import Lp
 from lollypop.utils import is_audio
+from lollypop.lio import Lio
 
 
 class Inotify:
@@ -39,7 +40,7 @@ class Inotify:
         if uri in self.__monitors:
             return
         try:
-            f = Gio.File.new_for_uri(uri)
+            f = Lio.File.new_for_uri(uri)
             monitor = f.monitor_directory(Gio.FileMonitorFlags.NONE,
                                           None)
             if monitor is not None:
@@ -68,7 +69,7 @@ class Inotify:
         # Run update delayed
         else:
             uri = changed_file.get_uri()
-            d = Gio.File.new_for_uri(uri)
+            d = Lio.File.new_for_uri(uri)
             if d.query_exists():
                 # If a directory, monitor it
                 if changed_file.query_file_type(
diff --git a/lollypop/lastfm.py b/lollypop/lastfm.py
index a2b3e872..214ebbba 100644
--- a/lollypop/lastfm.py
+++ b/lollypop/lastfm.py
@@ -33,10 +33,10 @@ from pylast import LastFMNetwork, LibreFMNetwork, md5, BadAuthenticationError
 from pylast import SessionKeyGenerator
 from gettext import gettext as _
 from locale import getdefaultlocale
+from threading import Thread
 import re
 
-from lollypop.helper_task import TaskHelper
-from lollypop.define import Lp, Type
+from lollypop.define import Lp, SecretSchema, SecretAttributes, Type
 from lollypop.objects import Track
 from lollypop.utils import debug, get_network_available
 
@@ -53,21 +53,18 @@ class LastFM(LastFMNetwork, LibreFMNetwork):
        really have much option :).
     """
 
-    def __init__(self, name):
+    def __init__(self):
         """
             Init lastfm support
-            @param name as str
         """
-        self.__name = name
-        self.__login = ""
+        self.__username = ""
         self.__is_auth = False
         self.__password = None
-        self.__goa = None
         self.__check_for_proxy()
-        if name == "librefm":
+        self.__goa = self.__get_goa_oauth()
+        if self.__goa is None and Lp().settings.get_value("use-librefm"):
             LibreFMNetwork.__init__(self)
         else:
-            self.__goa = self.__get_goa_oauth()
             if self.__goa is not None:
                 self.__API_KEY = self.__goa.props.client_id
                 self.__API_SECRET = self.__goa.props.client_secret
@@ -77,25 +74,46 @@ class LastFM(LastFMNetwork, LibreFMNetwork):
             LastFMNetwork.__init__(self,
                                    api_key=self.__API_KEY,
                                    api_secret=self.__API_SECRET)
-        self.connect()
+        self.connect(None)
 
-    def connect(self, full_sync=False, callback=None, *args):
+    def connect(self, password):
         """
-            Connect service
-            @param full_sync as bool
-            @param callback as function
+            Connect lastfm
+            @param password as str/None
         """
         if self.__goa is not None:
-            helper = TaskHelper()
-            helper.run(self.__connect, full_sync)
-        elif get_network_available():
-            from lollypop.helper_passwords import PasswordsHelper
-            helper = PasswordsHelper()
-            helper.get(self.__name,
-                       self.__on_get_password,
-                       full_sync,
-                       callback,
-                       *args)
+            t = Thread(target=self.__connect, args=("", "", True))
+            t.daemon = True
+            t.start()
+        # Get username/password from GSettings/Secret
+        elif Secret is not None and\
+                get_network_available():
+            self.__username = Lp().settings.get_value(
+                                                   "lastfm-login").get_string()
+            if password is None:
+                schema = Secret.Schema.new("org.gnome.Lollypop",
+                                           Secret.SchemaFlags.NONE,
+                                           SecretSchema)
+                Secret.password_lookup(schema, SecretAttributes, None,
+                                       self.__on_password_lookup)
+            else:
+                t = Thread(target=self.__connect, args=(self.__username,
+                                                        password, True))
+                t.daemon = True
+                t.start()
+
+    def connect_sync(self, password):
+        """
+            Connect lastfm sync
+            @param password as str
+        """
+        if get_network_available():
+            self.__username = Lp().settings.get_value(
+                                                   "lastfm-login").get_string()
+            self.__connect(self.__username, password)
+            t = Thread(target=self.__populate_loved_tracks, args=(True,))
+            t.daemon = True
+            t.start()
 
     def get_artist_info(self, artist):
         """
@@ -126,8 +144,13 @@ class LastFM(LastFMNetwork, LibreFMNetwork):
         """
         if get_network_available() and\
            self.__is_auth and Secret is not None:
-            helper = TaskHelper()
-            helper.run(self.__scrobble, artist, album, title, timestamp)
+            t = Thread(target=self.__scrobble,
+                       args=(artist,
+                             album,
+                             title,
+                             timestamp))
+            t.daemon = True
+            t.start()
 
     def now_playing(self, artist, album, title, duration):
         """
@@ -139,8 +162,13 @@ class LastFM(LastFMNetwork, LibreFMNetwork):
         """
         if get_network_available() and\
            self.__is_auth and Secret is not None:
-            helper = TaskHelper()
-            helper.run(self.__now_playing, artist, album, title, duration)
+            t = Thread(target=self.__now_playing,
+                       args=(artist,
+                             album,
+                             title,
+                             duration))
+            t.daemon = True
+            t.start()
 
     def love(self, artist, title):
         """
@@ -238,14 +266,15 @@ class LastFM(LastFMNetwork, LibreFMNetwork):
         except:
             pass
 
-    def __connect(self, full_sync=False):
+    def __connect(self, username, password, populate_loved=False):
         """
-            Connect service
-            @param full_sync as bool
+            Connect lastfm
+            @param username as str
+            @param password as str
             @thread safe
         """
-        if self.__goa is not None or (self.__password != "" and
-                                      self.__login != ""):
+        self.__username = username
+        if self.__goa is not None or (password != "" and username != ""):
             self.__is_auth = True
         else:
             self.__is_auth = False
@@ -258,13 +287,12 @@ class LastFM(LastFMNetwork, LibreFMNetwork):
             else:
                 skg = SessionKeyGenerator(self)
                 self.session_key = skg.get_session_key(
-                                          username=self.__login,
-                                          password_hash=md5(self.__password))
-            if full_sync:
-                helper = TaskHelper()
-                helper.run(self.__populate_loved_tracks)
+                                                  username=self.__username,
+                                                  password_hash=md5(password))
+            if populate_loved:
+                self.__populate_loved_tracks()
         except Exception as e:
-            debug("LastFM::__connect(): %s" % e)
+            debug("Lastfm::__connect(): %s" % e)
             self.__is_auth = False
 
     def __scrobble(self, artist, album, title, timestamp, first=True):
@@ -290,10 +318,10 @@ class LastFM(LastFMNetwork, LibreFMNetwork):
         except BadAuthenticationError as e:
             pass
         except Exception as e:
-            print("LastFM::__scrobble():", e)
+            print("Lastfm::scrobble():", e)
             # Scrobble sometimes fails
             if first:
-                self.__connect()
+                self.__connect(self.__username, self.__password)
                 self.__scrobble(artist, album, title, timestamp, False)
 
     def __now_playing(self, artist, album, title, duration, first=True):
@@ -319,45 +347,46 @@ class LastFM(LastFMNetwork, LibreFMNetwork):
             if Lp().notify is not None:
                 GLib.idle_add(Lp().notify.send, _("Wrong Last.fm credentials"))
         except Exception as e:
-            print("LastFM::__now_playing():", e)
+            print("Lastfm::scrobble():", e)
             # now playing sometimes fails
             if first:
-                self.__connect()
+                self.__connect(self.__username, self.__password)
                 self.__now_playing(artist, album, title, duration, False)
 
-    def __populate_loved_tracks(self):
+    def __populate_loved_tracks(self, force=False):
         """
             Populate loved tracks playlist
+            @param bool as force
         """
         if not self.__is_auth:
             return
         try:
-            tracks = []
-            user = self.get_user(self.__login)
-            for loved in user.get_loved_tracks():
-                track_id = Lp().tracks.search_track(
-                                                  str(loved.track.artist),
-                                                  str(loved.track.title))
-                if track_id is not None:
-                    tracks.append(Track(track_id))
-            Lp().playlists.add_tracks(Type.LOVED, tracks)
+            if force or len(Lp().playlists.get_tracks(Type.LOVED)) == 0:
+                tracks = []
+                user = self.get_user(self.__username)
+                for loved in user.get_loved_tracks():
+                    track_id = Lp().tracks.search_track(
+                                                      str(loved.track.artist),
+                                                      str(loved.track.title))
+                    if track_id is not None:
+                        tracks.append(Track(track_id))
+                Lp().playlists.add_tracks(Type.LOVED, tracks)
         except Exception as e:
                 print("LastFM::__populate_loved_tracks: %s" % e)
 
-    def __on_get_password(self, attributes, password,
-                          name, full_sync, callback, *args):
+    def __on_password_lookup(self, source, result):
         """
-             Set password label
-             @param attributes as {}
-             @param password as str
-             @param name as str
-             @param full_sync as bool
-             @param callback as function
+            Init self object
+            @param source as GObject.Object
+            @param result Gio.AsyncResult
         """
-        if attributes is None:
-            return
-        self.__login = attributes["login"]
-        self.__password = password
-        if get_network_available():
-            helper = TaskHelper()
-            helper.run(self.__connect, full_sync, callback=(callback, *args))
+        try:
+            password = Secret.password_lookup_finish(result)
+            self.__password = password
+            if get_network_available():
+                t = Thread(target=self.__connect,
+                           args=(self.__username, password))
+                t.daemon = True
+                t.start()
+        except Exception as e:
+            print("Lastfm::__on_password_lookup(): %s" % e)
diff --git a/lollypop/lio.py b/lollypop/lio.py
new file mode 100644
index 00000000..ee334639
--- /dev/null
+++ b/lollypop/lio.py
@@ -0,0 +1,76 @@
+# Copyright (c) 2014-2017 Cedric Bellegarde <cedric.bellegarde@adishatz.org>
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+# GNU General Public License for more details.
+# You should have received a copy of the GNU General Public License
+# along with this program. If not, see <http://www.gnu.org/licenses/>.
+
+import gi
+gi.require_version("Soup", "2.4")
+
+from gi.repository import Gio, GObject, Soup
+
+from lollypop.define import Lp
+
+
+class Lio:
+    class File(GObject.Object, Gio.File):
+        """
+            Extending Gio.File
+            - http download over libsoup
+        """
+        def new_for_uri(uri):
+            f = Gio.File.new_for_uri(uri)
+            f.__class__ = Lio.File
+            f.__token = None
+            return f
+
+        def add_spotify_headers(self, token):
+            """
+                Add spotify headers
+                @param token as str
+            """
+            self.__token = token
+
+        def load_contents(self, cancellable=None):
+            """
+                Load uri with libsoup (better performance)
+                @param cancellable as Gio.Cancellable
+            """
+            try:
+                uri = self.get_uri()
+                if uri.startswith("http") or uri.startswith("https"):
+                    session = Soup.Session.new()
+                    # Post message
+                    if self.__token is not None:
+                        msg = Soup.Message.new("GET", uri)
+                        headers = msg.get_property("request-headers")
+                        headers.append("Authorization",
+                                       "Bearer %s" % self.__token)
+                        session.send_message(msg)
+                        body = msg.get_property("response-body")
+                        bytes = body.flatten().get_data()
+                    # Get message
+                    else:
+                        request = session.request(uri)
+                        stream = request.send(cancellable)
+                        bytes = bytearray(0)
+                        buf = stream.read_bytes(1024, cancellable).get_data()
+                        while buf:
+                            bytes += buf
+                            buf = stream.read_bytes(1024,
+                                                    cancellable).get_data()
+                        stream.close()
+                    return (True, bytes, "")
+                else:
+                    return Gio.File.load_contents(self, cancellable)
+            except Exception as e:
+                # FIXME Use debug, need to be moved outside utils.py
+                if Lp().debug:
+                    print("Lio.load_contents():",  e)
+                return (False, b"", "")
diff --git a/lollypop/list.py b/lollypop/list.py
index bf8e30dd..baf1461c 100644
--- a/lollypop/list.py
+++ b/lollypop/list.py
@@ -25,54 +25,49 @@ class LinkedList:
         self.__next = next
         self.__prev = prev
 
-    def set_next(self, next):
+    def has_next(self):
         """
-            Set next
-            @param next as linked list
+            True if list has next
+            @return has next as bool
         """
-        self.__next = next
+        return self.__next is not None
 
-    def set_prev(self, prev):
+    def get_next(self):
         """
-            Set prev
-            @param prev as linked list
+            Return next
+            @return next as LinkedList
         """
-        self.__prev = prev
+        return self.__next
 
-    @property
-    def has_next(self):
+    def set_next(self, next):
         """
-            True if list has next
-            @return bool
+            Set next
+            @param next as linked list
         """
-        return self.__next is not None
+        self.__next = next
 
-    @property
     def has_prev(self):
         """
             True if list has prev
-            @return bool
+            @return has next as bool
         """
         return self.__prev is not None
 
-    @property
-    def prev(self):
+    def get_prev(self):
         """
             Return prev
             @return prev as LinkedList
         """
         return self.__prev
 
-    @property
-    def next(self):
+    def set_prev(self, prev):
         """
-            Return next
-            @return next as LinkedList
+            Set prev
+            @param prev as linked list
         """
-        return self.__next
+        self.__prev = prev
 
-    @property
-    def value(self):
+    def get_value(self):
         """
             Get value
             @return value as int
diff --git a/lollypop/mpris.py b/lollypop/mpris.py
index 1b88347d..692e0937 100644
--- a/lollypop/mpris.py
+++ b/lollypop/mpris.py
@@ -18,7 +18,7 @@ from gi.repository import Gio, Gst, GLib, Gtk
 
 from random import randint
 
-from lollypop.define import Lp, ArtSize, Type, Shuffle, NextContext
+from lollypop.define import Lp, ArtSize, Type
 
 
 class Server:
@@ -152,37 +152,16 @@ class MPRIS(Server):
             <property name="CanSeek" type="b" access="read"/>
             <property name="CanControl" type="b" access="read"/>
         </interface>
-        <interface name="org.mpris.MediaPlayer2.ExtensionSetRatings">
-            <method name="SetRating">\
-                <arg direction="in" name="TrackId" type="o"/>
-                <arg direction="in" name="Rating" type="d"/>\
-            </method>\
-            <property name="HasRatingsExtension" type="b" access="read"/>\
-        </interface>
     </node>
     """
     __MPRIS_IFACE = "org.mpris.MediaPlayer2"
     __MPRIS_PLAYER_IFACE = "org.mpris.MediaPlayer2.Player"
-    __MPRIS_RATINGS_IFACE = "org.mpris.MediaPlayer2.ExtensionSetRatings"
     __MPRIS_LOLLYPOP = "org.mpris.MediaPlayer2.Lollypop"
     __MPRIS_PATH = "/org/mpris/MediaPlayer2"
 
     def __init__(self, app):
         self.__app = app
-        self.__rating = None
-        self.__lollypop_id = 0
-        self.__metadata = {"mpris:trackid": GLib.Variant(
-                                  "o",
-                                  "/org/mpris/MediaPlayer2/TrackList/NoTrack")}
-        # Get the shuffle state for our shuffle toggle setting so we can
-        # remember the last non-NONE suffle state if we start with Shuffle.NONE
-        # then our "on" setting starts with Shuffle.TRACKS.
-        shuffle_state = Lp().settings.get_enum("shuffle")
-        if shuffle_state != Shuffle.NONE:
-            self.__shuffle_state = shuffle_state
-        else:
-            self.__shuffle_state = Shuffle.TRACKS
-        self.__track_id = self.__get_media_id(0)
+        self.__metadata = {}
         self.__bus = Gio.bus_get_sync(Gio.BusType.SESSION, None)
         Gio.bus_own_name_on_connection(self.__bus,
                                        self.__MPRIS_LOLLYPOP,
@@ -191,12 +170,10 @@ class MPRIS(Server):
                                        None)
         Server.__init__(self, self.__bus, self.__MPRIS_PATH)
         Lp().player.connect("current-changed", self.__on_current_changed)
+        Lp().player.connect("rate-changed", self.__on_current_changed)
         Lp().player.connect("seeked", self.__on_seeked)
         Lp().player.connect("status-changed", self.__on_status_changed)
         Lp().player.connect("volume-changed", self.__on_volume_changed)
-        Lp().player.connect("rate-changed", self.__on_rate_changed)
-        Lp().settings.connect("changed::shuffle", self.__on_shuffle_changed)
-        Lp().settings.connect("changed::playback", self.__on_playback_changed)
 
     def Raise(self):
         self.__app.window.setup_window()
@@ -245,21 +222,11 @@ class MPRIS(Server):
                           "Seeked",
                           GLib.Variant.new_tuple(GLib.Variant("x", position)))
 
-    def SetRating(self, track_id, rating):
-        # We don't currently care about the trackId since
-        # we have not yet implemented the TrackList interface.
-        Lp().player.current_track.set_rate(int(rating * 5))
-
     def Get(self, interface, property_name):
-        if property_name in ["CanQuit", "CanRaise", "CanSeek",
-                             "CanControl", "HasRatingsExtension"]:
+        if property_name in ["CanQuit", "CanRaise", "CanSeek", "CanControl"]:
             return GLib.Variant("b", True)
-        elif property_name == "HasTrackList":
+        elif property_name in ["HasTrackList", "Shuffle"]:
             return GLib.Variant("b", False)
-        elif property_name == "Shuffle":
-            return GLib.Variant(
-                           "b",
-                           Lp().settings.get_enum("shuffle") != Shuffle.NONE)
         elif property_name in ["Rate", "MinimumRate", "MaximumRate"]:
             return GLib.Variant("d", 1.0)
         elif property_name == "Identity":
@@ -276,14 +243,7 @@ class MPRIS(Server):
         elif property_name == "PlaybackStatus":
             return GLib.Variant("s", self.__get_status())
         elif property_name == "LoopStatus":
-            repeat = Lp().settings.get_enum("playback")
-            if repeat == NextContext.NONE:
-                value = "Playlist"
-            elif repeat == NextContext.REPEAT_TRACK:
-                value = "Track"
-            else:
-                value = "None"
-            return GLib.Variant("s", value)
+            return GLib.Variant("s", "Playlist")
         elif property_name == "Metadata":
             return GLib.Variant("a{sv}", self.__metadata)
         elif property_name == "Volume":
@@ -324,26 +284,11 @@ class MPRIS(Server):
                                   "CanSeek",
                                   "CanControl"]:
                 ret[property_name] = self.Get(interface, property_name)
-        elif interface == self.__MPRIS_RATINGS_IFACE:
-            ret["HasRatingsExtension"] = GLib.Variant("b", True)
         return ret
 
     def Set(self, interface, property_name, new_value):
         if property_name == "Volume":
             Lp().player.set_volume(new_value)
-        elif property_name == "Shuffle":
-            if new_value is True:
-                Lp().settings.set_enum("shuffle", self.__shuffle_state)
-            else:
-                Lp().settings.set_enum("shuffle", Shuffle.NONE)
-        elif property_name == "LoopStatus":
-            if new_value == "Playlist":
-                value = NextContext.NONE
-            elif new_value == "Track":
-                value = NextContext.REPEAT_TRACK
-            else:
-                value = NextContext.STOP
-            Lp().settings.set_enum("playback", value)
 
     def PropertiesChanged(self, interface_name, changed_properties,
                           invalidated_properties):
@@ -362,15 +307,9 @@ class MPRIS(Server):
 #######################
 # PRIVATE             #
 #######################
-
     def __get_media_id(self, track_id):
-        """
-            TrackId's must be unique even up to
-            the point that if you repeat a song
-            it must have a different TrackId.
-        """
-        track_id = track_id + randint(10000000, 90000000)
-        return GLib.Variant("o", "/org/gnome/Lollypop/TrackId/%s" % track_id)
+        return GLib.Variant("s", "/org/mpris/MediaPlayer2/TrackList/%s" %
+                            (track_id if track_id is not None else "NoTrack"))
 
     def __get_status(self):
         state = Lp().player.get_status()
@@ -383,11 +322,13 @@ class MPRIS(Server):
 
     def __update_metadata(self):
         if self.__get_status() == "Stopped":
-            self.__metadata = {"mpris:trackid": GLib.Variant(
-                                  "o",
-                                  "/org/mpris/MediaPlayer2/TrackList/NoTrack")}
+            self.__metadata = {}
         else:
-            self.__metadata["mpris:trackid"] = self.__track_id
+            if Lp().player.current_track.id >= 0:
+                track_id = Lp().player.current_track.id
+            else:
+                track_id = randint(10000000, 90000000)
+            self.__metadata["mpris:trackid"] = self.__get_media_id(track_id)
             track_number = Lp().player.current_track.number
             if track_number is None:
                 track_number = 1
@@ -414,11 +355,10 @@ class MPRIS(Server):
             self.__metadata["xesam:url"] = GLib.Variant(
                                                  "s",
                                                  Lp().player.current_track.uri)
-            if self.__rating is None:
-                self.__rating = Lp().player.current_track.get_rate()
-            self.__metadata["xesam:userRating"] = GLib.Variant(
-                                                             "d",
-                                                             self.__rating / 5)
+            rate = Lp().player.current_track.get_rate()
+            if rate == Type.NONE:
+                rate = Lp().player.current_track.get_popularity()
+            self.__metadata["xesam:userRating"] = GLib.Variant("d", rate / 5)
             if Lp().player.current_track.id == Type.RADIOS:
                 cover_path = Lp().art.get_radio_cache_path(
                      ", ".join(Lp().player.current_track.artists),
@@ -438,6 +378,8 @@ class MPRIS(Server):
                 self.__metadata["mpris:artUrl"] = GLib.Variant(
                                                         "s",
                                                         "file://" + cover_path)
+            elif "mpris:artUrl" in self.__metadata:
+                self.__metadata["mpris:artUrl"] = GLib.Variant("s", "")
 
     def __on_seeked(self, player, position):
         self.Seeked(position * (1000 * 1000))
@@ -448,46 +390,7 @@ class MPRIS(Server):
                                 Lp().player.volume), },
                                [])
 
-    def __on_shuffle_changed(self, settings, value):
-        shuffle_state = Lp().settings.get_enum("shuffle")
-        # We only want to remember the last non-NONE shuffle state.
-        if shuffle_state != Shuffle.NONE:
-            self.__shuffle_state = shuffle_state
-        value = GLib.Variant(
-                           "b",
-                           shuffle_state != Shuffle.NONE)
-        properties = {"Shuffle": GLib.Variant("b", value)}
-        self.PropertiesChanged(self.__MPRIS_PLAYER_IFACE, properties, [])
-
-    def __on_playback_changed(self, settings, value):
-        value = Lp().settings.get_enum("playback")
-        if value == NextContext.NONE:
-            mpris_value = "Playlist"
-        elif value == NextContext.REPEAT_TRACK:
-            mpris_value = "Track"
-        else:
-            mpris_value = "None"
-        properties = {"LoopStatus": GLib.Variant("s", mpris_value)}
-        self.PropertiesChanged(self.__MPRIS_PLAYER_IFACE, properties, [])
-
-    def __on_rate_changed(self, player, id_rating):
-        rated_track_id, rating = id_rating
-        # We only care about the current Track's rating.
-        if rated_track_id == self.__lollypop_id and self.__rating != rating:
-            self.__rating = rating
-            self.__update_metadata()
-            properties = {"Metadata": GLib.Variant("a{sv}", self.__metadata)}
-            self.PropertiesChanged(self.__MPRIS_PLAYER_IFACE, properties, [])
-
     def __on_current_changed(self, player):
-        current_track_id = Lp().player.current_track.id
-        if current_track_id and current_track_id >= 0:
-            self.__lollypop_id = current_track_id
-        else:
-            self.__lollypop_id = 0
-        # We only need to recalculate a new trackId at song changes.
-        self.__track_id = self.__get_media_id(self.__lollypop_id)
-        self.__rating = None
         self.__update_metadata()
         properties = {"Metadata": GLib.Variant("a{sv}", self.__metadata),
                       "CanPlay": GLib.Variant("b", True),
diff --git a/lollypop/mpris_legacy.py b/lollypop/mpris_legacy.py
new file mode 100644
index 00000000..2a0f580c
--- /dev/null
+++ b/lollypop/mpris_legacy.py
@@ -0,0 +1,235 @@
+# Copyright (c) 2014-2017 Cedric Bellegarde <cedric.bellegarde@adishatz.org>
+# Copyright (c) 2013 Arnel A. Borja <kyoushuu@yahoo.com>
+# Copyright (c) 2013 Vadim Rutkovsky <vrutkovs@redhat.com>
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+# GNU General Public License for more details.
+# You should have received a copy of the GNU General Public License
+# along with this program. If not, see <http://www.gnu.org/licenses/>.
+
+import dbus
+import dbus.service
+from dbus.mainloop.glib import DBusGMainLoop
+from random import randint
+
+from gi.repository import Gst, GLib
+
+from lollypop.define import Lp, ArtSize, Type
+
+
+class MPRIS(dbus.service.Object):
+    MPRIS_IFACE = "org.mpris.MediaPlayer2"
+    MPRIS_PLAYER_IFACE = "org.mpris.MediaPlayer2.Player"
+    MPRIS_LOLLYPOP = "org.mpris.MediaPlayer2.Lollypop"
+    MPRIS_PATH = "/org/mpris/MediaPlayer2"
+
+    def __init__(self, app):
+        DBusGMainLoop(set_as_default=True)
+        name = dbus.service.BusName(self.MPRIS_LOLLYPOP, dbus.SessionBus())
+        dbus.service.Object.__init__(self, name, self.MPRIS_PATH)
+        self._app = app
+        self._metadata = {}
+        Lp().player.connect("current-changed", self._on_current_changed)
+        Lp().player.connect("rate-changed", self._on_current_changed)
+        Lp().player.connect("seeked", self._on_seeked)
+        Lp().player.connect("status-changed", self._on_status_changed)
+        Lp().player.connect("volume-changed", self._on_volume_changed)
+
+    @dbus.service.method(dbus_interface=MPRIS_IFACE)
+    def Raise(self):
+        self.__app.window.setup_window()
+        self.__app.window.present()
+
+    @dbus.service.method(dbus_interface=MPRIS_IFACE)
+    def Quit(self):
+        self._app.quit()
+
+    @dbus.service.method(dbus_interface=MPRIS_PLAYER_IFACE)
+    def Next(self):
+        if Lp().notify is not None:
+            Lp().notify.inhibit()
+        Lp().player.next()
+
+    @dbus.service.method(dbus_interface=MPRIS_PLAYER_IFACE)
+    def Previous(self):
+        if Lp().notify is not None:
+            Lp().notify.inhibit()
+        Lp().player.prev()
+
+    @dbus.service.method(dbus_interface=MPRIS_PLAYER_IFACE)
+    def Pause(self):
+        Lp().player.pause()
+
+    @dbus.service.method(dbus_interface=MPRIS_PLAYER_IFACE)
+    def PlayPause(self):
+        Lp().player.play_pause()
+
+    @dbus.service.method(dbus_interface=MPRIS_PLAYER_IFACE)
+    def Stop(self):
+        Lp().player.stop()
+
+    @dbus.service.method(dbus_interface=MPRIS_PLAYER_IFACE)
+    def Play(self):
+        if Lp().player.current_track.id is None:
+            Lp().player.set_party(True)
+        else:
+            Lp().player.play()
+
+    @dbus.service.method(dbus_interface=MPRIS_PLAYER_IFACE,
+                         in_signature="ox")
+    def SetPosition(self, track_id, position):
+        Lp().player.seek(position/(1000 * 1000))
+
+    @dbus.service.method(dbus_interface=MPRIS_PLAYER_IFACE,
+                         in_signature="s")
+    def OpenUri(self, uri):
+        pass
+
+    @dbus.service.signal(dbus_interface=MPRIS_PLAYER_IFACE,
+                         signature="x")
+    def Seeked(self, position):
+        pass
+
+    @dbus.service.method(dbus_interface=dbus.PROPERTIES_IFACE,
+                         in_signature="ss", out_signature="v")
+    def Get(self, interface, property_name):
+        return self.GetAll(interface)[property_name]
+
+    @dbus.service.method(dbus_interface=dbus.PROPERTIES_IFACE,
+                         in_signature="s", out_signature="a{sv}")
+    def GetAll(self, interface):
+        if interface == self.MPRIS_IFACE:
+            return {
+                "CanQuit": True,
+                "CanRaise": True,
+                "HasTrackList": False,
+                "Identity": "Lollypop",
+                "DesktopEntry": "org.gnome.Lollypop"
+            }
+        elif interface == self.MPRIS_PLAYER_IFACE:
+            return {
+                "PlaybackStatus": self._get_status(),
+                "LoopStatus": "Playlist",
+                "Rate": dbus.Double(1.0),
+                "Shuffle": True,
+                "Metadata": dbus.Dictionary(self._metadata, signature="sv"),
+                "Volume": dbus.Double(Lp().player.volume),
+                "Position": dbus.Int64(
+                              Lp().player.position / Gst.SECOND * 1000 * 1000),
+                "MinimumRate": dbus.Double(1.0),
+                "MaximumRate": dbus.Double(1.0),
+                "CanGoNext": True,
+                "CanGoPrevious": True,
+                "CanPlay": True,
+                "CanPause": True,
+                "CanSeek": True,
+                "CanControl": True,
+            }
+        else:
+            raise dbus.exceptions.DBusException(
+                self.MPRIS_LOLLYPOP,
+                "Lollypop doesn't handle %s interface"
+                % interface)
+
+    @dbus.service.method(dbus_interface=dbus.PROPERTIES_IFACE,
+                         in_signature="ssv")
+    def Set(self, interface, property_name, new_value):
+        if property_name == "Volume":
+            Lp().player.set_volume(new_value)
+
+    @dbus.service.signal(dbus_interface=dbus.PROPERTIES_IFACE,
+                         signature="sa{sv}as")
+    def PropertiesChanged(self, interface, changed_properties,
+                          invalidated_properties):
+        pass
+
+#######################
+# PRIVATE             #
+#######################
+
+    def _get_status(self):
+        state = Lp().player.get_status()
+        if state == Gst.State.PLAYING:
+            return "Playing"
+        elif state == Gst.State.PAUSED:
+            return "Paused"
+        else:
+            return "Stopped"
+
+    def _update_metadata(self):
+        if self._get_status() == "Stopped":
+            self._metadata = {}
+        else:
+            if Lp().player.current_track.id >= 0:
+                self._metadata["mpris:trackid"] = dbus.ObjectPath(
+                    "/org/lollypop/%s" % Lp().player.current_track.id)
+            else:
+                # MPRIS SUX
+                track_id = randint(10000000, 90000000)
+                self._metadata["mpris:trackid"] = dbus.ObjectPath(
+                    "/org/lollypop/%s" % track_id)
+            track_number = Lp().player.current_track.number
+            if track_number is None:
+                track_number = 1
+            self._metadata["xesam:trackNumber"] = track_number
+            self._metadata["xesam:title"] = Lp().player.current_track.name
+            self._metadata["xesam:album"] = Lp(
+                                              ).player.current_track.album.name
+            self._metadata["xesam:artist"] = Lp().player.current_track.artists
+            self._metadata["xesam:albumArtist"] = \
+                ", ".join(Lp().player.current_track.album_artists)
+            self._metadata["mpris:length"] = dbus.Int64(
+                Lp().player.current_track.duration * (1000 * 1000))
+            self._metadata["xesam:genre"] = Lp().player.current_track.genres\
+                or "Web"
+            self._metadata["xesam:url"] = Lp().player.current_track.uri
+            rate = Lp().player.current_track.get_rate()
+            if rate == Type.NONE:
+                rate = Lp().player.current_track.get_popularity()
+            self._metadata["xesam:userRating"] = dbus.Double(rate / 5)
+            if Lp().player.current_track.id == Type.RADIOS:
+                cover_path = Lp().art.get_radio_cache_path(
+                     ", ".join(Lp().player.current_track.artists),
+                     ArtSize.MONSTER)
+            elif Lp().player.current_track.id == Type.EXTERNALS:
+                cover_path = "/tmp/lollypop_mpris.jpg"
+                pixbuf = Lp().art.pixbuf_from_tags(
+                    GLib.filename_from_uri(Lp().player.current_track.uri)[0],
+                    ArtSize.MONSTER)
+                if pixbuf is not None:
+                    pixbuf.savev(cover_path, "jpeg",
+                                 ["quality"], ["90"])
+            else:
+                cover_path = Lp().art.get_album_cache_path(
+                    Lp().player.current_track.album, ArtSize.MONSTER)
+            if cover_path is not None:
+                self._metadata["mpris:artUrl"] = "file://" + cover_path
+            elif "mpris:artUrl" in self._metadata:
+                self._metadata["mpris:artUrl"] = ""
+
+    def _on_seeked(self, player, position):
+        self.Seeked(position * (1000 * 1000))
+
+    def _on_volume_changed(self, player, data=None):
+        self.PropertiesChanged(self.MPRIS_PLAYER_IFACE,
+                               {"Volume": dbus.Double(
+                                Lp().player.volume), },
+                               [])
+
+    def _on_current_changed(self, player):
+        self._update_metadata()
+        properties = {"Metadata": dbus.Dictionary(self._metadata,
+                                                  signature="sv")}
+        try:
+            self.PropertiesChanged(self.MPRIS_PLAYER_IFACE, properties, [])
+        except Exception as e:
+            print("MPRIS::_on_current_changed(): %s" % e)
+
+    def _on_status_changed(self, data=None):
+        properties = {"PlaybackStatus": self._get_status()}
+        self.PropertiesChanged(self.MPRIS_PLAYER_IFACE, properties, [])
diff --git a/lollypop/notification.py b/lollypop/notification.py
index e8ea3854..2e0e74af 100644
--- a/lollypop/notification.py
+++ b/lollypop/notification.py
@@ -13,7 +13,7 @@
 from gi.repository import Gdk, GLib
 from gettext import gettext as _
 
-from lollypop.thirdparty.GioNotify import GioNotify
+from lollypop.GioNotify import GioNotify
 
 from lollypop.define import Lp, ArtSize, Type
 from lollypop.utils import is_gnome
@@ -28,13 +28,12 @@ class NotificationManager:
         """
             Init notification object with lollypop infos
         """
+        self.__inhibitor = False
+        self.__fully_initted = False
         self.__supports_actions = False
-        self.__disable_all_notifications = True
         self.__is_gnome = is_gnome()
-        self.__notification = None
-        self.__notification_handler_id = None
-        GioNotify.async_init("Lollypop",
-                             self.__on_init_finish)
+        self.__notification = GioNotify.async_init("Lollypop",
+                                                   self.__on_init_finish)
 
     def send(self, message, sub=""):
         """
@@ -42,8 +41,7 @@ class NotificationManager:
             @param message as str
             @param sub as str
         """
-
-        if self.__disable_all_notifications:
+        if not self.__fully_initted:
             return
 
         if self.__supports_actions:
@@ -52,29 +50,27 @@ class NotificationManager:
         self.__notification.show_new(
             message,
             sub,
-            "org.gnome.Lollypop-symbolic",
+            "org.gnome.Lollypop",
         )
 
         if self.__supports_actions:
             self.__set_actions()
 
+    def inhibit(self):
+        """
+            Inhibit notifications for one shot
+        """
+        self.__inhibitor = True
+
 #######################
 # PRIVATE             #
 #######################
 
-    def __on_init_finish(self, notification, server_info, caps, error=None):
+    def __on_init_finish(self, caps):
         """
             Set actions and connect signals
-            @param notification as GioNotify
-            @param server_info as {}
             @param caps as [str]
         """
-        if error is not None:
-            print("notification::__on_init_finish():", error)
-            return
-
-        self.__notification = notification
-
         self.__notification.set_hint(
             "category",
             GLib.Variant("s", "x-gnome.music"),
@@ -101,17 +97,12 @@ class NotificationManager:
             self.__supports_actions = True
             self.__set_actions()
 
-        self.__on_notifications_settings_changed()
-
-        Lp().settings.connect(
-            "changed::disable-song-notifications",
-            self.__on_notifications_settings_changed,
+        Lp().player.connect(
+            "current-changed",
+            self.__on_current_changed,
         )
 
-        Lp().settings.connect(
-            "changed::disable-notifications",
-            self.__on_notifications_settings_changed,
-        )
+        self.__fully_initted = True
 
     def __set_actions(self):
         """
@@ -135,6 +126,9 @@ class NotificationManager:
             Send notification with track_id infos
             @param player Player
         """
+        if player.current_track.title == "" or self.__inhibitor:
+            self.__inhibitor = False
+            return
         state = Lp().window.get_window().get_state()
         if player.current_track.id is None or\
                 state & Gdk.WindowState.FOCUSED or\
@@ -169,23 +163,3 @@ class NotificationManager:
                 ("<b>" + ", ".join(player.current_track.artists) + "</b>",
                  "<i>" + player.current_track.album.name + "</i>"),
                 cover_path)
-
-    def __on_notifications_settings_changed(self, *ignore):
-        self.__disable_all_notifications = Lp().settings.get_value(
-            "disable-notifications",
-        )
-
-        disable_song_notifications = Lp().settings.get_value(
-            "disable-song-notifications",
-        )
-
-        if self.__notification_handler_id:
-            Lp().player.disconnect(self.__notification_handler_id)
-            self.__notification_handler_id = None
-
-        if (not self.__disable_all_notifications and not
-                disable_song_notifications):
-            self.__notification_handler_id = Lp().player.connect(
-                "current-changed",
-                self.__on_current_changed,
-            )
diff --git a/lollypop/objects.py b/lollypop/objects.py
index 538aa113..ce3ae2aa 100644
--- a/lollypop/objects.py
+++ b/lollypop/objects.py
@@ -115,7 +115,6 @@ class Base:
             radios.set_rate(self._album_artists[0], rate)
         else:
             self.db.set_rate(self.id, rate)
-            Lp().player.emit("rate-changed", (self.id, rate))
 
 
 class Disc:
@@ -243,6 +242,14 @@ class Album(Base):
             self._tracks = [Track(track_id) for track_id in self.track_ids]
         return self._tracks
 
+    @property
+    def is_web(self):
+        """
+            True if a web stream
+            @return bool
+        """
+        return self.synced == Type.NONE
+
     def disc_names(self, disc):
         """
             Disc names
@@ -305,10 +312,10 @@ class Track(Base):
     """
         Represent a track
     """
-    FIELDS = ["name", "album_id", "album_artist_ids", "artist_ids",
-              "genre_ids", "popularity", "album_name", "artists", "genres",
+    FIELDS = ["name", "album_id", "album_artist_ids",
+              "artist_ids", "genre_ids", "album_name", "artists", "genres",
               "duration", "number", "year", "persistent", "mtime"]
-    DEFAULTS = ["", None, [], [], [], 0, "", "", "", 0.0, 0, None, 1, 0]
+    DEFAULTS = ["", None, [], [], [], "", "", "", 0.0, 0, None, 1, 0]
 
     def __init__(self, track_id=None):
         """
@@ -320,6 +327,30 @@ class Track(Base):
         self._uri = None
         self._non_album_artists = []
 
+    @property
+    def is_web(self):
+        """
+            True if a web stream
+            @return bool
+        """
+        return self.is_jgm or self.is_youtube
+
+    @property
+    def is_jgm(self):
+        """
+            True if a jgm stream
+            @return bool
+        """
+        return self.uri.startswith("http://app.jgm90.com")
+
+    @property
+    def is_youtube(self):
+        """
+            True if a youtube stream
+            @return bool
+        """
+        return self.uri.startswith("https://www.youtube.com")
+
     @property
     def non_album_artists(self):
         """
diff --git a/lollypop/player.py b/lollypop/player.py
index c0b00844..5942eaec 100644
--- a/lollypop/player.py
+++ b/lollypop/player.py
@@ -10,7 +10,7 @@
 # You should have received a copy of the GNU General Public License
 # along with this program. If not, see <http://www.gnu.org/licenses/>.
 
-from gi.repository import Gst
+from gi.repository import Gio, GLib, Gst
 
 from pickle import load
 from random import choice
@@ -103,9 +103,19 @@ class Player(BinPlayer, QueuePlayer, UserPlaylistPlayer, RadioPlayer,
             @param play as bool, ignored for radios
         """
         if track.id == Type.RADIOS:
+            if not Lp().scanner.is_locked():
+                Lp().window.pulse(False)
+                Lp().window.pulse(True)
             RadioPlayer.load(self, track)
         else:
             if play:
+                if track.is_web and\
+                        not Gio.NetworkMonitor.get_default(
+                                                     ).get_network_available():
+                    self._current_track = track
+                    self.set_next()
+                    GLib.idle_add(self.next)
+                    return
                 # Do not update next if user clicked on a track
                 if self.is_party and track != self._next_track:
                     self.__do_not_update_next = True
@@ -303,6 +313,9 @@ class Player(BinPlayer, QueuePlayer, UserPlaylistPlayer, RadioPlayer,
         # We are in compilation view without genre
         elif genre_ids and genre_ids[0] == Type.COMPILATIONS:
             self._albums = Lp().albums.get_compilation_ids()
+        # We are in charts view with a genre
+        elif artist_ids and artist_ids[0] == Type.CHARTS:
+            self._albums = Lp().albums.get_charts_ids(genre_ids)
         # Add albums for artists/genres
         else:
             # If we are not in compilation view and show compilation is on,
@@ -505,6 +518,8 @@ class Player(BinPlayer, QueuePlayer, UserPlaylistPlayer, RadioPlayer,
             # Get a linear track then
             if next_track.id is None:
                 next_track = LinearPlayer.next(self)
+            if next_track.is_web:
+                self._load_web(next_track, False)
             self._next_track = next_track
             self.emit("next-changed")
         except Exception as e:
@@ -540,15 +555,6 @@ class Player(BinPlayer, QueuePlayer, UserPlaylistPlayer, RadioPlayer,
 #######################
 # PROTECTED           #
 #######################
-    def _on_bus_error(self, bus, message):
-        """
-            Pass error to Bin/Radio
-            @param bus as Gst.Bus
-            @param message as Gst.Message
-        """
-        BinPlayer._on_bus_error(self, bus, message)
-        RadioPlayer._on_bus_error(self, bus, message)
-
     def _on_stream_start(self, bus, message):
         """
             On stream start, set next and previous track
diff --git a/lollypop/player_base.py b/lollypop/player_base.py
index 96fc8421..23af4102 100644
--- a/lollypop/player_base.py
+++ b/lollypop/player_base.py
@@ -33,8 +33,7 @@ class BasePlayer(GObject.GObject):
         "loading-changed": (GObject.SignalFlags.RUN_FIRST, None, (bool,)),
         "queue-changed": (GObject.SignalFlags.RUN_FIRST, None, ()),
         "duration-changed": (GObject.SignalFlags.RUN_FIRST, None, (int,)),
-        "rate-changed": (GObject.SignalFlags.RUN_FIRST, None,
-                         (GObject.TYPE_PYOBJECT,)),
+        "rate-changed": (GObject.SignalFlags.RUN_FIRST, None, ()),
         "party-changed": (GObject.SignalFlags.RUN_FIRST, None, (bool,))
     }
 
diff --git a/lollypop/player_bin.py b/lollypop/player_bin.py
index 02bf1076..923fac1b 100644
--- a/lollypop/player_bin.py
+++ b/lollypop/player_bin.py
@@ -13,14 +13,16 @@
 from gi.repository import Gst, GstAudio, GstPbutils, GLib
 
 from time import time
+from threading import Thread
 
 from lollypop.player_base import BasePlayer
 from lollypop.tagreader import TagReader
 from lollypop.player_plugins import PluginsPlayer
 from lollypop.define import GstPlayFlags, NextContext, Lp
 from lollypop.codecs import Codecs
-from lollypop.define import Type
-from lollypop.utils import debug
+from lollypop.define import Type, DbPersistent
+from lollypop.utils import debug, get_network_available
+from lollypop.objects import Track
 
 
 class BinPlayer(BasePlayer):
@@ -49,14 +51,14 @@ class BinPlayer(BasePlayer):
             playbin.set_property("buffer-size", 5 << 20)
             playbin.set_property("buffer-duration", 10 * Gst.SECOND)
             playbin.connect("about-to-finish",
-                            self._on_stream_about_to_finish)
+                            self.__on_stream_about_to_finish)
             bus = playbin.get_bus()
             bus.add_signal_watch()
-            bus.connect("message::error", self._on_bus_error)
-            bus.connect("message::eos", self._on_bus_eos)
-            bus.connect("message::element", self._on_bus_element)
+            bus.connect("message::error", self.__on_bus_error)
+            bus.connect("message::eos", self.__on_bus_eos)
+            bus.connect("message::element", self.__on_bus_element)
             bus.connect("message::stream-start", self._on_stream_start)
-            bus.connect("message::tag", self._on_bus_message_tag)
+            bus.connect("message::tag", self.__on_bus_message_tag)
         self._start_time = 0
 
     @property
@@ -250,12 +252,49 @@ class BinPlayer(BasePlayer):
         debug("BinPlayer::_load_track(): %s" % track.uri)
         try:
             self._current_track = track
-            self._playbin.set_property("uri", track.uri)
+            if track.is_web:
+                loaded = self._load_web(track)
+                # If track not loaded, go next
+                if not loaded:
+                    self.set_next()
+                    GLib.timeout_add(500, self.__load,
+                                     self.next_track, init_volume)
+                return False  # Return not loaded as handled by load_web()
+            else:
+                self._playbin.set_property("uri", track.uri)
         except Exception as e:  # Gstreamer error
             print("BinPlayer::_load_track(): ", e)
             return False
         return True
 
+    def _load_web(self, track, play=True):
+        """
+            Load track url and play it
+            @param track as Track
+            @param play as bool
+            @return True if loading
+        """
+        if not get_network_available():
+            # Force widgets to update (spinners)
+            self.emit("current-changed")
+            return False
+        try:
+            from lollypop.web import Web
+            if play:
+                self.emit("loading-changed", True)
+            t = Thread(target=Web.play_track,
+                       args=(track, play, self.__set_gv_uri))
+            t.daemon = True
+            t.start()
+            return True
+        except Exception as e:
+            self._current_track = Track()
+            self.stop()
+            self.emit("current-changed")
+            if Lp().notify is not None:
+                Lp().notify.send(str(e), track.uri)
+            print("PlayerBin::_load_web()", e)
+
     def _scrobble(self, finished, finished_start_time):
         """
             Scrobble on lastfm
@@ -266,7 +305,7 @@ class BinPlayer(BasePlayer):
         if finished.duration < 30:
             return
         # Scrobble on lastfm
-        if Lp().lastfm is not None and Lp().lastfm.session_key:
+        if Lp().lastfm is not None:
             artists = ", ".join(finished.artists)
             played = time() - finished_start_time
             # We can scrobble if the track has been played
@@ -276,17 +315,6 @@ class BinPlayer(BasePlayer):
                                         finished.album_name,
                                         finished.title,
                                         int(finished_start_time))
-        # Scrobble on librefm
-        if Lp().librefm is not None and Lp().librefm.session_key:
-            artists = ", ".join(finished.artists)
-            played = time() - finished_start_time
-            # We can scrobble if the track has been played
-            # for at least half its duration, or for 4 minutes
-            if played >= finished.duration / 2 or played >= 240:
-                Lp().librefm.do_scrobble(artists,
-                                         finished.album_name,
-                                         finished.title,
-                                         int(finished_start_time))
 
     def _on_stream_start(self, bus, message):
         """
@@ -299,10 +327,7 @@ class BinPlayer(BasePlayer):
         debug("Player::_on_stream_start(): %s" % self._current_track.uri)
         self.emit("current-changed")
         # Update now playing on lastfm
-        # Not supported by librefm
-        if Lp().lastfm is not None and\
-                Lp().lastfm.session_key and\
-                self._current_track.id >= 0:
+        if Lp().lastfm is not None and self._current_track.id >= 0:
             artists = ", ".join(self._current_track.artists)
             Lp().lastfm.now_playing(artists,
                                     self._current_track.album_name,
@@ -315,122 +340,24 @@ class BinPlayer(BasePlayer):
         except:  # Locked database
             pass
 
-    def _on_bus_message_tag(self, bus, message):
-        """
-            Read tags from stream
-            @param bus as Gst.Bus
-            @param message as Gst.Message
-        """
-        # Some radio streams send message tag every seconds!
-        changed = False
-        if self._current_track.id >= 0 or self._current_track.duration > 0.0:
-            return
-        debug("Player::__on_bus_message_tag(): %s" % self._current_track.uri)
-        reader = TagReader()
-        tags = message.parse_tag()
-        title = reader.get_title(tags, "")
-        if title != "" and self._current_track.name != title:
-            self._current_track.name = title
-            changed = True
-        if self._current_track.name == "":
-            self._current_track.name = self._current_track.uri
-            changed = True
-        artists = reader.get_artists(tags)
-        if artists != "" and self._current_track.artists != artists:
-            self._current_track.artists = artists.split(",")
-            changed = True
-        if not self._current_track.artists:
-            self._current_track.artists = self._current_track.album_artists
-            changed = True
-
-        if self._current_track.id == Type.EXTERNALS:
-            (b, duration) = self._playbin.query_duration(Gst.Format.TIME)
-            if b:
-                self._current_track.duration = duration/1000000000
-            # We do not use tagreader as we need to check if value is None
-            self._current_track.album_name = tags.get_string_index("album",
-                                                                   0)[1]
-            if self._current_track.album_name is None:
-                self._current_track.album_name = ""
-            self._current_track.genres = reader.get_genres(tags).split(",")
-            changed = True
-        if changed:
-            self.emit("current-changed")
-
-    def _on_bus_element(self, bus, message):
-        """
-            Set elements for missings plugins
-            @param bus as Gst.Bus
-            @param message as Gst.Message
-        """
-        if GstPbutils.is_missing_plugin_message(message):
-            self.__codecs.append(message)
-
-    def _on_bus_error(self, bus, message):
-        """
-            Try a codec install and update current track
-            @param bus as Gst.Bus
-            @param message as Gst.Message
-        """
-        debug("Error playing: %s" % self._current_track.uri)
-        Lp().window.pulse(False)
-        if self.__codecs.is_missing_codec(message):
-            self.__codecs.install()
-            Lp().scanner.stop()
-        elif Lp().notify is not None:
-            Lp().notify.send(message.parse_error()[0].message)
-        self.stop()
-
-    def _on_bus_eos(self, bus, message):
-        """
-            On end of stream, stop playback
-            go next otherwise
-        """
-        debug("Player::__on_bus_eos(): %s" % self._current_track.uri)
-        if self._playbin.get_bus() == bus:
-            self.stop()
-            self._next_context = NextContext.NONE
-            if self._next_track.id is not None:
-                self._load_track(self._next_track)
-            self.emit("current-changed")
-
-    def _on_stream_about_to_finish(self, playbin):
-        """
-            When stream is about to finish, switch to next track without gap
-            @param playbin as Gst bin
-        """
-        debug("Player::__on_stream_about_to_finish(): %s" % playbin)
-        # Don"t do anything if crossfade on, track already changed
-        if self._crossfading:
-            return
-        if self._current_track.id == Type.RADIOS:
-            return
-        self._scrobble(self._current_track, self._start_time)
-        # Increment popularity
-        if not Lp().scanner.is_locked() and self._current_track.id >= 0:
-            Lp().tracks.set_more_popular(self._current_track.id)
-            # In party mode, linear popularity
-            if self.is_party:
-                pop_to_add = 1
-            # In normal mode, based on tracks count
-            else:
-                # Some users report an issue where get_tracks_count() return 0
-                # See issue #886
-                # Don"t understand how this can happen!
-                count = Lp().albums.get_tracks_count(
-                                                 self._current_track.album_id)
-                if count:
-                    pop_to_add = int(Lp().albums.max_count / count)
-                else:
-                    pop_to_add = 1
-            Lp().albums.set_more_popular(self._current_track.album_id,
-                                         pop_to_add)
-        if self._next_track.id is not None:
-            self._load_track(self._next_track)
-
 #######################
 # PRIVATE             #
 #######################
+    def __update_current_duration(self, reader, track):
+        """
+            Update current track duration
+            @param reader as TagReader
+            @param track id as int
+        """
+        try:
+            duration = reader.get_info(track.uri).get_duration() / 1000000000
+            if duration != track.duration and duration > 0:
+                Lp().tracks.set_duration(track.id, duration)
+                self._current_track.set_duration(duration)
+                GLib.idle_add(self.emit, "duration-changed", track.id)
+        except:
+            pass
+
     def __load(self, track, init_volume=True):
         """
             Stop current track, load track id and play it
@@ -581,6 +508,131 @@ class BinPlayer(BasePlayer):
             self.__playbin1.set_volume(GstAudio.StreamVolumeFormat.CUBIC, vol)
         self.emit("volume-changed")
 
+    def __on_bus_message_tag(self, bus, message):
+        """
+            Read tags from stream
+            @param bus as Gst.Bus
+            @param message as Gst.Message
+        """
+        # Some radio streams send message tag every seconds!
+        changed = False
+        if self._current_track.persistent == DbPersistent.INTERNAL and\
+            (self._current_track.id >= 0 or
+             self._current_track.duration > 0.0):
+            return
+        debug("Player::__on_bus_message_tag(): %s" % self._current_track.uri)
+        reader = TagReader()
+
+        # Update duration of non internals
+        if self._current_track.persistent != DbPersistent.INTERNAL:
+            t = Thread(target=self.__update_current_duration,
+                       args=(reader, self._current_track))
+            t.daemon = True
+            t.start()
+            return
+
+        tags = message.parse_tag()
+        title = reader.get_title(tags, "")
+        if title != "" and self._current_track.name != title:
+            self._current_track.name = title
+            changed = True
+        if self._current_track.name == "":
+            self._current_track.name = self._current_track.uri
+            changed = True
+        artists = reader.get_artists(tags)
+        if artists != "" and self._current_track.artists != artists:
+            self._current_track.artists = artists.split(",")
+            changed = True
+        if not self._current_track.artists:
+            self._current_track.artists = self._current_track.album_artists
+            changed = True
+
+        if self._current_track.id == Type.EXTERNALS:
+            (b, duration) = self._playbin.query_duration(Gst.Format.TIME)
+            if b:
+                self._current_track.duration = duration/1000000000
+            # We do not use tagreader as we need to check if value is None
+            self._current_track.album_name = tags.get_string_index("album",
+                                                                   0)[1]
+            if self._current_track.album_name is None:
+                self._current_track.album_name = ""
+            self._current_track.genres = reader.get_genres(tags).split(",")
+            changed = True
+        if changed:
+            self.emit("current-changed")
+
+    def __on_bus_element(self, bus, message):
+        """
+            Set elements for missings plugins
+            @param bus as Gst.Bus
+            @param message as Gst.Message
+        """
+        if GstPbutils.is_missing_plugin_message(message):
+            self.__codecs.append(message)
+
+    def __on_bus_error(self, bus, message):
+        """
+            Handle first bus error, ignore others
+            @param bus as Gst.Bus
+            @param message as Gst.Message
+        """
+        debug("Error playing: %s" % self._current_track.uri)
+        Lp().window.pulse(False)
+        if self.__codecs.is_missing_codec(message):
+            self.__codecs.install()
+            Lp().scanner.stop()
+        elif Lp().notify is not None:
+            Lp().notify.send(message.parse_error()[0].message)
+        self.emit("current-changed")
+        return True
+
+    def __on_bus_eos(self, bus, message):
+        """
+            On end of stream, stop playback
+            go next otherwise
+        """
+        debug("Player::__on_bus_eos(): %s" % self._current_track.uri)
+        if self._playbin.get_bus() == bus:
+            self.stop()
+            self._next_context = NextContext.NONE
+            if self._next_track.id is not None:
+                self._load_track(self._next_track)
+            self.emit("current-changed")
+
+    def __on_stream_about_to_finish(self, playbin):
+        """
+            When stream is about to finish, switch to next track without gap
+            @param playbin as Gst bin
+        """
+        debug("Player::__on_stream_about_to_finish(): %s" % playbin)
+        # Don"t do anything if crossfade on, track already changed
+        if self._crossfading:
+            return
+        if self._current_track.id == Type.RADIOS:
+            return
+        self._scrobble(self._current_track, self._start_time)
+        # Increment popularity
+        if not Lp().scanner.is_locked() and self._current_track.id >= 0:
+            Lp().tracks.set_more_popular(self._current_track.id)
+            # In party mode, linear popularity
+            if self.is_party:
+                pop_to_add = 1
+            # In normal mode, based on tracks count
+            else:
+                # Some users report an issue where get_tracks_count() return 0
+                # See issue #886
+                # Don"t understand how this can happen!
+                count = Lp().albums.get_tracks_count(
+                                                 self._current_track.album_id)
+                if count:
+                    pop_to_add = int(Lp().albums.max_count / count)
+                else:
+                    pop_to_add = 1
+            Lp().albums.set_more_popular(self._current_track.album_id,
+                                         pop_to_add)
+        if self._next_track.id is not None:
+            self._load_track(self._next_track)
+
     def __set_gv_uri(self, uri, track, play):
         """
             Play uri for io
diff --git a/lollypop/player_queue.py b/lollypop/player_queue.py
index ad04d8e5..561d59f6 100644
--- a/lollypop/player_queue.py
+++ b/lollypop/player_queue.py
@@ -10,7 +10,11 @@
 # You should have received a copy of the GNU General Public License
 # along with this program. If not, see <http://www.gnu.org/licenses/>.
 
+from gettext import gettext as _
+
 from lollypop.objects import Track
+from lollypop.define import Lp
+from lollypop.utils import get_network_available
 
 
 class QueuePlayer:
@@ -32,6 +36,14 @@ class QueuePlayer:
             @param track id as int
             @param notify as bool
         """
+        track = Track(track_id)
+        if track.is_web and\
+           not get_network_available():
+            if Lp().notify is not None:
+                Lp().notify.send(_("No network available,"
+                                   " can't play this track"),
+                                 track.uri)
+            return
         if track_id in self.__queue:
             self.__queue.remove(track_id)
         self.__queue.append(track_id)
@@ -49,6 +61,14 @@ class QueuePlayer:
             @param track id as int
             @param notify as bool
         """
+        track = Track(track_id)
+        if track.is_web and\
+           not get_network_available():
+            if Lp().notify is not None:
+                Lp().notify.send(_("No network available,"
+                                   " can't play this track"),
+                                 track.uri)
+            return
         if track_id in self.__queue:
             self.__queue.remove(track_id)
         self.__queue.insert(pos, track_id)
diff --git a/lollypop/player_radio.py b/lollypop/player_radio.py
index 517163b6..8dc75135 100644
--- a/lollypop/player_radio.py
+++ b/lollypop/player_radio.py
@@ -10,11 +10,11 @@
 # You should have received a copy of the GNU General Public License
 # along with this program. If not, see <http://www.gnu.org/licenses/>.
 
-from gi.repository import TotemPlParser, Gst, Gio, GLib
+from gi.repository import TotemPlParser, Gst, Gio
 
 from lollypop.radios import Radios
 from lollypop.player_base import BasePlayer
-from lollypop.define import Type, Lp
+from lollypop.define import Type
 from lollypop.objects import Track
 
 
@@ -42,8 +42,6 @@ class RadioPlayer(BasePlayer):
         """
         if Gio.NetworkMonitor.get_default().get_network_available():
             try:
-                if not Lp().scanner.is_locked():
-                    Lp().window.pulse(True)
                 self.__current = track
                 parser = TotemPlParser.Parser.new()
                 parser.connect("entry-parsed", self.__on_entry_parsed, track)
@@ -113,32 +111,9 @@ class RadioPlayer(BasePlayer):
         """
         self.__radios = radios
 
-#######################
-# PROTECTED           #
-#######################
-    def _on_bus_error(self, bus, message):
-        """
-            Try a codec install and update current track
-            @param bus as Gst.Bus
-            @param message as Gst.Message
-        """
-        # Reload track if network is down
-        if self._current_track.id < 0 and\
-                not Gio.NetworkMonitor.get_default().get_network_available():
-            GLib.timeout_add(1000, self.__check_for_network)
-
 #######################
 # PRIVATE             #
 #######################
-    def __check_for_network(self):
-        """
-            Play track again once network is up
-        """
-        if Gio.NetworkMonitor.get_default().get_network_available():
-            self.load(self._current_track)
-        else:
-            return True
-
     def __start_playback(self, track):
         """
             Start playing track
@@ -167,7 +142,6 @@ class RadioPlayer(BasePlayer):
         # Only start playing if context always True
         if self.__current == track:
             self.__start_playback(track)
-            Lp().window.pulse(False)
 
     def __on_entry_parsed(self, parser, uri, metadata, track):
         """
diff --git a/lollypop/player_shuffle.py b/lollypop/player_shuffle.py
index bfe78d0c..e00e3cc9 100644
--- a/lollypop/player_shuffle.py
+++ b/lollypop/player_shuffle.py
@@ -11,8 +11,8 @@
 # along with this program. If not, see <http://www.gnu.org/licenses/>.
 
 import random
+from threading import Thread
 
-from lollypop.helper_task import TaskHelper
 from lollypop.define import Shuffle, NextContext, Lp, Type
 from lollypop.player_base import BasePlayer
 from lollypop.objects import Track, Album
@@ -48,8 +48,9 @@ class ShufflePlayer(BasePlayer):
         # Tracks already played for albums
         self.__already_played_tracks = {}
         # If we have tracks/albums to ignore in party mode, add them
-        helper = TaskHelper()
-        helper.run(self.__init_party_blacklist)
+        t = Thread(target=self.__init_party_blacklist)
+        t.daemon = True
+        t.start()
         # Reset user playlist
         self._user_playlist = []
         self._user_playlist_ids = []
@@ -60,7 +61,7 @@ class ShufflePlayer(BasePlayer):
             True if history provide a next track
             @return bool
         """
-        return self.__history and self.__history.has_next
+        return self.__history and self.__history.has_next()
 
     @property
     def shuffle_has_prev(self):
@@ -68,7 +69,7 @@ class ShufflePlayer(BasePlayer):
             True if history provide a prev track
             @return bool
         """
-        return self.__history and self.__history.has_prev
+        return self.__history and self.__history.has_prev()
 
     def next(self):
         """
@@ -78,7 +79,7 @@ class ShufflePlayer(BasePlayer):
         track_id = None
         if self._shuffle == Shuffle.TRACKS or self.__is_party:
             if self.shuffle_has_next:
-                track_id = self.__history.next.value
+                track_id = self.__history.get_next().get_value()
             elif self._albums:
                 track_id = self.__shuffle_next()
             else:
@@ -93,7 +94,7 @@ class ShufflePlayer(BasePlayer):
         track_id = None
         if self._shuffle == Shuffle.TRACKS or self.__is_party:
             if self.shuffle_has_prev:
-                track_id = self.__history.prev.value
+                track_id = self.__history.get_prev().get_value()
             else:
                 track_id = self._current_track.id
         return Track(track_id)
@@ -208,22 +209,22 @@ class ShufflePlayer(BasePlayer):
         # Add track to shuffle history if needed
         if self._shuffle == Shuffle.TRACKS or self.__is_party:
             if self.__history:
-                next = self.__history.next
-                prev = self.__history.prev
+                next = self.__history.get_next()
+                prev = self.__history.get_prev()
                 # Next track
                 if next is not None and\
-                        self._current_track.id == next.value:
-                    next = self.__history.next
+                        self._current_track.id == next.get_value():
+                    next = self.__history.get_next()
                     next.set_prev(self.__history)
                     self.__history = next
                 # Previous track
                 elif prev is not None and\
-                        self._current_track.id == prev.value:
-                    prev = self.__history.prev
+                        self._current_track.id == prev.get_value():
+                    prev = self.__history.get_prev()
                     prev.set_next(self.__history)
                     self.__history = prev
                 # New track
-                elif self.__history.value != self._current_track.id:
+                elif self.__history.get_value() != self._current_track.id:
                     new_list = LinkedList(self._current_track.id,
                                           None,
                                           self.__history)
diff --git a/lollypop/playlists.py b/lollypop/playlists.py
index e3127045..560dfe72 100644
--- a/lollypop/playlists.py
+++ b/lollypop/playlists.py
@@ -22,6 +22,7 @@ from lollypop.define import Lp, Type
 from lollypop.objects import Track
 from lollypop.sqlcursor import SqlCursor
 from lollypop.localized import LocalizedCollation
+from lollypop.lio import Lio
 
 
 class Playlists(GObject.GObject):
@@ -256,6 +257,10 @@ class Playlists(GObject.GObject):
         """
         if playlist_id == Type.LOVED:
             return self.LOVED
+        elif playlist_id == Type.SPOTIFY:
+            return _("Spotify charts")
+        elif playlist_id == Type.LASTFM:
+            return _("Last.fm charts")
 
         with SqlCursor(self) as sql:
             result = sql.execute("SELECT name\
@@ -351,7 +356,7 @@ class Playlists(GObject.GObject):
         """
         try:
             uri = uri.strip("\n\r")
-            f = Gio.File.new_for_uri(uri)
+            f = Lio.File.new_for_uri(uri)
             if f.query_exists():
                 if f.query_file_type(Gio.FileQueryInfoFlags.NONE,
                                      None) == Gio.FileType.DIRECTORY:
@@ -360,7 +365,7 @@ class Playlists(GObject.GObject):
                     while walk_uris:
                         uri = walk_uris.pop(0)
                         try:
-                            d = Gio.File.new_for_uri(uri)
+                            d = Lio.File.new_for_uri(uri)
                             infos = d.enumerate_children(
                                 "standard::name,standard::type",
                                 Gio.FileQueryInfoFlags.NONE,
diff --git a/lollypop/pop_albums.py b/lollypop/pop_albums.py
index 9df39611..288a3944 100644
--- a/lollypop/pop_albums.py
+++ b/lollypop/pop_albums.py
@@ -94,6 +94,7 @@ class AlbumRow(Gtk.ListBoxRow):
                                         self.get_scale_factor())
         cover.set_from_surface(surface)
         cover.set_size_request(ArtSize.MEDIUM, ArtSize.MEDIUM)
+        del surface
         self.__play_indicator = Gtk.Image.new_from_icon_name(
                                                "media-playback-start-symbolic",
                                                Gtk.IconSize.MENU)
diff --git a/lollypop/pop_info.py b/lollypop/pop_info.py
index 7ac232de..503b7648 100644
--- a/lollypop/pop_info.py
+++ b/lollypop/pop_info.py
@@ -13,8 +13,8 @@
 from gi.repository import Gtk, GLib
 
 from gettext import gettext as _
+from threading import Thread
 
-from lollypop.helper_task import TaskHelper
 from lollypop.define import Lp, OpenLink, Type
 from lollypop.objects import Track
 from lollypop.utils import get_network_available
@@ -25,7 +25,7 @@ from lollypop.view_artist_albums import CurrentArtistAlbumsView
 
 class InfoPopover(Gtk.Popover):
     """
-        Popover with artist information
+        Popover with artist informations
         @Warning: Auto destroy on hide if artist id is not None
     """
 
@@ -33,7 +33,7 @@ class InfoPopover(Gtk.Popover):
         from lollypop.wikipedia import Wikipedia
     except Exception as e:
         print(e)
-        print(_("Advanced artist information disabled"))
+        print(_("Advanced artist informations disabled"))
         print("$ sudo pip3 install wikipedia")
         Wikipedia = None
 
@@ -164,8 +164,9 @@ class InfoPopover(Gtk.Popover):
             view.set_property("expand", True)
             view.show()
             widget.add(view)
-        helper = TaskHelper()
-        helper.run(view.populate, self.__current_track)
+        t = Thread(target=view.populate, args=(self.__current_track,))
+        t.daemon = True
+        t.start()
 
     def _on_map_lastfm(self, widget):
         """
@@ -194,7 +195,9 @@ class InfoPopover(Gtk.Popover):
             content = LastfmContent()
             content.show()
             widget.add(content)
-            content.populate(artist)
+            t = Thread(target=content.populate, args=(artist, ))
+            t.daemon = True
+            t.start()
 
     def _on_map_wikipedia(self, widget):
         """
@@ -223,7 +226,10 @@ class InfoPopover(Gtk.Popover):
             content = WikipediaContent()
             content.show()
             widget.add(content)
-            content.populate(artist, self.__current_track.album.name)
+            t = Thread(target=content.populate,
+                       args=(artist, self.__current_track.album.name))
+            t.daemon = True
+            t.start()
 
     def _on_map_lyrics(self, widget):
         """
diff --git a/lollypop/pop_lastfm.py b/lollypop/pop_lastfm.py
index f6fade39..48cb054a 100644
--- a/lollypop/pop_lastfm.py
+++ b/lollypop/pop_lastfm.py
@@ -12,6 +12,8 @@
 
 from gi.repository import Gtk, GLib, Pango
 
+from threading import Thread
+
 from lollypop.define import Lp
 from lollypop.utils import get_network_available
 
@@ -51,7 +53,9 @@ class LastfmPopover(Gtk.Popover):
             artists = []
             for artist_id in artist_ids:
                 artists.append(Lp().artists.get_name(artist_id))
-            GLib.idle_add(self.__populate, artists)
+            t = Thread(target=self.__populate, args=(artists,))
+            t.daemon = True
+            t.start()
 
 #######################
 # PRIVATE             #
diff --git a/lollypop/pop_menu.py b/lollypop/pop_menu.py
index 7cad923f..4095e893 100644
--- a/lollypop/pop_menu.py
+++ b/lollypop/pop_menu.py
@@ -13,14 +13,16 @@
 from gi.repository import Gio, GLib, Gtk
 
 from gettext import gettext as _
+from threading import Thread
+from time import time
 
 from lollypop.widgets_rating import RatingWidget
 from lollypop.widgets_loved import LovedWidget
 from lollypop.define import Lp, Type
+from lollypop.sqlcursor import SqlCursor
 from lollypop.objects import Track, Album
 from lollypop.utils import set_loved
 from lollypop.helper_dbus import DBusHelper
-from lollypop.helper_task import TaskHelper
 
 
 class BaseMenu(Gio.Menu):
@@ -290,8 +292,9 @@ class PlaylistsMenu(BaseMenu):
             if playlist_id in Lp().player.get_user_playlist_ids():
                 Lp().player.update_user_playlist(
                                      Lp().playlists.get_track_ids(playlist_id))
-        helper = TaskHelper()
-        helper.run(add, playlist_id)
+        t = Thread(target=add, args=(playlist_id,))
+        t.daemon = True
+        t.start()
 
     def __remove_from_playlist(self, action, variant, playlist_id):
         """
@@ -316,8 +319,9 @@ class PlaylistsMenu(BaseMenu):
             if playlist_id in Lp().player.get_user_playlist_ids():
                 Lp().player.update_user_playlist(
                                      Lp().playlists.get_track_ids(playlist_id))
-        helper = TaskHelper()
-        helper.run(remove, playlist_id)
+        t = Thread(target=remove, args=(playlist_id,))
+        t.daemon = True
+        t.start()
 
     def __add_to_loved(self, action, variant):
         """
@@ -355,13 +359,28 @@ class EditMenu(BaseMenu):
             obj = Track(object.id)
         BaseMenu.__init__(self, obj)
 
-        dbus_helper = DBusHelper()
-        dbus_helper.call("CanLaunchTagEditor", None,
-                         self.__on_can_launch_tag_editor, None)
+        if self._object.is_web:
+            self.__set_remove_action()
+        else:
+            dbus_helper = DBusHelper()
+            dbus_helper.call("CanLaunchTagEditor", None,
+                             self.__on_can_launch_tag_editor, None)
 
 #######################
 # PRIVATE             #
 #######################
+    def __set_remove_action(self):
+        """
+            Remove album
+        """
+        remove_action = Gio.SimpleAction(name="remove_action")
+        Lp().add_action(remove_action)
+        remove_action.connect("activate", self.__remove_object)
+        if isinstance(self._object, Album):
+            self.append(_("Remove album"), "app.remove_action")
+        else:
+            self.append(_("Remove track"), "app.remove_action")
+
     def __set_edit_actions(self):
         """
             Set edit actions
@@ -477,6 +496,27 @@ class TrackMenuPopover(Gtk.Popover):
             year.set_property("hexpand", True)
             year.show()
 
+        if track.album.is_web:
+            uri = Lp().tracks.get_uri(track.id)
+            web = Gtk.LinkButton(uri)
+            icon = Gtk.Image.new_from_icon_name("web-browser-symbolic",
+                                                Gtk.IconSize.MENU)
+            web.set_image(icon)
+            web.get_style_context().add_class("no-padding")
+            web.set_margin_end(5)
+            web.set_tooltip_text(uri)
+            web.show_all()
+            uri = "https://www.youtube.com/results?search_query=%s" %\
+                (track.artists[0] + " " + track.name,)
+            search = Gtk.LinkButton(uri)
+            icon = Gtk.Image.new_from_icon_name("edit-find-symbolic",
+                                                Gtk.IconSize.MENU)
+            search.set_image(icon)
+            search.get_style_context().add_class("no-padding")
+            search.set_margin_end(5)
+            search.set_tooltip_text(uri)
+            search.show_all()
+
         # Hack to add two widgets in popover
         # Use a Gtk.PopoverMenu later (GTK>3.16 available on Debian stable)
         grid = Gtk.Grid()
@@ -492,31 +532,53 @@ class TrackMenuPopover(Gtk.Popover):
             grid.add(menu_widget)
 
         hgrid = Gtk.Grid()
-        rating = RatingWidget(track)
-        rating.set_margin_top(5)
-        rating.set_margin_bottom(5)
-        rating.set_property("halign", Gtk.Align.START)
-        rating.set_property("hexpand", True)
-        rating.show()
-
-        loved = LovedWidget(track)
-        loved.set_margin_end(5)
-        loved.set_margin_top(5)
-        loved.set_margin_bottom(5)
-        if track_year == "":
-            loved.set_property("halign", Gtk.Align.END)
-        else:
-            loved.set_property("halign", Gtk.Align.CENTER)
-        loved.set_property("hexpand", True)
-        loved.show()
-
-        hgrid.add(rating)
-        hgrid.add(loved)
-
-        if track_year != "":
-            hgrid.add(year)
-        hgrid.show()
-
+        if Type.CHARTS not in track.genre_ids:
+            if not track.album.is_web:
+                separator = Gtk.Separator()
+                separator.show()
+                grid.add(separator)
+
+            rating = RatingWidget(track)
+            rating.set_margin_top(5)
+            rating.set_margin_bottom(5)
+            rating.set_property("halign", Gtk.Align.START)
+            rating.set_property("hexpand", True)
+            rating.show()
+
+            loved = LovedWidget(track)
+            loved.set_margin_end(5)
+            loved.set_margin_top(5)
+            loved.set_margin_bottom(5)
+            if track_year == "":
+                loved.set_property("halign", Gtk.Align.END)
+            else:
+                loved.set_property("halign", Gtk.Align.CENTER)
+            loved.set_property("hexpand", True)
+            loved.show()
+
+            hgrid.add(rating)
+            hgrid.add(loved)
+
+            if track.album.is_web:
+                hgrid.add(web)
+                hgrid.add(search)
+            if track_year != "":
+                hgrid.add(year)
+            hgrid.show()
+
+        if track.album.is_web:
+            grid.set_row_spacing(2)
+            uri = Lp().tracks.get_uri(track.id)
+            edit = Gtk.Entry()
+            edit.set_margin_start(5)
+            edit.set_margin_end(5)
+            edit.set_margin_bottom(5)
+            edit.set_tooltip_text(_("Video address"))
+            edit.set_property("hexpand", True)
+            edit.set_text(uri)
+            edit.connect("changed", self.__on_edit_changed, track.id)
+            edit.show()
+            grid.add(edit)
         grid.add(hgrid)
         self.add(stack)
 
@@ -530,3 +592,104 @@ class TrackMenuPopover(Gtk.Popover):
             @param track id as int
         """
         Lp().tracks.set_uri(track_id, edit.get_text())
+
+
+class AlbumMenuPopover(Gtk.Popover):
+    """
+        Contextual menu widget for a track
+    """
+
+    def __init__(self, album, menu):
+        """
+            Init widget
+            @param album as album
+            @param menu as Gio.Menu
+        """
+        Gtk.Popover.__init__(self)
+        if menu is not None:
+            self.bind_model(menu, None)
+
+        edit = Gtk.Entry()
+        edit.set_margin_start(5)
+        edit.set_margin_end(5)
+        edit.set_margin_bottom(5)
+        edit.set_property("hexpand", True)
+        edit.set_property("halign", Gtk.Align.CENTER)
+        genres = ";".join(Lp().albums.get_genres(album.id))
+        if not genres:
+            genres = "Web"
+        edit.set_text(genres)
+        edit.show()
+
+        save = Gtk.Button.new_from_icon_name("document-save-symbolic",
+                                             Gtk.IconSize.MENU)
+        save.set_margin_end(5)
+        save.set_margin_bottom(5)
+        save.set_property("hexpand", True)
+        save.set_property("halign", Gtk.Align.CENTER)
+        save.set_property("valign", Gtk.Align.CENTER)
+        save.set_tooltip_text(_("Save genre"))
+        save.connect("clicked", self.__on_clicked, edit, album)
+        save.show()
+
+        # Hack to add two widgets in popover
+        # Use a Gtk.PopoverMenu later (GTK>3.16 available on Debian stable)
+        grid = Gtk.Grid()
+        grid.set_orientation(Gtk.Orientation.VERTICAL)
+
+        stack = Gtk.Stack()
+        stack.add_named(grid, "main")
+        stack.show_all()
+
+        menu_widget = self.get_child()
+        if menu_widget is not None:
+            self.remove(menu_widget)
+            grid.add(menu_widget)
+        # separator = Gtk.Separator()
+        # separator.show()
+
+        if menu is None:
+            label = Gtk.Label.new(_("Save into collection"))
+            label.show()
+            grid.add(label)
+        # grid.add(separator)
+        hgrid = Gtk.Grid()
+        hgrid.add(edit)
+        hgrid.add(save)
+        hgrid.show()
+        grid.add(hgrid)
+        self.add(stack)
+
+#######################
+# PRIVATE             #
+#######################
+    def __on_clicked(self, button, edit, album):
+        """
+            Save album genre
+            @param button as Gtk.Button
+            @param edit as Gtk.Edit
+            @param album as Album
+        """
+        genres = edit.get_text()
+        if not genres:
+            return
+        orig_genre_ids = Lp().albums.get_genre_ids(album.id)
+        Lp().albums.del_genres(album.id)
+        for track_id in album.track_ids:
+                Lp().tracks.del_genres(track_id)
+        for genre in genres.split(";"):
+            genre_id = Lp().genres.get_id(genre)
+            if genre_id is None:
+                genre_id = Lp().genres.add(genre)
+                Lp().scanner.emit("genre-updated", genre_id, True)
+            Lp().albums.add_genre(album.id, genre_id, int(time()))
+            for track_id in album.track_ids:
+                Lp().tracks.add_genre(track_id, genre_id, int(time()))
+        for genre_id in orig_genre_ids:
+            if genre_id >= 0:
+                Lp().genres.clean(genre_id)
+                GLib.idle_add(Lp().scanner.emit, "genre-updated",
+                              genre_id, False)
+        with SqlCursor(Lp().db) as sql:
+            sql.commit()
+        Lp().scanner.emit("album-updated", album.id, True)
diff --git a/lollypop/pop_queue.py b/lollypop/pop_queue.py
index 765b42d1..18ed8ba0 100644
--- a/lollypop/pop_queue.py
+++ b/lollypop/pop_queue.py
@@ -148,6 +148,7 @@ class QueueRow(Gtk.ListBoxRow):
         else:
             self.__cover.set_from_surface(surface)
             self.__cover.show()
+            del surface
 
 #######################
 # PRIVATE             #
diff --git a/lollypop/pop_radio.py b/lollypop/pop_radio.py
index 48c4dd10..b6dd5368 100644
--- a/lollypop/pop_radio.py
+++ b/lollypop/pop_radio.py
@@ -12,13 +12,15 @@
 
 from gi.repository import Gtk, Gdk, GLib, Gio, GdkPixbuf
 
+from threading import Thread
+
 from gettext import gettext as _
 
 from lollypop.objects import Track
 from lollypop.widgets_rating import RatingWidget
 from lollypop.define import Lp, ArtSize
-from lollypop.helper_task import TaskHelper
 from lollypop.art import Art
+from lollypop.lio import Lio
 
 
 # Show a popover with radio logos from the web
@@ -41,7 +43,6 @@ class RadioPopover(Gtk.Popover):
         self.__radios_manager = radios_manager
         self.__start = 0
         self.__orig_pixbufs = {}
-        self.__cancellable = Gio.Cancellable()
 
         self.__stack = Gtk.Stack()
         self.__stack.set_transition_duration(1000)
@@ -93,112 +94,58 @@ class RadioPopover(Gtk.Popover):
 #######################
 # PROTECTED           #
 #######################
-    def _on_btn_add_modify_clicked(self, widget):
-        """
-            Add/Modify a radio
-            @param widget as Gtk.Widget
-        """
-        uri = self.__uri_entry.get_text()
-        new_name = self.__name_entry.get_text()
-        rename = self.__name != "" and self.__name != new_name
-
-        if uri != "" and new_name != "":
-            self.__stack.get_visible_child().hide()
-            if rename:
-                self.__radios_manager.rename(self.__name, new_name)
-                Lp().art.rename_radio(self.__name, new_name)
-            else:
-                self.__radios_manager.add(new_name, uri.lstrip().rstrip())
-            self.__stack.set_visible_child_name("spinner")
-            self.__name = new_name
-            uri = Lp().art.get_google_search_uri(self.__name + "+logo+radio")
-            helper = TaskHelper()
-            helper.load_uri_content(uri,
-                                    self.__cancellable,
-                                    self.__on_google_content_loaded)
-            self.set_size_request(700, 400)
-
-    def _on_btn_delete_clicked(self, widget):
+    def __populate_threaded(self):
         """
-            Delete a radio
-            @param widget as Gtk.Widget
+            Populate view
         """
-        self.hide()
-        if self.__name != "":
-            store = Art._RADIOS_PATH
-            self.__radios_manager.delete(self.__name)
-            Lp().art.clean_radio_cache(self.__name)
-            f = Gio.File.new_for_path(store + "/%s.png" % self.__name)
-            if f.query_exists():
-                f.delete()
+        self._thread = True
+        t = Thread(target=self.__populate)
+        t.daemon = True
+        t.start()
 
-    def _on_entry_changed(self, entry):
+    def __populate(self):
         """
-            Update modify/add button
-            @param entry as Gtk.Entry
+            Same as __populate_threaded()
+            @thread safe
         """
-        uri = self.__uri_entry.get_text()
-        name = self.__name_entry.get_text()
-        if name != "" and uri.find("://") != -1:
-            self.__btn_add_modify.set_sensitive(True)
+        self._urls = Lp().art.get_google_arts(self.__name+"+logo+radio")
+        if self._urls:
+            self.__add_pixbufs()
         else:
-            self.__btn_add_modify.set_sensitive(False)
+            GLib.idle_add(self.__show_not_found)
 
-    def _on_button_clicked(self, button):
+    def __add_pixbufs(self):
         """
-            Show file chooser
-            @param button as Gtk.button
+            Add urls to the view
         """
-        dialog = Gtk.FileChooserDialog()
-        dialog.add_buttons(Gtk.STOCK_CANCEL, Gtk.ResponseType.CANCEL)
-        dialog.add_buttons(Gtk.STOCK_OPEN, Gtk.ResponseType.OK)
-        dialog.set_transient_for(Lp().window)
-        self.hide()
-        response = dialog.run()
-        if response == Gtk.ResponseType.OK:
+        if self._urls:
+            url = self._urls.pop()
+            stream = None
             try:
-                pixbuf = GdkPixbuf.Pixbuf.new_from_file(dialog.get_filename())
-                Lp().art.save_radio_artwork(pixbuf, self.__name)
-                Lp().art.clean_radio_cache(self.__name)
-                Lp().art.radio_artwork_update(self.__name)
-                self._streams = {}
-            except Exception as e:
-                print("RadioPopover::_on_button_clicked():", e)
-        dialog.destroy()
+                f = Lio.File.new_for_uri(url)
+                (status, data, tag) = f.load_contents()
+                if status:
+                    stream = Gio.MemoryInputStream.new_from_data(data, None)
+            except:
+                if self._thread:
+                    self.__add_pixbufs()
+            if stream:
+                GLib.idle_add(self.__add_pixbuf, stream)
+            if self._thread:
+                self.__add_pixbufs()
 
-#######################
-# PRIVATE             #
-#######################
-    def __populate(self, uris):
+    def __show_not_found(self):
         """
-            Add uris to view
-            @param uris as [str]
+            Show not found message if view empty
         """
-        if uris:
-            uri = uris.pop(0)
-            helper = TaskHelper()
-            helper.load_uri_content(uri,
-                                    self.__cancellable,
-                                    self.__add_pixbuf,
-                                    self.__populate,
-                                    uris)
-        elif len(self.__view.get_children()) == 0:
+        if len(self.__view.get_children()) == 0:
             self.__stack.set_visible_child_name("notfound")
 
-    def __add_pixbuf(self, uri, loaded, content, callback, *args):
+    def __add_pixbuf(self, stream):
         """
-            Add uri to the view and load callback
-            @param uri as str
-            @param loaded as bool
-            @param content as bytes
-            @param callback as function
+            Add stream to the view
         """
-        if self.__cancellable.is_cancelled():
-            return
-        if loaded:
-            bytes = GLib.Bytes(content)
-            stream = Gio.MemoryInputStream.new_from_bytes(bytes)
-            bytes.unref()
+        try:
             pixbuf = GdkPixbuf.Pixbuf.new_from_stream_at_scale(
                 stream, ArtSize.MONSTER,
                 ArtSize.MONSTER,
@@ -222,18 +169,22 @@ class RadioPopover(Gtk.Popover):
             scaled_pixbuf = pixbuf.scale_simple(width,
                                                 height,
                                                 GdkPixbuf.InterpType.BILINEAR)
+            del pixbuf
             surface = Gdk.cairo_surface_create_from_pixbuf(
                                                        scaled_pixbuf,
                                                        self.get_scale_factor(),
                                                        None)
+            del scaled_pixbuf
             image.set_from_surface(surface)
+            del surface
             image.show()
             self.__view.add(image)
-        # Switch on first image
+        except Exception as e:
+            print(e)
+            pass
         if self.__stack.get_visible_child_name() == "spinner":
             self.__spinner.stop()
             self.__stack.set_visible_child_name("logo")
-        callback(*args)
 
     def __on_map(self, widget):
         """
@@ -254,23 +205,83 @@ class RadioPopover(Gtk.Popover):
         Lp().window.enable_global_shortcuts(True)
         GLib.idle_add(self.destroy)
 
-    def __on_google_content_loaded(self, uri, loaded, content):
+    def _on_btn_add_modify_clicked(self, widget):
         """
-            Extract content
-            @param uri as str
-            @param loaded as bool
-            @param content as bytes
+            Add/Modify a radio
+            @param widget as Gtk.Widget
         """
-        if loaded:
-            uris = Lp().art.get_google_artwork(content)
-            self.__populate(uris)
+        uri = self.__uri_entry.get_text()
+        new_name = self.__name_entry.get_text()
+        rename = self.__name != "" and self.__name != new_name
+
+        if uri != "" and new_name != "":
+            self.__stack.get_visible_child().hide()
+            if rename:
+                self.__radios_manager.rename(self.__name, new_name)
+                Lp().art.rename_radio(self.__name, new_name)
+            else:
+                self.__radios_manager.add(new_name, uri.lstrip().rstrip())
+            self.__stack.set_visible_child_name("spinner")
+            self.__name = new_name
+            self.__populate_threaded()
+            self.set_size_request(700, 400)
+
+    def _on_btn_delete_clicked(self, widget):
+        """
+            Delete a radio
+            @param widget as Gtk.Widget
+        """
+        self.hide()
+        if self.__name != "":
+            store = Art._RADIOS_PATH
+            self.__radios_manager.delete(self.__name)
+            Lp().art.clean_radio_cache(self.__name)
+            f = Lio.File.new_for_path(store + "/%s.png" % self.__name)
+            if f.query_exists():
+                f.delete()
 
+    def _on_entry_changed(self, entry):
+        """
+            Update modify/add button
+            @param entry as Gtk.Entry
+        """
+        uri = self.__uri_entry.get_text()
+        name = self.__name_entry.get_text()
+        if name != "" and uri.find("://") != -1:
+            self.__btn_add_modify.set_sensitive(True)
+        else:
+            self.__btn_add_modify.set_sensitive(False)
+
+    def _on_button_clicked(self, button):
+        """
+            Show file chooser
+            @param button as Gtk.button
+        """
+        dialog = Gtk.FileChooserDialog()
+        dialog.add_buttons(Gtk.STOCK_CANCEL, Gtk.ResponseType.CANCEL)
+        dialog.add_buttons(Gtk.STOCK_OPEN, Gtk.ResponseType.OK)
+        dialog.set_transient_for(Lp().window)
+        self.hide()
+        response = dialog.run()
+        if response == Gtk.ResponseType.OK:
+            try:
+                pixbuf = GdkPixbuf.Pixbuf.new_from_file(dialog.get_filename())
+                Lp().art.save_radio_artwork(pixbuf, self.__name)
+                Lp().art.clean_radio_cache(self.__name)
+                Lp().art.radio_artwork_update(self.__name)
+                self._streams = {}
+            except Exception as e:
+                print("RadioPopover::_on_button_clicked():", e)
+        dialog.destroy()
+
+#######################
+# PRIVATE             #
+#######################
     def __on_activate(self, flowbox, child):
         """
             Use pixbuf as cover
             Reset cache and use player object to announce cover change
         """
-        self.__cancellable.cancel()
         pixbuf = self.__orig_pixbufs[child.get_child()]
         Lp().art.save_radio_artwork(pixbuf, self.__name)
         Lp().art.clean_radio_cache(self.__name)
diff --git a/lollypop/pop_search.py b/lollypop/pop_search.py
index e160cdc4..0a68d45a 100644
--- a/lollypop/pop_search.py
+++ b/lollypop/pop_search.py
@@ -10,15 +10,17 @@
 # You should have received a copy of the GNU General Public License
 # along with this program. If not, see <http://www.gnu.org/licenses/>.
 
-from gi.repository import Gtk, GLib, Gio, Gdk
+from gi.repository import Gtk, GLib, Gio, Gdk, GdkPixbuf
 
-from lollypop.define import Lp, ArtSize, Type
+from gettext import gettext as _
+from threading import Thread
+
+from lollypop.define import Lp, ArtSize, Type, DbPersistent
 from lollypop.objects import Track, Album
 from lollypop.pop_menu import TrackMenuPopover, TrackMenu
 from lollypop.view_albums import AlbumBackView
-from lollypop.utils import noaccents
-from lollypop.helper_task import TaskHelper
-from lollypop.search import Search
+from lollypop.utils import noaccents, get_network_available
+from lollypop.lio import Lio
 
 
 class SearchRow(Gtk.ListBoxRow):
@@ -34,10 +36,18 @@ class SearchRow(Gtk.ListBoxRow):
         """
         Gtk.ListBoxRow.__init__(self)
         self.__item = item
+        self.__uri_set = False
         self.__score = None
         builder = Gtk.Builder()
-        builder.add_from_resource("/org/gnome/Lollypop/InternalSearchRow.ui")
-        self.__stack = builder.get_object("stack")
+        if internal:
+            builder.add_from_resource(
+                                    "/org/gnome/Lollypop/InternalSearchRow.ui")
+            self.__progress = None
+        else:
+            builder.add_from_resource(
+                                    "/org/gnome/Lollypop/ExternalSearchRow.ui")
+            self.__progress = builder.get_object("progress")
+            self.__stack = builder.get_object("stack")
         builder.connect_signals(self)
         self.set_property("has-tooltip", True)
         self.connect("query-tooltip", self.__on_query_tooltip)
@@ -138,11 +148,47 @@ class SearchRow(Gtk.ListBoxRow):
         surface = Gdk.cairo_surface_create_from_pixbuf(pixbuf,
                                                        self.get_scale_factor(),
                                                        None)
+        del pixbuf
         self.__cover.set_from_surface(surface)
+        del surface
+
+    @property
+    def is_loading(self):
+        """
+            True if is loading a track/album
+            @return bool
+        """
+        return self.__progress is not None and\
+            self.__progress.get_opacity() == 1
+
+    def on_activated(self, persistent):
+        """
+            Download item
+            @param persistent as DbPersistent
+        """
+        from lollypop.web import Web
+        web = Web()
+        web.connect("saved", self.__on_saved, persistent)
+        if self.__item.is_track:
+            web.save_track(self.__item, persistent)
+        else:
+            web.save_album(self.__item, persistent)
+            if self.__progress is not None:
+                self.__progress.set_opacity(1)
+            web.connect("progress", self.__on_progress)
+        self.__stack.set_visible_child_name("spinner")
+        self.__stack.get_visible_child().start()
 
 #######################
 # PROTECTED           #
 #######################
+    def _on_save_clicked(self, button):
+        """
+            Save into collection
+            @param button as Gtk.Button
+        """
+        self.on_activated(DbPersistent.EXTERNAL)
+
     def _on_playlist_clicked(self, button):
         """
             Prepend track to queue
@@ -199,8 +245,39 @@ class SearchRow(Gtk.ListBoxRow):
                                                  ArtSize.MEDIUM,
                                                  self.get_scale_factor())
         self.__cover.set_from_surface(surface)
+        del surface
         self.__artist.set_text(", ".join(artists))
 
+    def __on_saved(self, web, item_id, persistent):
+        """
+            Play track
+            @param web as Web
+            @param item id as int
+            @parma activated as DbPersistent
+        """
+        if self.__progress is not None:
+            self.__progress.set_opacity(0)
+        self.__item.id = item_id
+        if persistent == DbPersistent.NONE:
+            if self.__item.is_track:
+                Lp().player.emit("loading-changed", True)
+            self.emit("activate")
+        # If no visible widget in stack, self destroyed
+        visible = self.__stack.get_visible_child()
+        if visible is not None:
+            visible.stop()
+            self.__stack.set_visible_child_name("save")
+            self.__stack.get_visible_child().set_sensitive(False)
+
+    def __on_progress(self, web, progress):
+        """
+            Update progress bar
+            @param web as Web
+            @param progress as float
+        """
+        if self.__progress is not None:
+            self.__progress.set_fraction(progress)
+
     def __on_query_tooltip(self, widget, x, y, keyboard, tooltip):
         """
             Show tooltip if needed
@@ -233,9 +310,10 @@ class SearchPopover(Gtk.Popover):
         self.set_position(Gtk.PositionType.BOTTOM)
         self.connect("map", self.__on_map)
         self.connect("unmap", self.__on_unmap)
-        self.__timeout_id = None
+        self.__timeout = None
         self.__current_search = ""
-        self.__cancellable = Gio.Cancellable()
+        self.__nsearch = None
+        self.__lsearch = None
         self.__history = []
 
         builder = Gtk.Builder()
@@ -255,6 +333,12 @@ class SearchPopover(Gtk.Popover):
         self.__spinner = builder.get_object("spinner")
         self.__header_stack = builder.get_object("stack")
 
+        self.__switch = builder.get_object("search-switch")
+        if GLib.find_program_in_path("youtube-dl") is None:
+            self.__switch.set_tooltip_text(_("You need to install youtube-dl"))
+        else:
+            self.__switch.set_state(Lp().settings.get_value("network-search"))
+
         self.__scrolled = builder.get_object("scrolled")
         self.__scrolled.add(self.__view)
         # Connect here because we don"t want previous switch.set_state()
@@ -282,31 +366,48 @@ class SearchPopover(Gtk.Popover):
             Create a new playlist based on search
             @param button as Gtk.Button
         """
-        helper = TaskHelper()
-        helper.run(self.__new_playlist)
+        t = Thread(target=self.__new_playlist)
+        t.daemon = True
+        t.start()
 
     def _on_search_changed(self, widget):
         """
             Timeout filtering
             @param widget as Gtk.TextEntry
         """
-        self.__cancellable.reset()
-        if self.__timeout_id:
-            GLib.source_remove(self.__timeout_id)
-            self.__timeout_id = None
+        self.__reset_search()
+        if self.__timeout:
+            GLib.source_remove(self.__timeout)
+            self.__timeout = None
 
         self.__current_search = widget.get_text().strip()
         if self.__current_search != "":
             self.__new_btn.set_sensitive(True)
-            self.__timeout_id = GLib.timeout_add(
-                                              200,
-                                              self.__on_search_changed_timeout)
+            self.__timeout = GLib.timeout_add(500,
+                                              self.__on_search_changed_thread)
         else:
             self.__new_btn.set_sensitive(False)
 
+    def _on_state_set(self, switch, state):
+        """
+            Save state
+            @param switch as Gtk.switch
+            @param state as bool
+        """
+        Lp().settings.set_boolean("network-search", state)
+        GLib.idle_add(self._on_search_changed, self.__entry)
+
 #######################
 # PRIVATE             #
 #######################
+    def __enable_network_search(self):
+        """
+            True if shoud enable network search
+            @return bool
+        """
+        return GLib.find_program_in_path("youtube-dl") is not None and\
+            get_network_available()
+
     def __calculate_score(self, row):
         """
             Calculate score for row
@@ -314,10 +415,15 @@ class SearchPopover(Gtk.Popover):
         """
         if row.score is not None:
             return
-        score = 0
-        artists = []
-        for artist_id in row.artist_ids:
-            artists.append(Lp().artists.get_name(artist_id))
+        # Network search score less
+        if row.id is None:
+            score = 0
+            artists = row.artists
+        else:
+            score = 1
+            artists = []
+            for artist_id in row.artist_ids:
+                artists.append(Lp().artists.get_name(artist_id))
 
         for item in self.__current_search.split():
             try:
@@ -349,34 +455,78 @@ class SearchPopover(Gtk.Popover):
         self.__calculate_score(row2)
         return row1.score < row2.score
 
-    def __clear(self):
+    def __clear(self, rows):
         """
-            Clear view
+            Clear search view
+            @param items as [SearchRow]
+            @warning not thread safe
         """
-        self.__view.forall(lambda x: self.__view.remove(x))
+        if rows:
+            row = rows.pop(0)
+            self.__view.remove(row)
+            row.destroy()
+            GLib.idle_add(self.__clear, rows)
 
     def __populate(self):
         """
             Populate searching items
             in db based on text entry current text
         """
-        self.__clear()
         self.__header_stack.set_visible_child(self.__spinner)
         self.__spinner.start()
         self.__history = []
+        # Network Search
+        if self.__need_network_search():
+            t = Thread(target=self.__nsearch.do, args=(self.__current_search,))
+            t.daemon = True
+            t.start()
+
+        # Local Search
         search_items = [self.__current_search]
         for item in self.__current_search.split():
-            if len(item) >= 3 and item not in search_items:
+            if len(item) >= 3:
                 search_items.append(item)
-        search = Search()
-        search.get(search_items,
-                   self.__cancellable,
-                   callback=(self.__on_search_get,))
+        GLib.idle_add(self.__clear, self.__view.get_children())
+        t = Thread(target=self.__lsearch.do, args=(search_items,))
+        t.daemon = True
+        t.start()
 
-    def __new_playlist(self, params):
+    def __download_cover(self, uri, row):
+        """
+            Download row covers
+            @param uri as str
+            @param row as SearchRow
+        """
+        try:
+            f = Lio.File.new_for_uri(uri)
+            (status, data, tag) = f.load_contents(None)
+            if status:
+                stream = Gio.MemoryInputStream.new_from_data(data,
+                                                             None)
+                pixbuf = GdkPixbuf.Pixbuf.new_from_stream_at_scale(
+                                                   stream,
+                                                   ArtSize.MEDIUM,
+                                                   -1,
+                                                   True,
+                                                   None)
+                stream.close()
+                GLib.idle_add(row.set_cover, pixbuf)
+        except:
+            pass
+
+    def __populate_user_playlist_by_tracks(self, track_ids, track_id):
+        """
+            Set user playlist
+            @param track_ids as [int]
+            @param track id as int
+            @thread safe
+        """
+        Lp().player.load(Track(track_id))
+        Lp().player.populate_user_playlist_by_tracks(track_ids, [Type.SEARCH])
+
+    def __new_playlist(self):
         """
             Create a new playlist based on search
-            @params as ()
         """
         tracks = []
         for child in self.__view.get_children():
@@ -394,27 +544,82 @@ class SearchPopover(Gtk.Popover):
                 playlist_id = Lp().playlists.get_id(self.__current_search)
             Lp().playlists.add_tracks(playlist_id, tracks)
 
-    def __on_search_get(self, items):
+    def __reset_search(self):
+        """
+            Reset search object
+        """
+        self.__header_stack.set_visible_child(self.__new_btn)
+        self.__spinner.stop()
+        if self.__nsearch is not None:
+            self.__nsearch.disconnect_by_func(self.__on_network_item_found)
+            self.__nsearch.stop()
+            self.__nsearch = None
+        if self.__lsearch is not None:
+            self.__lsearch.disconnect_by_func(self.__on_local_item_found)
+            self.__lsearch.stop()
+            self.__lsearch = None
+
+    def __need_network_search(self):
+        """
+            Return True if network search needed
+            @return True
+        """
+        return Lp().settings.get_value("network-search") and\
+            GLib.find_program_in_path("youtube-dl") is not None
+
+    def __on_local_item_found(self, search):
+        """
+            Add rows for internal results
+            @param search as LocalSearch
+        """
+        if self.__lsearch != search:
+            return
+        if not search.items:
+            if self.__lsearch.finished and\
+                    (self.__nsearch is None or self.__nsearch.finished):
+                self.__header_stack.set_visible_child(self.__new_btn)
+                self.__spinner.stop()
+            return
+        item = search.items.pop(0)
+        search_row = SearchRow(item)
+        search_row.show()
+        self.__view.add(search_row)
+
+    def __on_network_item_found(self, search):
         """
             Add rows for internal results
-            @param items as [SearchItem]
+            @param search as NetworkSearch
         """
-        if items:
-            item = items.pop(0)
-            search_row = SearchRow(item)
+        if self.__nsearch != search:
+            return
+        if not search.items:
+            if self.__nsearch.finished and self.__lsearch.finished:
+                self.__header_stack.set_visible_child(self.__new_btn)
+                self.__spinner.stop()
+            return
+        item = search.items.pop(0)
+        if item.exists_in_db()[0]:
+            return
+        if item.is_track:
+            history = "♫" + item.name + item.artists[0]
+        else:
+            history = item.name + item.artists[0]
+        if history.lower() not in self.__history:
+            self.__history.append(history.lower())
+            search_row = SearchRow(item, False)
             search_row.show()
             self.__view.add(search_row)
-            GLib.idle_add(self.__on_search_get, items)
-        else:
-            GLib.idle_add(self.__spinner.stop)
-            GLib.idle_add(self.__header_stack.set_visible_child,
-                          self.__new_btn)
+            t = Thread(target=self.__download_cover,
+                       args=(item.smallcover, search_row))
+            t.daemon = True
+            t.start()
 
     def __on_map(self, widget):
         """
             Disable global shortcuts and resize
             @param widget as Gtk.Widget
         """
+        self.__switch.set_sensitive(self.__enable_network_search())
         # FIXME Not needed with GTK >= 3.18
         Lp().window.enable_global_shortcuts(False)
         height = Lp().window.get_size()[1]
@@ -427,17 +632,23 @@ class SearchPopover(Gtk.Popover):
         """
         # FIXME Not needed with GTK >= 3.18
         Lp().window.enable_global_shortcuts(True)
-        self.__cancellable.cancel()
+        self.__reset_search()
         self.__header_stack.set_visible_child(self.__new_btn)
         self.__spinner.stop()
 
-    def __on_search_changed_timeout(self):
+    def __on_search_changed_thread(self):
         """
             Populate widget
         """
-        self.__timeout_id = None
-        self.__cancellable.cancel()
-        self.__cancellable.reset()
+        self.__reset_search()
+        from lollypop.search_local import LocalSearch
+        from lollypop.search_network import NetworkSearch
+        self.__timeout = None
+        self.__lsearch = LocalSearch()
+        self.__lsearch.connect("item-found", self.__on_local_item_found)
+        if self.__need_network_search():
+            self.__nsearch = NetworkSearch()
+            self.__nsearch.connect("item-found", self.__on_network_item_found)
         self.__populate()
 
     def __on_row_activated(self, widget, row):
@@ -446,7 +657,11 @@ class SearchPopover(Gtk.Popover):
             @param widget as Gtk.ListBox
             @param row as SearchRow
         """
-        if row.is_track:
+        if row.is_loading:
+            return
+        if row.id is None:
+            row.on_activated(DbPersistent.NONE)
+        elif row.is_track:
             # Add to queue, and play (so remove from queue)
             # Allow us to not change user current playlist
             if not Lp().player.is_party:
diff --git a/lollypop/pop_tunein.py b/lollypop/pop_tunein.py
index a82339e4..ecbc98c2 100644
--- a/lollypop/pop_tunein.py
+++ b/lollypop/pop_tunein.py
@@ -12,20 +12,15 @@
 
 from gi.repository import Gtk, GLib, Gio, GdkPixbuf, Gdk, Pango
 
+from threading import Thread
 from gettext import gettext as _
 
 from lollypop.radios import Radios
+from lollypop.tunein import TuneIn
 from lollypop.define import Lp, ArtSize, WindowSize
 from lollypop.art import Art
 from lollypop.utils import get_network_available
-from lollypop.list import LinkedList
-from lollypop.helper_task import TaskHelper
-
-
-class TuneItem:
-    TEXT = ""
-    URL = ""
-    LOGO = ""
+from lollypop.lio import Lio
 
 
 class TuneinPopover(Gtk.Popover):
@@ -39,13 +34,14 @@ class TuneinPopover(Gtk.Popover):
             @param radios_manager as Radios
         """
         Gtk.Popover.__init__(self)
-        self.__cancellable = Gio.Cancellable()
+        self.__tunein = TuneIn()
         if radios_manager is not None:
             self.__radios_manager = radios_manager
         else:
             self.__radios_manager = Radios()
+        self.__current_url = None
         self.__timeout_id = None
-        self.__history = None
+        self.__previous_urls = []
         self.__covers_to_download = []
 
         self.__stack = Gtk.Stack()
@@ -82,25 +78,23 @@ class TuneinPopover(Gtk.Popover):
         self.connect("map", self.__on_map)
         self.connect("unmap", self.__on_unmap)
 
-    def populate(self, uri="http://opml.radiotime.com/Browse.ashx?c="):
+    def populate(self, url=None):
         """
             Populate views
-            @param uri as str
+            @param url as string
         """
-        if not get_network_available():
-            self.__show_not_found(_("Can't connect to TuneIn…"))
+        if url is None and self.__current_url is not None:
             return
         self.__spinner.start()
         self.__clear()
         self.__stack.set_visible_child_name("spinner")
+        self.__current_url = url
         self.__back_btn.set_sensitive(False)
         self.__home_btn.set_sensitive(False)
         self.__label.set_text(_("Please wait…"))
-        helper = TaskHelper()
-        helper.load_uri_content(uri,
-                                self.__cancellable,
-                                self.__on_uri_content)
-        self.__cancellable.reset()
+        t = Thread(target=self.__populate, args=(url,))
+        t.daemon = True
+        t.start()
 
 #######################
 # PROTECTED           #
@@ -110,22 +104,22 @@ class TuneinPopover(Gtk.Popover):
             Go to previous URL
             @param btn as Gtk.Button
         """
-        if self.__history.prev is None:
-            return
-        self.__history = self.__history.prev
+        url = None
+        self.__current_url = None
+        if self.__previous_urls:
+            url = self.__previous_urls.pop()
         self.__stack.set_visible_child_name("spinner")
         self.__spinner.start()
         self.__clear()
-        self.populate(self.__history.value)
-        if self.__history.prev is None:
-            self.__back_btn.set_sensitive(False)
+        self.populate(url)
 
     def _on_home_btn_clicked(self, btn):
         """
             Go to root URL
             @param btn as Gtk.Button
         """
-        self.__history = None
+        self.__current_url = None
+        self.__previous_urls = []
         self.populate()
 
     def _on_search_changed(self, widget):
@@ -134,7 +128,7 @@ class TuneinPopover(Gtk.Popover):
             after timeout
             @param widget as Gtk.TextEntry
         """
-        self.__history = None
+        self.__current_url = None
         if self.__timeout_id is not None:
             GLib.source_remove(self.__timeout_id)
             self.__timeout_id = None
@@ -146,8 +140,10 @@ class TuneinPopover(Gtk.Popover):
                                                  self.__on_search_timeout,
                                                  text)
         else:
-            self.__history = None
-            self.populate()
+            self.__home_btn.set_sensitive(False)
+            self.__timeout_id = GLib.timeout_add(1000,
+                                                 self._on_home_btn_clicked,
+                                                 None)
 
 #######################
 # PRIVATE             #
@@ -162,80 +158,142 @@ class TuneinPopover(Gtk.Popover):
         self.__stack.set_visible_child_name("notfound")
         self.__home_btn.set_sensitive(True)
 
-    def __add_items(self, items):
+    def __populate(self, url):
+        """
+            Same as populate()
+            @param url as string
+            @thread safe
+        """
+        try:
+            if url is None:
+                items = self.__tunein.get_items(
+                                    "http://opml.radiotime.com/Browse.ashx?c=")
+            else:
+                items = self.__tunein.get_items(url)
+
+            if self.__current_url == url:
+                if items:
+                    self.__add_items(items, url)
+                else:
+                    GLib.idle_add(self.__show_not_found)
+        except:
+            GLib.idle_add(self.__show_not_found,
+                          _("Can't connect to TuneIn…"))
+
+    def __add_items(self, items, url):
         """
             Add current items
             @param items as [TuneItem]
+            @parma url as str
             @thread safe
         """
-        GLib.idle_add(self.__add_item, items)
+        GLib.idle_add(self.__add_item, items, url)
 
-    def __add_item(self, items):
+    def __add_item(self, items, url):
         """
             Add item
             @param items as [TuneItem]
+            @param url as str
         """
-        if items:
-            item = items.pop(0)
-            child = Gtk.Grid()
-            child.set_column_spacing(5)
-            child.set_property("halign", Gtk.Align.START)
-            child.show()
-            link = Gtk.LinkButton.new_with_label(item.URL, item.TEXT)
-            # Hack
-            link.get_children()[0].set_ellipsize(Pango.EllipsizeMode.END)
-            link.connect("activate-link", self.__on_activate_link, item)
-            link.show()
-            if item.TYPE == "audio":
-                link.set_tooltip_text(_("Play"))
-                button = Gtk.Button.new_from_icon_name("list-add-symbolic",
-                                                       Gtk.IconSize.MENU)
-                button.connect("clicked", self.__on_button_clicked, item)
-                button.set_relief(Gtk.ReliefStyle.NONE)
-                button.set_property("valign", Gtk.Align.CENTER)
-                # Translators: radio context
-                button.set_tooltip_text(_("Add"))
-                button.show()
-                child.add(button)
-                image = Gtk.Image.new()
-                image.set_property("width-request", ArtSize.MEDIUM)
-                image.set_property("height-request", ArtSize.MEDIUM)
-                image.show()
-                child.add(image)
-                self.__covers_to_download.append((item, image))
-            else:
-                link.set_tooltip_text("")
-            child.add(link)
-            self.__view.add(child)
-            if not self.__cancellable.is_cancelled():
-                GLib.idle_add(self.__add_items, items)
-        else:  # Download images
-            self.__home_btn.set_sensitive(self.__history is not None)
-            self.__download_images()
+        if url != self.__current_url:
+            return
+        if not items:
+            self.__home_btn.set_sensitive(self.__current_url is not None)
+            t = Thread(target=self.__download_images, args=(url,))
+            t.daemon = True
+            t.start()
             return
+        item = items.pop(0)
+        child = Gtk.Grid()
+        child.set_column_spacing(5)
+        child.set_property("halign", Gtk.Align.START)
+        child.show()
+        link = Gtk.LinkButton.new_with_label(item.URL, item.TEXT)
+        # Hack
+        link.get_children()[0].set_ellipsize(Pango.EllipsizeMode.END)
+        link.connect("activate-link", self.__on_activate_link, item)
+        link.show()
+        if item.TYPE == "audio":
+            link.set_tooltip_text(_("Play"))
+            button = Gtk.Button.new_from_icon_name("list-add-symbolic",
+                                                   Gtk.IconSize.MENU)
+            button.connect("clicked", self.__on_button_clicked, item)
+            button.set_relief(Gtk.ReliefStyle.NONE)
+            button.set_property("valign", Gtk.Align.CENTER)
+            # Translators: radio context
+            button.set_tooltip_text(_("Add"))
+            button.show()
+            child.add(button)
+            image = Gtk.Image.new()
+            image.set_property("width-request", ArtSize.MEDIUM)
+            image.set_property("height-request", ArtSize.MEDIUM)
+            image.show()
+            child.add(image)
+            self.__covers_to_download.append((item, image))
+        else:
+            link.set_tooltip_text("")
+        child.add(link)
+
+        self.__view.add(child)
+
         # Remove spinner if exist
         if self.__stack.get_visible_child_name() == "spinner":
             self.__stack.set_visible_child_name("scrolled")
             self.__spinner.stop()
             self.__label.set_text("")
-            self.__home_btn.set_sensitive(self.__history is not None)
+            if self.__current_url is not None:
+                self.__back_btn.set_sensitive(True)
+        GLib.idle_add(self.__add_items, items, url)
 
-    def __download_images(self):
+    def __download_images(self, url):
         """
             Download and set image for TuneItem
+            @param url as str
             @thread safe
         """
-        if self.__covers_to_download and not self.__cancellable.is_cancelled():
+        while self.__covers_to_download and url == self.__current_url:
             (item, image) = self.__covers_to_download.pop(0)
-            helper = TaskHelper()
-            helper.load_uri_content(item.LOGO, self.__cancellable,
-                                    self.__on_image_downloaded, image)
+            try:
+                f = Lio.File.new_for_uri(item.LOGO)
+                (status, data, tag) = f.load_contents()
+                if status:
+                    stream = Gio.MemoryInputStream.new_from_data(data, None)
+                    if stream is not None:
+                        GLib.idle_add(self.__set_image, image, stream)
+            except Exception as e:
+                GLib.idle_add(image.set_from_icon_name,
+                              "image-missing",
+                              Gtk.IconSize.LARGE_TOOLBAR)
+                print("TuneinPopover::_download_images: %s" % e)
+
+    def __set_image(self, image, stream):
+        """
+            Set image with stream
+            @param image as Gtk.Image
+            @param stream as Gio.MemoryInputStream
+        """
+        try:
+            # Strange issue #969, stream is None
+            # But there is a check in __download_images()
+            pixbuf = GdkPixbuf.Pixbuf.new_from_stream_at_scale(stream,
+                                                               ArtSize.MEDIUM,
+                                                               ArtSize.MEDIUM,
+                                                               True,
+                                                               None)
+            stream.close()
+            surface = Gdk.cairo_surface_create_from_pixbuf(pixbuf,
+                                                           0,
+                                                           None)
+            del pixbuf
+            image.set_from_surface(surface)
+            del surface
+        except Exception as e:
+            print("TuneinPopover::__set_image():", e)
 
     def __clear(self):
         """
             Clear view
         """
-        self.__cancellable.cancel()
         for child in self.__view.get_children():
             self.__view.remove(child)
             child.destroy()
@@ -248,16 +306,22 @@ class TuneinPopover(Gtk.Popover):
         # Get cover art
         try:
             cache = Art._RADIOS_PATH
-            s = Gio.File.new_for_uri(item.LOGO)
-            d = Gio.File.new_for_path("%s/%s.png" %
-                                      (cache, item.TEXT.replace("/", "-")))
+            s = Lio.File.new_for_uri(item.LOGO)
+            d = Lio.File.new_for_path(cache+"/%s.png" %
+                                      item.TEXT.replace("/", "-"))
             s.copy(d, Gio.FileCopyFlags.OVERWRITE, None, None)
         except Exception as e:
             print("TuneinPopover::_add_radio: %s" % e)
-        # Tunein in embbed uri in ashx files, so get content if possible
-        helper = TaskHelper()
-        helper.load_uri_content(item.URL, self.__cancellable,
-                                self.__on_item_content, item.TEXT)
+        url = item.URL
+        # Tune in embbed uri in ashx files, so get content if possible
+        try:
+            f = Lio.File.new_for_uri(url)
+            (status, data, tag) = f.load_contents()
+            if status:
+                url = data.decode("utf-8").split("\n")[0]
+        except Exception as e:
+            print("TuneinPopover::_add_radio: %s" % e)
+        self.__radios_manager.add(item.TEXT.replace("/", "-"), url)
 
     def __on_map(self, widget):
         """
@@ -274,112 +338,44 @@ class TuneinPopover(Gtk.Popover):
             Enable global shortcuts
             @param widget as Gtk.Widget
         """
-        self.__cancellable.cancel()
         # FIXME Not needed with GTK >= 3.18
         Lp().window.enable_global_shortcuts(True)
 
-    def __on_item_content(self, uri, status, content, name):
-        """
-            Add radio to manager
-            @param uri as str
-            @param status as bool
-            @param content as bytes
-            @param name as str
-        """
-        if status:
-            uri = content.decode("utf-8").split("\n")[0]
-        self.__radios_manager.add(name.replace("/", "-"), uri)
-
-    def __on_image_downloaded(self, uri, status, content, image):
-        """
-            Set downloaded image
-            @param uri as str
-            @param status as bool
-            @param content as bytes
-            @param image as Gtk.Image
-        """
-        if status:
-            bytes = GLib.Bytes(content)
-            stream = Gio.MemoryInputStream.new_from_bytes(bytes)
-            bytes.unref()
-            if stream is not None:
-                pixbuf = GdkPixbuf.Pixbuf.new_from_stream_at_scale(
-                                                       stream,
-                                                       ArtSize.MEDIUM,
-                                                       ArtSize.MEDIUM,
-                                                       True,
-                                                       None)
-                stream.close()
-                surface = Gdk.cairo_surface_create_from_pixbuf(pixbuf,
-                                                               0,
-                                                               None)
-                image.set_from_surface(surface)
-        self.__download_images()
-
     def __on_activate_link(self, link, item):
         """
-            Open new uri or just play stream
+            Update header with new link
             @param link as Gtk.LinkButton
             @param item as TuneIn Item
         """
         if item.TYPE == "link":
             self.__scrolled.get_vadjustment().set_value(0.0)
+            if self.__current_url is not None:
+                self.__previous_urls.append(self.__current_url)
             self.populate(item.URL)
         elif item.TYPE == "audio":
             if get_network_available():
-                helper = TaskHelper()
                 # Cache for toolbar
-                helper.run(Lp().art.copy_uri_to_cache,
-                           item.LOGO, item.TEXT, Lp().window.toolbar.artsize)
+                t = Thread(target=Lp().art.copy_uri_to_cache,
+                           args=(item.LOGO, item.TEXT,
+                                 Lp().window.toolbar.artsize))
+                t.daemon = True
+                t.start()
                 # Cache for MPRIS
-                helper.run(Lp().art.copy_uri_to_cache,
-                           item.LOGO, item.TEXT, ArtSize.BIG)
+                t = Thread(target=Lp().art.copy_uri_to_cache,
+                           args=(item.LOGO, item.TEXT,
+                                 ArtSize.BIG))
+                t.daemon = True
+                t.start()
                 # Cache for miniplayer
-                helper.run(Lp().art.copy_uri_to_cache,
-                           item.LOGO, item.TEXT, WindowSize.SMALL)
+                t = Thread(target=Lp().art.copy_uri_to_cache,
+                           args=(item.LOGO, item.TEXT,
+                                 WindowSize.SMALL))
+                t.daemon = True
+                t.start()
             Lp().player.load_external(item.URL, item.TEXT)
             Lp().player.play_this_external(item.URL)
         return True
 
-    def __on_uri_content(self, uri, status, content):
-        """
-            Extract content
-            @param uri as str
-            @param status as bool
-            @param content as bytes
-        """
-        try:
-            if status:
-                if self.__history is not None:
-                    self.__back_btn.set_sensitive(True)
-                self.__history = LinkedList(uri, None, self.__history)
-                if content:
-                    import xml.etree.ElementTree as xml
-                    items = []
-                    root = xml.fromstring(content)
-                    for child in root.iter("outline"):
-                        try:
-                            item = TuneItem()
-                            item.URL = child.attrib["URL"]
-                            item.TEXT = child.attrib["text"]
-                            try:
-                                item.LOGO = child.attrib["image"]
-                            except:
-                                pass
-                            item.TYPE = child.attrib["type"]
-                            items.append(item)
-                        except:
-                            del item
-                    if items:
-                        self.__add_items(items)
-                    else:
-                        self.__show_not_found(_("No result…"))
-                else:
-                    self.__show_not_found(_("No result…"))
-        except Exception as e:
-            print("TuneinPopover::__on_uri_content():", e)
-            self.__show_not_found(_("Can't connect to TuneIn…"))
-
     def __on_button_clicked(self, button, item):
         """
             Play the radio
@@ -387,7 +383,9 @@ class TuneinPopover(Gtk.Popover):
             @param item as TuneIn Item
         """
         self.__timeout_id = None
-        self.__add_radio(item)
+        t = Thread(target=self.__add_radio, args=(item,))
+        t.daemon = True
+        t.start()
         self.hide()
 
     def __on_search_timeout(self, string):
@@ -396,6 +394,6 @@ class TuneinPopover(Gtk.Popover):
             @param string as str
         """
         self.__timeout_id = None
-        uri = "http://opml.radiotime.com/Search.ashx?query=%s" %\
+        url = "http://opml.radiotime.com/Search.ashx?query=%s" %\
             GLib.uri_escape_string(string, "/", False)
-        self.populate(uri)
+        self.populate(url)
diff --git a/lollypop/radios.py b/lollypop/radios.py
index dc8949e9..45af3902 100644
--- a/lollypop/radios.py
+++ b/lollypop/radios.py
@@ -10,11 +10,13 @@
 # You should have received a copy of the GNU General Public License
 # along with this program. If not, see <http://www.gnu.org/licenses/>.
 
-from gi.repository import GObject, GLib
+from gi.repository import GObject, GLib, Gio, TotemPlParser
 
 import sqlite3
 
 from lollypop.sqlcursor import SqlCursor
+from lollypop.define import Type
+from lollypop.lio import Lio
 
 
 class Radios(GObject.GObject):
@@ -40,6 +42,8 @@ class Radios(GObject.GObject):
             Init playlists manager
         """
         GObject.GObject.__init__(self)
+        f = Lio.File.new_for_path(self.DB_PATH)
+        try_import = not f.query_exists()
         # Create db schema
         try:
             with SqlCursor(self) as sql:
@@ -48,6 +52,23 @@ class Radios(GObject.GObject):
         except:
             pass
 
+        # We import radios from lollypop < 0.9.60
+        if try_import:
+            d = Lio.File.new_for_path(self.LOCAL_PATH + "/radios")
+            infos = d.enumerate_children(
+                "standard::name",
+                Gio.FileQueryInfoFlags.NOFOLLOW_SYMLINKS,
+                None)
+            for info in infos:
+                f = info.get_name()
+                if f.endswith(".m3u"):
+                    parser = TotemPlParser.Parser.new()
+                    parser.connect("entry-parsed",
+                                   self.__on_entry_parsed,
+                                   f[:-4])
+                    parser.parse_async(d.get_uri() + "/%s" % f,
+                                       True, None, None)
+
     def add(self, name, url):
         """
             Add a radio, update url if radio already exists in db
@@ -254,9 +275,9 @@ class Radios(GObject.GObject):
                                   FROM radios\
                                   WHERE name=?", (name,))
             v = result.fetchone()
-            if v:
+            if v and v[0]:
                 return v[0]
-            return 0
+            return Type.NONE
 
     def get_cursor(self):
         """
diff --git a/lollypop/search_item.py b/lollypop/search_item.py
new file mode 100644
index 00000000..56e4bca1
--- /dev/null
+++ b/lollypop/search_item.py
@@ -0,0 +1,55 @@
+# Copyright (c) 2014-2017 Cedric Bellegarde <cedric.bellegarde@adishatz.org>
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+# GNU General Public License for more details.
+# You should have received a copy of the GNU General Public License
+# along with this program. If not, see <http://www.gnu.org/licenses/>.
+
+from lollypop.define import Lp
+
+
+class SearchItem:
+    """
+        Represent a search item
+    """
+    def __init__(self):
+        self.is_track = False
+        self.id = None  # Always None for externals
+        self.ex_id = None
+        # Internal
+        self.artist_ids = []
+        # External
+        self.artists = []
+        self.name = ""
+        self.track_number = 0
+        self.cover = ""
+        self.smallcover = ""
+        self.year = None
+        self.subitems = []
+        self.album = None
+        self.mtime = 0
+
+    def exists_in_db(self):
+        """
+            Search if item exists in db
+            @return (bool, int)
+        """
+        artist_ids = []
+        for artist in self.artists:
+            artist_id = Lp().artists.get_id(artist)
+            artist_ids.append(artist_id)
+        if self.is_track:
+            album_id = Lp().albums.get_id(self.album.name, artist_ids, True)
+            track_id = Lp().tracks.get_id_by(self.name,
+                                             album_id,
+                                             artist_ids)
+            return (track_id is not None, track_id)
+        else:
+            album_id = Lp().albums.get_id(self.name, artist_ids, True)
+            return (album_id is not None, album_id)
+        return (False, None)
diff --git a/lollypop/search_itunes.py b/lollypop/search_itunes.py
new file mode 100644
index 00000000..4588dfbc
--- /dev/null
+++ b/lollypop/search_itunes.py
@@ -0,0 +1,130 @@
+# Copyright (c) 2014-2017 Cedric Bellegarde <cedric.bellegarde@adishatz.org>
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+# GNU General Public License for more details.
+# You should have received a copy of the GNU General Public License
+# along with this program. If not, see <http://www.gnu.org/licenses/>.
+
+from gi.repository import GLib, Gio
+
+import json
+
+from lollypop.search_item import SearchItem
+from lollypop.lio import Lio
+
+
+class ItunesSearch:
+    """
+        Search provider for Itunes
+    """
+    def __init__(self):
+        """
+            Init provider
+        """
+        if not hasattr(self, "_cancel"):
+            self._cancel = Gio.Cancellable.new()
+
+    def tracks(self, name):
+        """
+            Return tracks containing name
+            @param name as str
+        """
+        try:
+            formated = GLib.uri_escape_string(name, None, True).replace(
+                                                                      " ", "+")
+            s = Lio.File.new_for_uri("https://itunes.apple.com/search"
+                                     "?entity=musicTrack&term=%s" % formated)
+            (status, data, tag) = s.load_contents(self._cancel)
+            if status:
+                decode = json.loads(data.decode("utf-8"))
+                tracks = []
+                for item in decode["results"]:
+                    if item["trackName"].lower() in tracks:
+                        continue
+                    album_item = SearchItem()
+                    album_item.name = item["collectionName"]
+                    search_item = SearchItem()
+                    search_item.is_track = True
+                    search_item.name = item["trackName"]
+                    tracks.append(search_item.name.lower())
+                    search_item.album = album_item
+                    search_item.tracknumber = int(item["trackNumber"])
+                    search_item.discnumber = int(item["discNumber"])
+                    search_item.duration = int(item["trackTimeMillis"]) / 1000
+                    search_item.cover = item["artworkUrl60"].replace("60x60",
+                                                                     "512x512")
+                    search_item.smallcover = item["artworkUrl100"]
+                    search_item.artists.append(item["artistName"])
+                    self._items.append(search_item)
+                    GLib.idle_add(self.emit, "item-found")
+        except Exception as e:
+            print("SpotifySearch::tracks(): %s" % e)
+
+    def albums(self, name):
+        """
+            Return albums containing name
+            @param name as str
+            @return albums as [SearchItem]
+        """
+        self.__get_albums(name)
+
+#######################
+# PRIVATE             #
+#######################
+    def __get_albums(self, name):
+        """
+            Get albums for name
+            @param name as str
+        """
+        try:
+            # Read album list
+            formated = GLib.uri_escape_string(name, None, True).replace(
+                                                                      " ", "+")
+            s = Lio.File.new_for_uri("https://itunes.apple.com/search"
+                                     "?entity=album&term=%s" % formated)
+            (status, data, tag) = s.load_contents(self._cancel)
+            if not status:
+                raise
+            decode = json.loads(data.decode("utf-8"))
+            # For each album, get cover and tracks
+            for item in decode["results"]:
+                album_item = SearchItem()
+                album_item.name = item["collectionName"]
+                album_item.is_track = False
+                album_item.artists = [item["artistName"]]
+                album_item.cover = item["artworkUrl60"].replace("60x60",
+                                                                "512x512")
+                album_item.smallcover = item["artworkUrl100"]
+                s = Lio.File.new_for_uri("https://itunes.apple.com/lookup"
+                                         "?id=%s&entity=song" %
+                                         item["collectionId"])
+                (status, data, tag) = s.load_contents(self._cancel)
+                if not status:
+                    raise
+                decode = json.loads(data.decode("utf-8"))
+                for item in decode["results"]:
+                    if item["wrapperType"] == "collection":
+                        continue
+                    track_item = SearchItem()
+                    track_item.is_track = True
+                    try:
+                        track_item.year = decode["releaseDate"][:4]
+                    except:
+                        pass  # May be missing
+                    track_item.name = item["trackName"]
+                    track_item.album = album_item
+                    track_item.tracknumber = int(item["trackNumber"])
+                    track_item.discnumber = int(item["discNumber"])
+                    track_item.duration = int(item["trackTimeMillis"])\
+                        / 1000
+                    track_item.artists.append(item["artistName"])
+                    album_item.subitems.append(track_item)
+                self._items.append(album_item)
+                GLib.idle_add(self.emit, "item-found")
+        except Exception as e:
+            print("ItunesSearch::__get_albums(): %s" % e)
diff --git a/lollypop/search.py b/lollypop/search_local.py
similarity index 68%
rename from lollypop/search.py
rename to lollypop/search_local.py
index dbf7b11e..ecec29d0 100644
--- a/lollypop/search.py
+++ b/lollypop/search_local.py
@@ -10,61 +10,66 @@
 # You should have received a copy of the GNU General Public License
 # along with this program. If not, see <http://www.gnu.org/licenses/>.
 
-from lollypop.define import Lp
-from lollypop.helper_task import TaskHelper
-
+from gi.repository import GObject, Gio, GLib
 
-class SearchItem:
-    """
-        Represent a search item
-    """
-    def __init__(self):
-        self.is_track = False
-        self.id = None
+from lollypop.define import Lp
+from lollypop.search_item import SearchItem
 
 
-class Search:
+class LocalSearch(GObject.GObject):
     """
-        Local search
+        Search provider over network
     """
+    __gsignals__ = {
+        "item-found": (GObject.SignalFlags.RUN_FIRST, None, ()),
+    }
 
     def __init__(self):
         """
-            Init search
+            Init provider
         """
-        pass
+        GObject.GObject.__init__(self)
+        self._cancel = Gio.Cancellable.new()
+        self._items = []
+        self.__stop = False
+        self._finished = False
 
-    def get(self, search_items, cancellable, callback):
+    @property
+    def finished(self):
+        """
+            True if search finished
         """
-            Get track for name
-            @param search_items as [str]
-            @param cancellable as Gio.Cancellable
-            @param callback as callback
+        return self._finished
+
+    @property
+    def items(self):
         """
-        helper = TaskHelper()
-        helper.run(self.__get, search_items, cancellable, callback=callback)
+            Get items
+            @return items as [SearchItems]
+        """
+        return self._items
+
+    def stop(self):
+        self.__stop = True
 
-#######################
-# PRIVATE             #
-#######################
-    def __get(self, search_items, cancellable):
+    def do(self, search_items):
         """
-            Get track for name
-            @param search_items as [str]
-            @param cancellable as Gio.Cancellable
-            @return items as [SearchItem]
+            Return tracks containing name
+            @param search items as [str]
+            @return tracks as [SearchItem]
         """
-        items = []
+        self.__stop = False
+        # Local search
         added_album_ids = []
         added_track_ids = []
         for item in search_items:
-            if cancellable.is_cancelled():
+            if self.__stop:
                 return
             albums = []
             tracks_non_album_artist = []
             # Get all albums for all artists and non album_artist tracks
             for artist_id in Lp().artists.search(item):
-                if cancellable.is_cancelled():
+                if self.__stop:
                     return
                 for album_id in Lp().albums.get_ids([artist_id], []):
                     if (album_id, artist_id) not in albums:
@@ -74,7 +79,7 @@ class Search:
                     tracks_non_album_artist.append((track_id, track_name))
 
             for album_id, artist_id in albums:
-                if cancellable.is_cancelled():
+                if self.__stop:
                     return
                 if album_id in added_album_ids:
                     continue
@@ -84,7 +89,8 @@ class Search:
                 search_item.is_track = False
                 search_item.artist_ids = [artist_id]
                 search_item.year = Lp().albums.get_year(album_id)
-                items.append(search_item)
+                self._items.append(search_item)
+                GLib.idle_add(self.emit, "item-found")
 
             try:
                 year = int(item)
@@ -93,7 +99,7 @@ class Search:
                 albums = []
             albums += Lp().albums.search(item)
             for album_id in albums:
-                if cancellable.is_cancelled():
+                if self.__stop:
                     return
                 if album_id in added_album_ids:
                     continue
@@ -103,11 +109,12 @@ class Search:
                 search_item.is_track = False
                 search_item.artist_ids = Lp().albums.get_artist_ids(album_id)
                 search_item.year = Lp().albums.get_year(album_id)
-                items.append(search_item)
+                self._items.append(search_item)
+                GLib.idle_add(self.emit, "item-found")
 
             for track_id, track_name in Lp().tracks.search(
                                                item) + tracks_non_album_artist:
-                if cancellable.is_cancelled():
+                if self.__stop:
                     return
                 if track_id in added_track_ids:
                     continue
@@ -116,5 +123,7 @@ class Search:
                 added_track_ids.append(track_id)
                 search_item.is_track = True
                 search_item.artist_ids = Lp().tracks.get_artist_ids(track_id)
-                items.append(search_item)
-        return items
+                self._items.append(search_item)
+                GLib.idle_add(self.emit, "item-found")
+        self._finished = True
+        GLib.idle_add(self.emit, "item-found")
diff --git a/lollypop/search_network.py b/lollypop/search_network.py
new file mode 100644
index 00000000..701836de
--- /dev/null
+++ b/lollypop/search_network.py
@@ -0,0 +1,86 @@
+# Copyright (c) 2014-2017 Cedric Bellegarde <cedric.bellegarde@adishatz.org>
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+# GNU General Public License for more details.
+# You should have received a copy of the GNU General Public License
+# along with this program. If not, see <http://www.gnu.org/licenses/>.
+
+from gi.repository import GObject, Gio, GLib
+
+from lollypop.search_spotify import SpotifySearch
+from lollypop.search_itunes import ItunesSearch
+from lollypop.utils import get_network_available
+from lollypop.define import Lp
+
+
+class NetworkSearch(SpotifySearch, ItunesSearch, GObject.GObject):
+    """
+        Search provider over network
+    """
+    __gsignals__ = {
+        "item-found": (GObject.SignalFlags.RUN_FIRST, None, ()),
+    }
+
+    def __init__(self):
+        """
+            Init provider
+        """
+        GObject.GObject.__init__(self)
+        SpotifySearch.__init__(self)
+        ItunesSearch.__init__(self)
+        self._cancel = Gio.Cancellable.new()
+        self._items = []
+        self._finished = False
+
+    @property
+    def finished(self):
+        """
+            True if search finished
+        """
+        return self._finished
+
+    @property
+    def items(self):
+        """
+            Get items
+            @return items as [SearchItems]
+        """
+        return self._items
+
+    def stop(self):
+        self._cancel.cancel()
+
+    def do_tracks(self, name):
+        """
+            Populate items with tracks containing name
+            @param name as str
+            @return tracks/albums as [SearchItem]
+        """
+        if get_network_available():
+            if Lp().settings.get_value("search-itunes"):
+                ItunesSearch.tracks(self, name)
+            if Lp().settings.get_value("search-spotify"):
+                SpotifySearch.tracks(self, name)
+        self._finished = True
+        GLib.idle_add(self.emit, "item-found")
+
+    def do(self, name):
+        """
+            Populate items with albums/tracks containing name
+            @param name as str
+            @return tracks/albums as [SearchItem]
+        """
+        if get_network_available():
+            if Lp().settings.get_value("search-itunes"):
+                ItunesSearch.albums(self, name)
+                ItunesSearch.tracks(self, name)
+            if Lp().settings.get_value("search-spotify"):
+                SpotifySearch.albums(self, name)
+                SpotifySearch.tracks(self, name)
+        self._finished = True
+        GLib.idle_add(self.emit, "item-found")
diff --git a/lollypop/search_spotify.py b/lollypop/search_spotify.py
new file mode 100644
index 00000000..e05c3d5b
--- /dev/null
+++ b/lollypop/search_spotify.py
@@ -0,0 +1,346 @@
+# Copyright (c) 2014-2017 Cedric Bellegarde <cedric.bellegarde@adishatz.org>
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+# GNU General Public License for more details.
+# You should have received a copy of the GNU General Public License
+# along with this program. If not, see <http://www.gnu.org/licenses/>.
+
+from gi.repository import GLib, Gio, Soup
+
+import json
+from base64 import b64encode
+from time import time
+
+from lollypop.search_item import SearchItem
+from lollypop.lio import Lio
+from lollypop.utils import debug
+from lollypop.define import SPOTIFY_CLIENT_ID, SPOTIFY_SECRET
+
+
+class SpotifySearch:
+    """
+        Search provider for Spotify
+    """
+    __EXPIRES = 0
+    __TOKEN = None
+
+    def get_token(cancellable):
+        """
+            Get a new auth token
+            @param cancellable as Gio.Cancellable
+            @return str
+        """
+        # Remove 60 seconds to be sure
+        if int(time()) + 60 < SpotifySearch.__EXPIRES and\
+                SpotifySearch.__TOKEN is not None:
+            debug("Use spotify token: %s" % SpotifySearch.__TOKEN)
+            return SpotifySearch.__TOKEN
+        try:
+            token_uri = "https://accounts.spotify.com/api/token"
+            credentials = "%s:%s" % (SPOTIFY_CLIENT_ID, SPOTIFY_SECRET)
+            encoded = b64encode(credentials.encode("utf-8"))
+            credentials = encoded.decode("utf-8")
+            session = Soup.Session.new()
+            data = {"grant_type": "client_credentials"}
+            msg = Soup.form_request_new_from_hash("POST", token_uri, data)
+            msg.request_headers.append("Authorization",
+                                       "Basic %s" % credentials)
+            status = session.send_message(msg)
+            if status == 200:
+                body = msg.get_property("response-body")
+                data = body.flatten().get_data()
+                decode = json.loads(data.decode("utf-8"))
+                SpotifySearch.__EXPIRES = int(time()) +\
+                    int(decode["expires_in"])
+                SpotifySearch.__TOKEN = decode["access_token"]
+                return SpotifySearch.__TOKEN
+        except:
+            return ""
+
+    def __init__(self):
+        """
+            Init provider
+        """
+        self.__token = SpotifySearch.get_token(None)
+        if not hasattr(self, "_cancel"):
+            self._cancel = Gio.Cancellable.new()
+
+    def tracks(self, name):
+        """
+            Return tracks containing name
+            @param name as str
+        """
+        try:
+            formated = GLib.uri_escape_string(name, None, True).replace(
+                                                                      " ", "+")
+            s = Lio.File.new_for_uri("https://api.spotify.com/v1/search?q=%s"
+                                     "&type=track" % formated)
+            s.add_spotify_headers(self.__token)
+            (status, data, tag) = s.load_contents(self._cancel)
+            if status:
+                decode = json.loads(data.decode("utf-8"))
+                tracks = []
+                for item in decode["tracks"]["items"]:
+                    if item["name"].lower() in tracks:
+                        continue
+                    album_item = SearchItem()
+                    search_item = SearchItem()
+                    search_item.is_track = True
+                    search_item.name = item["name"]
+                    album_item.name = item["name"]
+                    search_item.album = album_item
+                    tracks.append(search_item.name.lower())
+                    search_item.tracknumber = int(item["track_number"])
+                    search_item.discnumber = int(item["disc_number"])
+                    search_item.duration = int(item["duration_ms"]) / 1000
+                    search_item.cover = item["album"]["images"][0]["url"]
+                    search_item.smallcover = item["album"]["images"][2]["url"]
+                    for artist in item["artists"]:
+                        search_item.artists.append(artist["name"])
+                    self._items.append(search_item)
+                    GLib.idle_add(self.emit, "item-found")
+        except Exception as e:
+            print("SpotifySearch::tracks(): %s" % e)
+
+    def albums(self, name):
+        """
+            Return albums containing name
+            @param name as str
+            @return albums as [SearchItem]
+        """
+        self.__get_artists(name)
+        self.__get_albums(name)
+
+    def get_album_id(self, track_id):
+        """
+            Get album id for track
+            @param track id as str
+            @return album id as str
+        """
+        try:
+            s = Lio.File.new_for_uri("https://api.spotify.com/v1/"
+                                     "tracks/%s" % track_id)
+            s.add_spotify_headers(self.__token)
+            (status, data, tag) = s.load_contents(self._cancel)
+            if status:
+                decode = json.loads(data.decode("utf-8"))
+                return decode["album"]["id"]
+        except Exception as e:
+            print("SpotifySearch::get_album_id():", e, track_id)
+
+    def get_album(self, album_id):
+        """
+            Return spotify album as SearchItem
+            @param album id as str
+            @return SearchItem
+        """
+        try:
+            s = Lio.File.new_for_uri("https://api.spotify.com/v1/"
+                                     "albums/%s" % album_id)
+            s.add_spotify_headers(self.__token)
+            (status, data, tag) = s.load_contents(self._cancel)
+            if status:
+                decode = json.loads(data.decode("utf-8"))
+                album_item = SearchItem()
+                album_item.name = decode["name"]
+                album_item.cover = decode["images"][0]["url"]
+                album_item.smallcover = decode["images"][2]["url"]
+                album_item.ex_id = album_id
+                for item in decode["tracks"]["items"]:
+                    track_item = SearchItem()
+                    track_item.is_track = True
+                    track_item.name = item["name"]
+                    track_item.album = album_item.name
+                    try:
+                        track_item.year = decode[
+                                                "release_date"][:4]
+                    except:
+                        pass  # May be missing
+                    track_item.tracknumber = int(
+                                              item["track_number"])
+                    track_item.discnumber = int(
+                                               item["disc_number"])
+                    track_item.duration = int(
+                                        item["duration_ms"]) / 1000
+                    for artist in item["artists"]:
+                        track_item.artists.append(artist["name"])
+                    if not album_item.artists:
+                        album_item.artists = track_item.artists
+                    album_item.subitems.append(track_item)
+                return album_item
+        except Exception as e:
+            print("SpotifySearch::get_album:", e)
+        return None
+
+    def get_track(self, track_id):
+        """
+            Return spotify track as SearchItem
+            @param track id as str
+            @return SearchItem
+        """
+        try:
+            s = Lio.File.new_for_uri("https://api.spotify.com/v1/"
+                                     "tracks/%s" % track_id)
+            s.add_spotify_headers(self.__token)
+            (status, data, tag) = s.load_contents(self._cancel)
+            if status:
+                decode = json.loads(data.decode("utf-8"))
+                album_item = SearchItem()
+                album_item.name = decode["album"]["name"]
+                album_item.cover = decode["album"]["images"][0]["url"]
+                album_item.smallcover = decode["album"]["images"][2]["url"]
+
+                track_item = SearchItem()
+                track_item.is_track = True
+                track_item.name = decode["name"]
+                track_item.album = album_item
+                track_item.tracknumber = int(
+                                          decode["track_number"])
+                track_item.discnumber = int(
+                                           decode["disc_number"])
+                track_item.duration = int(
+                                    decode["duration_ms"]) / 1000
+                for artist in decode["artists"]:
+                    track_item.artists.append(artist["name"])
+                album_item.artists = track_item.artists
+                album_item.subitems.append(track_item)
+                return album_item
+        except Exception as e:
+            print("SpotifySearch::get_track", e)
+        return None
+
+#######################
+# PRIVATE             #
+#######################
+    def __get_artists(self, name):
+        """
+            Get albums for artists name
+            @param name as str
+        """
+        try:
+            # Read album list
+            formated = GLib.uri_escape_string(name, None, True).replace(
+                                                                      " ", "+")
+            s = Lio.File.new_for_uri("https://api.spotify.com/v1/search?q=%s"
+                                     "&type=artist" % formated)
+            s.add_spotify_headers(self.__token)
+            (status, data, tag) = s.load_contents(self._cancel)
+            if status:
+                decode = json.loads(data.decode("utf-8"))
+                # For each album, get cover and tracks
+                artists = []
+                for item in decode["artists"]["items"]:
+                    album_items = []
+                    artist_id = item["id"]
+                    if item["name"].lower() in artists:
+                        continue
+                    artists.append(item["name"].lower())
+                    s = Lio.File.new_for_uri("https://api.spotify.com/"
+                                             "v1/artists/%s/albums" %
+                                             artist_id)
+                    s.add_spotify_headers(self.__token)
+                    (status, data, tag) = s.load_contents(self._cancel)
+                    if status:
+                        decode = json.loads(data.decode("utf-8"))
+                        albums = []
+                        for item in decode["items"]:
+                            if item["name"].lower() in albums:
+                                continue
+                            album_item = SearchItem()
+                            album_item.name = item["name"]
+                            albums.append(album_item.name.lower())
+                            album_item.cover = item["images"][0]["url"]
+                            album_item.smallcover = item["images"][2]["url"]
+                            album_items.append(album_item)
+                            album_item.ex_id = item["id"]
+
+                    for album_item in album_items:
+                        s = Lio.File.new_for_uri("https://api.spotify.com/v1/"
+                                                 "albums/%s" %
+                                                 album_item.ex_id)
+                        s.add_spotify_headers(self.__token)
+                        (status, data, tag) = s.load_contents(self._cancel)
+                        if status:
+                            decode = json.loads(data.decode("utf-8"))
+                            for item in decode["tracks"]["items"]:
+                                track_item = SearchItem()
+                                track_item.is_track = True
+                                track_item.name = item["name"]
+                                track_item.album = album_item
+                                try:
+                                    track_item.year = decode[
+                                                            "release_date"][:4]
+                                except:
+                                    pass  # May be missing
+                                track_item.tracknumber = int(
+                                                          item["track_number"])
+                                track_item.discnumber = int(
+                                                           item["disc_number"])
+                                track_item.duration = int(
+                                                    item["duration_ms"]) / 1000
+                                for artist in item["artists"]:
+                                    track_item.artists.append(artist["name"])
+                                if not album_item.artists:
+                                    album_item.artists = track_item.artists
+                                album_item.subitems.append(track_item)
+                        self._items.append(album_item)
+                        GLib.idle_add(self.emit, "item-found")
+        except Exception as e:
+            print("SpotifySearch::albums(): %s" % e)
+
+    def __get_albums(self, name):
+        """
+            Get albums for name
+            @param name as str
+        """
+        try:
+            # Read album list
+            formated = GLib.uri_escape_string(name, None, True).replace(
+                                                                      " ", "+")
+            s = Lio.File.new_for_uri("https://api.spotify.com/v1/search?q=%s"
+                                     "&type=album" % formated)
+            s.add_spotify_headers(self.__token)
+            (status, data, tag) = s.load_contents(self._cancel)
+            if status:
+                decode = json.loads(data.decode("utf-8"))
+                # For each album, get cover and tracks
+                for item in decode["albums"]["items"]:
+                    album_item = SearchItem()
+                    album_item.name = item["name"]
+                    album_item.is_track = False
+                    album_item.cover = item["images"][0]["url"]
+                    album_item.smallcover = item["images"][2]["url"]
+                    s = Lio.File.new_for_uri("https://api.spotify.com/v1/"
+                                             "albums/%s" % item["id"])
+                    s.add_spotify_headers(self.__token)
+                    (status, data, tag) = s.load_contents(self._cancel)
+                    if status:
+                        decode = json.loads(data.decode("utf-8"))
+                        for item in decode["tracks"]["items"]:
+                            track_item = SearchItem()
+                            track_item.is_track = True
+                            try:
+                                track_item.year = decode[
+                                                        "release_date"][:4]
+                            except:
+                                pass  # May be missing
+                            track_item.name = item["name"]
+                            track_item.album = album_item
+                            track_item.tracknumber = int(item["track_number"])
+                            track_item.discnumber = int(item["disc_number"])
+                            track_item.duration = int(item["duration_ms"])\
+                                / 1000
+                            for artist in item["artists"]:
+                                track_item.artists.append(artist["name"])
+                            if not album_item.artists:
+                                album_item.artists = track_item.artists
+                            album_item.subitems.append(track_item)
+                    self._items.append(album_item)
+                    GLib.idle_add(self.emit, "item-found")
+        except Exception as e:
+            print("SpotifySearch::albums(): %s" % e)
diff --git a/lollypop/selectionlist.py b/lollypop/selectionlist.py
index f21e1325..b7a5c356 100644
--- a/lollypop/selectionlist.py
+++ b/lollypop/selectionlist.py
@@ -77,10 +77,13 @@ class SelectionList(Gtk.Overlay):
         self.__scrolled.add(self.__view)
         self.__scrolled.show()
         self.add(self.__scrolled)
-        self.__fast_scroll = FastScroll(self.__view,
-                                        self.__model,
-                                        self.__scrolled)
-        self.add_overlay(self.__fast_scroll)
+        if Gtk.get_minor_version() > 14:
+            self.__fast_scroll = FastScroll(self.__view,
+                                            self.__model,
+                                            self.__scrolled)
+            self.add_overlay(self.__fast_scroll)
+        else:
+            self.__fast_scroll = None
         self.__scrolled.connect("enter-notify-event", self.__on_enter_notify)
         self.__scrolled.connect("leave-notify-event", self.__on_leave_notify)
 
@@ -287,9 +290,11 @@ class SelectionList(Gtk.Overlay):
             items.append((Type.LOVED, _("Loved albums")))
         items.append((Type.RECENTS, _("Recently added albums")))
         items.append((Type.RANDOMS, _("Random albums")))
-        items.append((Type.NEVER, _("Never played albums")))
         items.append((Type.PLAYLISTS, _("Playlists")))
         items.append((Type.RADIOS, _("Radios")))
+        if Lp().settings.get_value("show-charts") and\
+                Lp().settings.get_value("network-access"):
+            items.append((Type.CHARTS, _("The charts")))
         if self.__is_artists:
             items.append((Type.ALL, _("All albums")))
         else:
@@ -462,7 +467,15 @@ class SelectionList(Gtk.Overlay):
         elif object_id == Type.LOVED:
             icon = "emblem-favorite-symbolic"
         elif object_id == Type.NEVER:
-            icon = "audio-speakers-symbolic"
+            icon = "document-new-symbolic"
+        elif object_id == Type.CHARTS:
+            icon = "application-rss+xml-symbolic"
+        elif object_id == Type.SPOTIFY:
+            icon = "lollypop-spotify-symbolic"
+        elif object_id == Type.ITUNES:
+            icon = "lollypop-itunes-symbolic"
+        elif object_id == Type.LASTFM:
+            icon = "lollypop-lastfm-symbolic"
         elif object_id == Type.NOPARTY:
             icon = "emblem-music-symbolic"
         return icon
diff --git a/lollypop/settings.py b/lollypop/settings.py
index 87c53922..2ef9f9d3 100644
--- a/lollypop/settings.py
+++ b/lollypop/settings.py
@@ -11,16 +11,23 @@
 # along with this program. If not, see <http://www.gnu.org/licenses/>.
 
 from gi.repository import Gtk, Gdk, GLib, Gio, Pango
+try:
+    from gi.repository import Secret
+except:
+    Secret = None
+
 
 from gettext import gettext as _
 from gettext import ngettext as ngettext
+from threading import Thread
 
-from lollypop.define import Lp
+from lollypop.define import Lp, SecretSchema, SecretAttributes, Type
 from lollypop.cache import InfoCache
 from lollypop.database import Database
 from lollypop.touch_helper import TouchHelper
 from lollypop.database_history import History
 from lollypop.utils import get_network_available
+from lollypop.lio import Lio
 from lollypop.helper_dbus import DBusHelper
 
 
@@ -74,6 +81,17 @@ class SettingsDialog:
         self.__mix_tid = None
         self.__popover = None
 
+        cs_api_key = Lp().settings.get_value("cs-api-key").get_string()
+        default_cs_api_key = Lp().settings.get_default_value(
+                                                     "cs-api-key").get_string()
+        if (not cs_api_key or
+            cs_api_key == default_cs_api_key) and\
+                get_network_available() and\
+                Lp().notify is not None:
+            Lp().notify.send(
+                         _("Google Web Services need a custom API key"),
+                         _("Lollypop needs this to search artwork and music."))
+
         builder = Gtk.Builder()
         builder.add_from_resource("/org/gnome/Lollypop/SettingsDialog.ui")
         self.__progress = builder.get_object("progress")
@@ -125,7 +143,6 @@ class SettingsDialog:
 
         switch_mix = builder.get_object("switch_mix")
         switch_mix.set_state(Lp().settings.get_value("mix"))
-
         self.__helper = TouchHelper(switch_mix, None, None)
         self.__helper.set_long_func(self.__mix_long_func, switch_mix)
         self.__helper.set_short_func(self.__mix_short_func, switch_mix)
@@ -133,6 +150,9 @@ class SettingsDialog:
         switch_mix_party = builder.get_object("switch_mix_party")
         switch_mix_party.set_state(Lp().settings.get_value("party-mix"))
 
+        switch_librefm = builder.get_object("switch_librefm")
+        switch_librefm.set_state(Lp().settings.get_value("use-librefm"))
+
         switch_artwork_tags = builder.get_object("switch_artwork_tags")
         grid_behaviour = builder.get_object("grid_behaviour")
         # Check portal for kid3-cli
@@ -141,6 +161,13 @@ class SettingsDialog:
                          self.__on_can_set_cover,
                          (switch_artwork_tags, grid_behaviour))
 
+        if GLib.find_program_in_path("youtube-dl") is None or\
+                not Lp().settings.get_value("network-access"):
+            builder.get_object("charts_grid").hide()
+        else:
+            switch_charts = builder.get_object("switch_charts")
+            switch_charts.set_state(Lp().settings.get_value("show-charts"))
+
         switch_genres = builder.get_object("switch_genres")
         switch_genres.set_state(Lp().settings.get_value("show-genres"))
 
@@ -151,6 +178,15 @@ class SettingsDialog:
         switch_artwork = builder.get_object("switch_artwork")
         switch_artwork.set_state(Lp().settings.get_value("artist-artwork"))
 
+        switch_spotify = builder.get_object("switch_spotify")
+        switch_spotify.set_state(Lp().settings.get_value("search-spotify"))
+
+        switch_itunes = builder.get_object("switch_itunes")
+        switch_itunes.set_state(Lp().settings.get_value("search-itunes"))
+
+        if GLib.find_program_in_path("youtube-dl") is None:
+            builder.get_object("yt-dl").show()
+
         combo_orderby = builder.get_object("combo_orderby")
         combo_orderby.set_active(Lp().settings.get_enum(("orderby")))
 
@@ -202,35 +238,24 @@ class SettingsDialog:
         #
         # Google tab
         #
-        key = Lp().settings.get_value("cs-api-key").get_string() or\
-            Lp().settings.get_default_value("cs-api-key").get_string()
-        builder.get_object("cs-entry").set_text(key)
-
-        from lollypop.helper_passwords import PasswordsHelper
-        helper = PasswordsHelper()
+        builder.get_object("cs-entry").set_text(
+                            Lp().settings.get_value("cs-api-key").get_string())
         #
         # Last.fm tab
         #
-        if Lp().lastfm is not None:
-            self.__lastfm_test_image = builder.get_object("lastfm_test_image")
-            self.__lastfm_login = builder.get_object("lastfm_login")
-            self.__lastfm_password = builder.get_object("lastfm_password")
-            helper.get("lastfm",
-                       self.__on_get_password)
+        if Lp().lastfm is not None and Secret is not None:
+            self.__test_img = builder.get_object("test_img")
+            self.__login = builder.get_object("login")
+            self.__password = builder.get_object("password")
+            schema = Secret.Schema.new("org.gnome.Lollypop",
+                                       Secret.SchemaFlags.NONE,
+                                       SecretSchema)
+            Secret.password_lookup(schema, SecretAttributes, None,
+                                   self.__on_password_lookup)
             builder.get_object("lastfm_grid").set_sensitive(True)
-            builder.get_object("lastfm_error_label").hide()
-        #
-        # Libre.fm tab
-        #
-        if Lp().librefm is not None:
-            self.__librefm_test_image = builder.get_object(
-                                                          "librefm_test_image")
-            self.__librefm_login = builder.get_object("librefm_login")
-            self.__librefm_password = builder.get_object("librefm_password")
-            helper.get("librefm",
-                       self.__on_get_password)
-            builder.get_object("librefm_grid").set_sensitive(True)
-            builder.get_object("librefm_error_label").hide()
+            builder.get_object("lastfm_error").hide()
+            self.__login.set_text(
+                Lp().settings.get_value("lastfm-login").get_string())
 
     def show(self):
         """
@@ -301,6 +326,32 @@ class SettingsDialog:
         Lp().settings.set_value("show-genres",
                                 GLib.Variant("b", state))
 
+    def _update_charts_setting(self, widget, state):
+        """
+            Update show charts setting
+            @param widget as Gtk.Switch
+            @param state as bool
+        """
+        if Lp().settings.get_value("network-access"):
+            GLib.idle_add(Lp().window.add_remove_from,
+                          (Type.CHARTS, _("The charts"), ""),
+                          True,
+                          state)
+        if state:
+            if Lp().charts is None:
+                from lollypop.charts import Charts
+                Lp().charts = Charts()
+            if get_network_available():
+                Lp().charts.start()
+            elif Lp().notify is not None:
+                Lp().notify.send(_("The charts"),
+                                 _("Network access disabled"))
+        else:
+            Lp().charts.stop()
+            Lp().scanner.clean_charts()
+        Lp().settings.set_value("show-charts",
+                                GLib.Variant("b", state))
+
     def _update_mix_setting(self, widget, state):
         """
             Update mix setting
@@ -326,6 +377,16 @@ class SettingsDialog:
         Lp().settings.set_value("party-mix", GLib.Variant("b", state))
         Lp().player.update_crossfading()
 
+    def _update_librefm_setting(self, widget, state):
+        """
+            Update librefm setting
+            @param widget as Gtk.Range
+        """
+        from lollypop.lastfm import LastFM
+        Lp().settings.set_value("use-librefm", GLib.Variant("b", state))
+        # Reset lastfm object
+        Lp().lastfm = LastFM()
+
     def _update_mix_duration_setting(self, widget):
         """
             Update mix duration setting
@@ -370,36 +431,48 @@ class SettingsDialog:
         """
         Lp().settings.set_enum("orderby", widget.get_active())
 
-    def _update_fm_settings(self, name):
+    def _update_spotify_setting(self, widget, state):
+        """
+            Update search on spotify setting
+            @param widget as Gtk.Switch
+            @param state as bool
+        """
+        Lp().settings.set_value("search-spotify", GLib.Variant("b", state))
+
+    def _update_itunes_setting(self, widget, state):
+        """
+            Update search on spotify setting
+            @param widget as Gtk.Switch
+            @param state as bool
+        """
+        Lp().settings.set_value("search-itunes", GLib.Variant("b", state))
+
+    def _update_lastfm_settings(self, sync=False):
         """
             Update lastfm settings
-            @param name as str (librefm/lastfm)
-        """
-        fm = None
-        if name == "librefm" and Lp().librefm is not None:
-            fm = Lp().librefm
-            callback = self.__test_librefm_connection
-            login = self.__librefm_login.get_text()
-            password = self.__librefm_password.get_text()
-        elif Lp().lastfm is not None:
-            fm = Lp().lastfm
-            callback = self.__test_lastfm_connection
-            login = self.__lastfm_login.get_text()
-            password = self.__lastfm_password.get_text()
+            @param sync as bool
+        """
         try:
-            if fm is not None and login and password:
-                from lollypop.helper_passwords import PasswordsHelper
-                helper = PasswordsHelper()
-                helper.clear(name,
-                             helper.store,
-                             name,
-                             login,
-                             password,
-                             self.__on_password_store,
-                             fm,
-                             callback)
+            if Lp().lastfm is not None and Secret is not None:
+                schema = Secret.Schema.new("org.gnome.Lollypop",
+                                           Secret.SchemaFlags.NONE,
+                                           SecretSchema)
+                Secret.password_store_sync(schema, SecretAttributes,
+                                           Secret.COLLECTION_DEFAULT,
+                                           "org.gnome.Lollypop"
+                                           ".lastfm.login %s" %
+                                           self.__login.get_text(),
+                                           self.__password.get_text(),
+                                           None)
+                Lp().settings.set_value("lastfm-login",
+                                        GLib.Variant("s",
+                                                     self.__login.get_text()))
+                if sync:
+                    Lp().lastfm.connect_sync(self.__password.get_text())
+                else:
+                    Lp().lastfm.connect(self.__password.get_text())
         except Exception as e:
-            print("Settings::_update_fm_settings(): %s" % e)
+            print("Settings::_update_lastfm_settings(): %s" % e)
 
     def _on_cs_api_changed(self, entry):
         """
@@ -438,29 +511,19 @@ class SettingsDialog:
         if event.keyval == Gdk.KEY_Escape:
             self.__settings_dialog.destroy()
 
-    def _on_lastfm_test_btn_clicked(self, button):
+    def _on_test_btn_clicked(self, button):
         """
             Test lastfm connection
             @param button as Gtk.Button
         """
-        self._update_fm_settings("lastfm")
-        if not get_network_available():
-            self.__lastfm_test_image.set_from_icon_name(
-                                               "computer-fail-symbolic",
-                                               Gtk.IconSize.MENU)
-            return
-
-    def _on_librefm_test_btn_clicked(self, button):
-        """
-            Test librefm connection
-            @param button as Gtk.Button
-        """
-        self._update_fm_settings("librefm")
+        self._update_lastfm_settings(True)
         if not get_network_available():
-            self.__librefm_test_image.set_from_icon_name(
-                                               "computer-fail-symbolic",
+            self.__test_img.set_from_icon_name("computer-fail-symbolic",
                                                Gtk.IconSize.MENU)
             return
+        t = Thread(target=self.__test_lastfm_connection)
+        t.daemon = True
+        t.start()
 
     def _hide_popover(self, widget):
         """
@@ -496,6 +559,8 @@ class SettingsDialog:
             self.__reset_button.get_toplevel().set_deletable(False)
             self.__reset_button.set_sensitive(False)
             self.__infobar.hide()
+            if Lp().charts is not None:
+                Lp().charts.stop()
             self.__reset_database(track_ids, len(track_ids), history)
         except Exception as e:
             print("Application::_on_confirm_button_clicked():", e)
@@ -598,6 +663,13 @@ class SettingsDialog:
         previous = Lp().settings.get_value("music-uris")
         Lp().settings.set_value("music-uris", GLib.Variant("as", uris))
 
+        # Last.fm
+        try:
+            if not Lp().lastfm.is_goa:
+                self._update_lastfm_settings()
+        except:
+            pass
+
         self.__settings_dialog.hide()
         self.__settings_dialog.destroy()
         if set(previous) != set(uris):
@@ -605,44 +677,20 @@ class SettingsDialog:
         if Lp().window.view is not None:
             Lp().window.view.update_children()
 
-    def __test_lastfm_connection(self, result):
+    def __test_lastfm_connection(self):
         """
             Test lastfm connection
-            @param result as None
+            @thread safe
         """
         if Lp().lastfm.session_key:
-            self.__lastfm_test_image.set_from_icon_name(
+            GLib.idle_add(self.__test_img.set_from_icon_name,
                           "object-select-symbolic",
                           Gtk.IconSize.MENU)
         else:
-            self.__lastfm_test_image.set_from_icon_name(
+            GLib.idle_add(self.__test_img.set_from_icon_name,
                           "computer-fail-symbolic",
                           Gtk.IconSize.MENU)
 
-    def __test_librefm_connection(self, result):
-        """
-            Test librefm connection
-            @param result as None
-        """
-        if Lp().librefm.session_key:
-            self.__librefm_test_image.set_from_icon_name(
-                          "object-select-symbolic",
-                          Gtk.IconSize.MENU)
-        else:
-            self.__librefm_test_image.set_from_icon_name(
-                          "computer-fail-symbolic",
-                          Gtk.IconSize.MENU)
-
-    def __on_password_store(self, source, result, fm, callback):
-        """
-            Connect service
-            @param source as GObject.Object
-            @param result as Gio.AsyncResult
-            @param fm as LastFM
-            @param callback as function
-        """
-        fm.connect(True, callback)
-
     def __on_pa_list_sinks(self, source, result, combo):
         """
             Populate combo
@@ -691,21 +739,20 @@ class SettingsDialog:
             switch_artwork_tags.set_state(
                                        Lp().settings.get_value("save-to-tags"))
 
-    def __on_get_password(self, attributes, password, name):
+    def __on_password_lookup(self, source, result):
         """
-             Set password label
-             @param attributes as {}
-             @param password as str
-             @param name as str
+            Set password entry
+            @param source as GObject.Object
+            @param result Gio.AsyncResult
         """
-        if attributes is None:
-            return
-        if name == "librefm":
-            self.__librefm_login.set_text(attributes["login"])
-            self.__librefm_password.set_text(password)
-        else:
-            self.__lastfm_login.set_text(attributes["login"])
-            self.__lastfm_password.set_text(password)
+        try:
+            password = None
+            if result is not None:
+                password = Secret.password_lookup_finish(result)
+            if password is not None:
+                self.__password.set_text(password)
+        except:
+            pass
 
     def __reset_database(self, track_ids, count, history):
         """
@@ -717,13 +764,13 @@ class SettingsDialog:
         if track_ids:
             track_id = track_ids.pop(0)
             uri = Lp().tracks.get_uri(track_id)
-            f = Gio.File.new_for_uri(uri)
+            f = Lio.File.new_for_uri(uri)
             name = f.get_basename()
             album_id = Lp().tracks.get_album_id(track_id)
             popularity = Lp().tracks.get_popularity(track_id)
             rate = Lp().tracks.get_rate(track_id)
             ltime = Lp().tracks.get_ltime(track_id)
-            mtime = Lp().tracks.get_mtime(track_id)
+            mtime = Lp().albums.get_mtime(album_id)
             duration = Lp().tracks.get_duration(track_id)
             loved = Lp().albums.get_loved(album_id)
             album_popularity = Lp().albums.get_popularity(album_id)
@@ -741,6 +788,8 @@ class SettingsDialog:
             Lp().window.show_genres(Lp().settings.get_value("show-genres"))
             Lp().window.update_db()
             self.__progress.get_toplevel().set_deletable(True)
+            if Lp().charts is not None and get_network_available():
+                Lp().charts.start()
 
 
 class ChooserWidget(Gtk.Grid):
diff --git a/lollypop/sync_mtp.py b/lollypop/sync_mtp.py
index d7cac868..9b7a8821 100644
--- a/lollypop/sync_mtp.py
+++ b/lollypop/sync_mtp.py
@@ -19,7 +19,7 @@ import json
 from lollypop.utils import escape, debug
 from lollypop.define import Lp, Type
 from lollypop.objects import Track
-
+from lollypop.lio import Lio
 
 class MtpSyncDb:
     """
@@ -33,7 +33,6 @@ class MtpSyncDb:
         It also implements the context manager interface, ensuring database is
         loaded before entering the scope and saving it when exiting.
     """
-
     def __init__(self, base_uri):
         """
             Constructor for MtpSyncDb
@@ -48,8 +47,7 @@ class MtpSyncDb:
             Get mtime for a uri on MTP device from the metadata db
             @param uri as str
         """
-        return self.__metadata.get(
-                           self.__get_reluri(uri), {}).get("time::modified", 0)
+        return self.__metadata.get(self._get_reluri(uri), {}).get("time::modified", 0)
 
     def set_mtime(self, uri, mtime):
         """
@@ -57,21 +55,17 @@ class MtpSyncDb:
             @param uri as str
             @param mtime as int
         """
-        self.__metadata.setdefault(self.__get_reluri(uri),
-                                   dict())["time::modified"] = mtime
+        self.__metadata.setdefault(self._get_reluri(uri), dict())["time::modified"] = mtime
 
     def delete_uri(self, uri):
         """
             Deletes metadata for a uri from the on-device metadata db
             @param uri as str
         """
-        if self.__get_reluri(uri) in self.__metadata:
-            del self.__metadata[self.__get_reluri(uri)]
+        if self._get_reluri(uri) in self.__metadata:
+            del self.__metadata[self._get_reluri(uri)]
 
-############
-# Private  #
-############
-    def __get_reluri(self, uri):
+    def _get_reluri(self, uri):
         """
             Returns a relative on-device uri from an absolute on-device.
             We do not want to store absolute uri in the db as the same
@@ -83,15 +77,15 @@ class MtpSyncDb:
             uri = uri[len(self.__base_uri) + 1:]
         return uri
 
-    def __load_db(self):
+    def _load_db(self):
         """
             Loads the metadata db from the MTP device
         """
-        debug("MtpSyncDb::__load_db()")
-        dbfile = Gio.File.new_for_uri(self.__db_uri)
+        debug("MtpSyncDb::_load_db()")
+        dbfile = Lio.File.new_for_uri(self.__db_uri)
         ok, jsonraw, _ = dbfile.load_contents(None)
         if not ok:
-            debug("MtpSyncDb::__load_db() sync db is absent")
+            debug("MtpSyncDb::_load_db() sync db is absent")
             return
         try:
             jsondb = json.loads(jsonraw.decode("utf-8"))
@@ -99,41 +93,33 @@ class MtpSyncDb:
                 for m in jsondb["tracks_metadata"]:
                     self.__metadata[m["uri"]] = m["metadata"]
             else:
-                print("MtpSyncDb::__load_db() unknown sync db version")
+                print("MtpSyncDb::_load_db() unknown sync db version")
         except Exception as e:
-            print("MtpSyncDb::__load_db() sync db is invalid : %s" % e)
+            print("MtpSyncDb::_load_db() sync db is invalid : %s" % e)
 
-    def __save_db(self):
+    def _save_db(self):
         """
             Saves the metadata db to the MTP device
         """
-        debug("MtpSyncDb::__save_db()")
-        jsondb = json.dumps({"version": 1,
-                             "tracks_metadata": [
-                                {"uri": x, "metadata": y}
-                                for x, y in sorted(self.__metadata.items())]})
-        dbfile = Gio.File.new_for_uri(self.__db_uri)
-        ok, _ = dbfile.replace_contents(
-                                    jsondb.encode("utf-8"),
-                                    None, False,
-                                    Gio.FileCreateFlags.REPLACE_DESTINATION,
-                                    None)
+        debug("MtpSyncDb::_save_db()")
+        jsondb = json.dumps({"version": 1, "tracks_metadata": [{"uri": x, "metadata": y} for x, y in sorted(self.__metadata.items())]})
+        dbfile = Lio.File.new_for_uri(self.__db_uri)
+        ok, _ = dbfile.replace_contents(jsondb.encode("utf-8"), None, False, Gio.FileCreateFlags.REPLACE_DESTINATION, None)
         if not ok:
-            print("MtpSyncDb::__save_db() failed")
+            print("MtpSyncDb::_save_db() failed")
 
     def __enter__(self):
         """
             Context manager implementation
         """
-        self.__load_db()
+        self._load_db()
         return self
 
     def __exit__(self, *args):
         """
             Context manager implementation
         """
-        self.__save_db()
-
+        self._save_db()
 
 # TODO Rework this code: was designed
 # for playlists and then for albums, it sucks!
@@ -238,7 +224,7 @@ class MtpSync:
             self.__remove_empty_dirs()
 
             # Remove old playlists
-            d = Gio.File.new_for_uri(self._uri)
+            d = Lio.File.new_for_uri(self._uri)
             infos = d.enumerate_children(
                 "standard::name",
                 Gio.FileQueryInfoFlags.NOFOLLOW_SYMLINKS,
@@ -249,7 +235,7 @@ class MtpSync:
                     f = infos.get_child(info)
                     self.__retry(f.delete, (None,))
 
-            d = Gio.File.new_for_uri(self._uri+"/unsync")
+            d = Lio.File.new_for_uri(self._uri+"/unsync")
             if not d.query_exists():
                 self.__retry(d.make_directory_with_parents, (None,))
         except Exception as e:
@@ -297,7 +283,7 @@ class MtpSync:
             # First get all directories
             while dir_uris:
                 uri = dir_uris.pop(0)
-                d = Gio.File.new_for_uri(uri)
+                d = Lio.File.new_for_uri(uri)
                 infos = d.enumerate_children(
                     "standard::name,standard::type",
                     Gio.FileQueryInfoFlags.NOFOLLOW_SYMLINKS,
@@ -307,7 +293,7 @@ class MtpSync:
                         if info.get_name() != "unsync":
                             f = infos.get_child(info)
                             # We need to check for dir to be empty
-                            # On some device, Gio.File.delete() remove
+                            # On some device, Lio.File.delete() remove
                             # non empty directories #828
                             subinfos = f.enumerate_children(
                                     "standard::name,standard::type",
@@ -322,7 +308,7 @@ class MtpSync:
                                 to_delete.append(f.get_uri())
             # Then delete
             for d in to_delete:
-                d = Gio.File.new_for_uri(d)
+                d = Lio.File.new_for_uri(d)
                 try:
                     d.delete()
                 except:
@@ -337,13 +323,13 @@ class MtpSync:
         """
         children = []
         dir_uris = [self._uri]
-        d = Gio.File.new_for_uri(self._uri)
+        d = Lio.File.new_for_uri(self._uri)
         if not d.query_exists():
             self.__retry(d.make_directory_with_parents, (None,))
         while dir_uris:
             try:
                 uri = dir_uris.pop(0)
-                d = Gio.File.new_for_uri(uri)
+                d = Lio.File.new_for_uri(uri)
                 infos = d.enumerate_children(
                     "standard::name,standard::type",
                     Gio.FileQueryInfoFlags.NOFOLLOW_SYMLINKS,
@@ -375,7 +361,7 @@ class MtpSync:
                 try:
                     playlist_name = Lp().playlists.get_name(playlist)
                     # Create playlist
-                    m3u = Gio.File.new_for_path(
+                    m3u = Lio.File.new_for_path(
                         "/tmp/lollypop_%s.m3u" % (playlist_name,))
                     self.__retry(m3u.replace_contents, (b"#EXTM3U\n", None,
                                  False,
@@ -417,24 +403,24 @@ class MtpSync:
                                            artists,
                                            album_name)
 
-                d = Gio.File.new_for_uri(on_device_album_uri)
+                d = Lio.File.new_for_uri(on_device_album_uri)
                 if not d.query_exists():
                     self.__retry(d.make_directory_with_parents, (None,))
                 # Copy album art
                 art = Lp().art.get_album_artwork_uri(track.album)
                 debug("MtpSync::__copy_to_device(): %s" % art)
                 if art is not None:
-                    src_art = Gio.File.new_for_uri(art)
+                    src_art = Lio.File.new_for_uri(art)
                     art_uri = "%s/cover.jpg" % on_device_album_uri
                     # To be sure to get uri correctly escaped for Gio
-                    f = Gio.File.new_for_uri(art_uri)
+                    f = Lio.File.new_for_uri(art_uri)
                     self.__copied_art_uris.append(f.get_uri())
-                    dst_art = Gio.File.new_for_uri(art_uri)
+                    dst_art = Lio.File.new_for_uri(art_uri)
                     if not dst_art.query_exists():
                         self.__retry(src_art.copy,
                                      (dst_art, Gio.FileCopyFlags.OVERWRITE,
                                       None, None))
-                f = Gio.File.new_for_uri(track.uri)
+                f = Lio.File.new_for_uri(track.uri)
                 track_name = escape(f.get_basename())
                 # Check extension, if not mp3, convert
                 m = match(".*(\.[^.]*)", track.uri)
@@ -444,14 +430,14 @@ class MtpSync:
                     track_name = track_name.replace(ext, ".mp3")
                 else:
                     convertion_needed = False
-                src_track = Gio.File.new_for_uri(track.uri)
+                src_track = Lio.File.new_for_uri(track.uri)
                 info = src_track.query_info("time::modified",
                                             Gio.FileQueryInfoFlags.NONE,
                                             None)
                 # Prefix track with mtime to make sure updating it later
                 mtime = info.get_attribute_uint64("time::modified")
                 dst_uri = "%s/%s" % (on_device_album_uri,
-                                     track_name)
+                                        track_name)
                 if stream is not None:
                     if is_compilation:
                         line = "%s/%s\n" %\
@@ -464,13 +450,11 @@ class MtpSync:
                                  track_name)
                     self.__retry(stream.get_output_stream().write,
                                  (line.encode(encoding="UTF-8"), None))
-                dst_track = Gio.File.new_for_uri(dst_uri)
-                if not dst_track.query_exists() or\
-                        self.__mtpmetadata.get_mtime(
-                                                  dst_track.get_uri()) < mtime:
+                dst_track = Lio.File.new_for_uri(dst_uri)
+                if not dst_track.query_exists() or self.__mtpmetadata.get_mtime(dst_track.get_uri()) < mtime:
                     if convertion_needed:
                         mp3_uri = "file:///tmp/%s" % track_name
-                        mp3_file = Gio.File.new_for_uri(mp3_uri)
+                        mp3_file = Lio.File.new_for_uri(mp3_uri)
                         pipeline = self.__convert_to_mp3(src_track, mp3_file)
                         # Check if encoding is finished
                         if pipeline is not None:
@@ -506,7 +490,7 @@ class MtpSync:
                 stream.close()
             if m3u is not None:
                 playlist_name = escape(playlist_name)
-                dst = Gio.File.new_for_uri(self._uri+"/"+playlist_name+".m3u")
+                dst = Lio.File.new_for_uri(self._uri+"/"+playlist_name+".m3u")
                 self.__retry(m3u.move,
                              (dst, Gio.FileCopyFlags.OVERWRITE, None, None))
 
@@ -545,16 +529,20 @@ class MtpSync:
                 on_device_album_uri = "%s/%s_%s" % (self._uri,
                                                     artists,
                                                     album_name)
-            f = Gio.File.new_for_uri(track.uri)
+            f = Lio.File.new_for_uri(track.uri)
             track_name = escape(f.get_basename())
             # Check extension, if not mp3, convert
             m = match(".*(\.[^.]*)", track.uri)
             ext = m.group(1)
             if ext != ".mp3" and self.__convert:
                 track_name = track_name.replace(ext, ".mp3")
+            on_disk = Lio.File.new_for_uri(track.uri)
+            info = on_disk.query_info("time::modified",
+                                      Gio.FileQueryInfoFlags.NONE,
+                                      None)
             dst_uri = "%s/%s" % (on_device_album_uri, track_name)
             # To be sure to get uri correctly escaped for Gio
-            f = Gio.File.new_for_uri(dst_uri)
+            f = Lio.File.new_for_uri(dst_uri)
             track_uris.append(f.get_uri())
 
         on_mtp_files = self.__get_track_files()
@@ -568,7 +556,7 @@ class MtpSync:
             debug("MtpSync::__remove_from_device(): %s" % uri)
             if uri not in track_uris and uri not in self.__copied_art_uris:
                 debug("MtpSync::__remove_from_device(): deleting %s" % uri)
-                to_delete = Gio.File.new_for_uri(uri)
+                to_delete = Lio.File.new_for_uri(uri)
                 self.__retry(to_delete.delete, (None,))
                 self.__mtpmetadata.delete_uri(uri)
             self.__done += 1
diff --git a/lollypop/tagreader.py b/lollypop/tagreader.py
index af4ab6f9..551a9d30 100644
--- a/lollypop/tagreader.py
+++ b/lollypop/tagreader.py
@@ -10,7 +10,7 @@
 # You should have received a copy of the GNU General Public License
 # along with this program. If not, see <http://www.gnu.org/licenses/>.
 
-from gi.repository import Gst, GstPbutils, GLib, Gio
+from gi.repository import Gst, GstPbutils, GLib
 
 from re import match
 
@@ -18,6 +18,7 @@ from gettext import gettext as _
 
 from lollypop.define import Lp
 from lollypop.utils import format_artist_name, decode_all
+from lollypop.lio import Lio
 
 
 class Discoverer:
@@ -252,7 +253,7 @@ class TagReader(Discoverer):
                     tracknumber = 0
             else:
                 tracknumber = 0
-        return min(abs(tracknumber), GLib.MAXINT32)
+        return tracknumber
 
     def get_year(self, tags):
         """
@@ -460,7 +461,7 @@ class TagReader(Discoverer):
         return genre_ids
 
     def add_album(self, album_name, artist_ids,
-                  uri, loved, popularity, rate, mtime):
+                  uri, loved, popularity, rate, remote):
         """
             Add album to db
             @param album name as string
@@ -470,34 +471,35 @@ class TagReader(Discoverer):
             @param loved as bool
             @param popularity as int
             @param rate as int
-            @param mtime as int
+            @param remote as bool
             @return (album id as int, new as bool)
             @commit needed
         """
-        f = Gio.File.new_for_uri(uri)
+        f = Lio.File.new_for_uri(uri)
         d = f.get_parent()
         if d is not None:
             parent_uri = d.get_uri()
         else:
             parent_uri = ""
         new = False
-        album_id = Lp().albums.get_id(album_name, artist_ids)
+        album_id = Lp().albums.get_id(album_name, artist_ids, remote)
         if album_id is None:
             new = True
             album_id = Lp().albums.add(album_name, artist_ids, parent_uri,
-                                       loved, popularity, rate, mtime)
+                                       loved, popularity, rate)
         # Now we have our album id, check if path doesn"t change
         if Lp().albums.get_uri(album_id) != parent_uri:
             Lp().albums.set_uri(album_id, parent_uri)
 
         return (album_id, new)
 
-    def update_album(self, album_id, artist_ids, genre_ids, year):
+    def update_album(self, album_id, artist_ids, genre_ids, mtime, year):
         """
             Set album artists
             @param album id as int
             @param artist ids as [int]
             @param genre ids as [int]
+            @param mtime as int
             @param year as int
             @commit needed
         """
@@ -508,13 +510,13 @@ class TagReader(Discoverer):
                                     Lp().albums.calculate_artist_ids(album_id))
         # Update album genres
         for genre_id in genre_ids:
-            Lp().albums.add_genre(album_id, genre_id)
+            Lp().albums.add_genre(album_id, genre_id, mtime)
 
         # Update year based on tracks
         year = Lp().albums.get_year_from_tracks(album_id)
         Lp().albums.set_year(album_id, year)
 
-    def update_track(self, track_id, artist_ids, genre_ids):
+    def update_track(self, track_id, artist_ids, genre_ids, mtime):
         """
             Set track artists/genres
             @param track id as int
@@ -528,4 +530,4 @@ class TagReader(Discoverer):
         for artist_id in artist_ids:
             Lp().tracks.add_artist(track_id, artist_id)
         for genre_id in genre_ids:
-            Lp().tracks.add_genre(track_id, genre_id)
+            Lp().tracks.add_genre(track_id, genre_id, mtime)
diff --git a/lollypop/toolbar_info.py b/lollypop/toolbar_info.py
index c794668a..c5a36e3a 100644
--- a/lollypop/toolbar_info.py
+++ b/lollypop/toolbar_info.py
@@ -110,6 +110,7 @@ class ToolbarInfo(Gtk.Bin, InfoController):
                                        self._artsize,
                                        self._cover.get_scale_factor())
             self._cover.set_from_surface(surface)
+            del surface
 
     def __update_logo(self, art, name):
         """
@@ -120,6 +121,7 @@ class ToolbarInfo(Gtk.Bin, InfoController):
         if Lp().player.current_track.album_artist == name:
             pixbuf = Lp().art.get_radio_artwork(name, self._artsize)
             self._cover.set_from_surface(pixbuf)
+            del pixbuf
 
     def __on_info_long(self, args):
         """
diff --git a/lollypop/tunein.py b/lollypop/tunein.py
new file mode 100644
index 00000000..d2929738
--- /dev/null
+++ b/lollypop/tunein.py
@@ -0,0 +1,62 @@
+# Copyright (c) 2014-2017 Cedric Bellegarde <cedric.bellegarde@adishatz.org>
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+# GNU General Public License for more details.
+# You should have received a copy of the GNU General Public License
+# along with this program. If not, see <http://www.gnu.org/licenses/>.
+
+import xml.etree.ElementTree as xml
+
+from lollypop.utils import get_network_available
+from lollypop.lio import Lio
+
+
+class TuneItem:
+    TEXT = ""
+    URL = ""
+    LOGO = ""
+
+
+class TuneIn:
+    """
+        Get radios from Tune in
+    """
+
+    def __init__(self):
+        """
+            Init tunein
+        """
+        pass
+
+    def get_items(self, url):
+        """
+            Get radio entries for uri
+            @param uri as string
+        """
+        items = []
+        if not get_network_available():
+            raise
+        f = Lio.File.new_for_uri(url)
+        (status, data, tag) = f.load_contents()
+        if not status:
+            raise
+        root = xml.fromstring(data)
+        for child in root.iter("outline"):
+            try:
+                item = TuneItem()
+                item.URL = child.attrib["URL"]
+                item.TEXT = child.attrib["text"]
+                try:
+                    item.LOGO = child.attrib["image"]
+                except:
+                    pass
+                item.TYPE = child.attrib["type"]
+                items.append(item)
+            except:
+                del item
+        return items
diff --git a/lollypop/utils.py b/lollypop/utils.py
index d620c986..ea9d41cd 100644
--- a/lollypop/utils.py
+++ b/lollypop/utils.py
@@ -13,11 +13,12 @@
 from gi.repository import Gio, GLib
 
 from gettext import gettext as _
+from threading import Thread
 import unicodedata
 
-from lollypop.helper_task import TaskHelper
 from lollypop.define import Lp, Type, ENCODING
 from lollypop.objects import Track
+from lollypop.lio import Lio
 
 
 def decode_all(bytes):
@@ -83,7 +84,7 @@ def is_gnome():
     """
         Return True if desktop is Gnome
     """
-    return GLib.getenv("XDG_CURRENT_DESKTOP") in ["ubuntu:GNOME", "GNOME"]
+    return GLib.getenv("XDG_CURRENT_DESKTOP") == "GNOME"
 
 
 def is_audio(f):
@@ -177,7 +178,7 @@ def is_readonly(uri):
     """
         Check if uri is readonly
     """
-    f = Gio.File.new_for_uri(uri)
+    f = Lio.File.new_for_uri(uri)
     info = f.query_info("access::can-write",
                         Gio.FileQueryInfoFlags.NONE,
                         None)
@@ -198,7 +199,7 @@ def remove_static_genres(genre_ids):
         Remove static genre ids
         @param genre ids as [int]
     """
-    return [item for item in genre_ids if item >= 0]
+    return [item for item in genre_ids if item >= 0 or item == Type.CHARTS]
 
 
 def set_loved(track_id, loved):
@@ -212,15 +213,19 @@ def set_loved(track_id, loved):
             Lp().playlists.add_tracks(Type.LOVED,
                                       [Track(track_id)])
             if Lp().lastfm is not None:
-                helper = TaskHelper()
-                helper.run(_set_loved_on_lastfm, track_id, True)
+                t = Thread(target=_set_loved_on_lastfm, args=(track_id,
+                                                              True))
+                t.daemon = True
+                t.start()
     else:
         if not loved:
             Lp().playlists.remove_tracks(Type.LOVED,
                                          [Track(track_id)])
             if Lp().lastfm is not None:
-                helper = TaskHelper()
-                helper.run(_set_loved_on_lastfm, track_id, False)
+                t = Thread(target=_set_loved_on_lastfm, args=(track_id,
+                                                              False))
+                t.daemon = True
+                t.start()
 
 
 def _set_loved_on_lastfm(track_id, loved):
diff --git a/lollypop/view_artist.py b/lollypop/view_artist.py
index 6505a154..44bbcdee 100644
--- a/lollypop/view_artist.py
+++ b/lollypop/view_artist.py
@@ -23,6 +23,7 @@ from lollypop.pop_info import InfoPopover
 from lollypop.cache import InfoCache
 from lollypop.pop_artwork import ArtworkPopover
 from lollypop.view_artist_albums import ArtistAlbumsView
+from lollypop.lio import Lio
 
 
 class ArtistView(ArtistAlbumsView):
@@ -241,6 +242,7 @@ class ArtistView(ArtistAlbumsView):
                                                          pixbuf,
                                                          self.__scale_factor,
                                                          None)
+            del pixbuf
         else:
             surface = image.props.surface
 
@@ -293,13 +295,10 @@ class ArtistView(ArtistAlbumsView):
                 for suffix in ["lastfm", "spotify", "wikipedia"]:
                     uri = InfoCache.get_artwork(artist, suffix, size)
                     if uri is not None:
-                        f = Gio.File.new_for_path(uri)
+                        f = Lio.File.new_for_path(uri)
                         (status, data, tag) = f.load_contents(None)
-                        if not status:
-                            continue
-                        bytes = GLib.Bytes(data)
-                        stream = Gio.MemoryInputStream.new_from_bytes(bytes)
-                        bytes.unref()
+                        stream = Gio.MemoryInputStream.new_from_data(data,
+                                                                     None)
                         pixbuf = GdkPixbuf.Pixbuf.new_from_stream_at_scale(
                                                                        stream,
                                                                        size,
@@ -309,7 +308,9 @@ class ArtistView(ArtistAlbumsView):
                         stream.close()
                         surface = Gdk.cairo_surface_create_from_pixbuf(
                                             pixbuf, self.__scale_factor, None)
+                        del pixbuf
                         self.__artwork.set_from_surface(surface)
+                        del surface
                         artwork_height = ArtSize.ARTIST_SMALL * 2
                         self.__artwork.get_style_context().remove_class(
                                                                 "artwork-icon")
diff --git a/lollypop/view_device.py b/lollypop/view_device.py
index 0f04d08e..db1b178d 100644
--- a/lollypop/view_device.py
+++ b/lollypop/view_device.py
@@ -18,6 +18,7 @@ import re
 from lollypop.view import View
 from lollypop.define import Lp
 from lollypop.widgets_device import DeviceManagerWidget
+from lollypop.lio import Lio
 
 
 class DeviceLocked(View):
@@ -45,7 +46,7 @@ class DeviceView(View):
             @param uri as str
             @return bool
         """
-        d = Gio.File.new_for_uri(uri+"/Music/lollypop/tracks")
+        d = Lio.File.new_for_uri(uri+"/Music/lollypop/tracks")
         return d.query_exists()
 
     def get_files(uri):
@@ -56,7 +57,7 @@ class DeviceView(View):
         """
         files = []
         try:
-            d = Gio.File.new_for_uri(uri)
+            d = Lio.File.new_for_uri(uri)
             if not d.query_exists():
                 d.make_directory_with_parents()
             infos = d.enumerate_children(
@@ -69,7 +70,7 @@ class DeviceView(View):
                 f = infos.get_child(info)
                 # We look to this folder to select an already synced uri
                 suburi = f.get_uri() + "/Music/unsync"
-                sub = Gio.File.new_for_uri(suburi)
+                sub = Lio.File.new_for_uri(suburi)
                 if sub.query_exists():
                     files.insert(0, info.get_name())
                 else:
diff --git a/lollypop/view_playlists.py b/lollypop/view_playlists.py
index 499e2d32..7aecfe2a 100644
--- a/lollypop/view_playlists.py
+++ b/lollypop/view_playlists.py
@@ -78,6 +78,7 @@ class PlaylistsView(View):
     def populate(self, tracks):
         """
             Populate view with tracks from playlist
+            Thread safe
         """
         # We are looking for middle
         # Ponderate with this:
diff --git a/lollypop/view_radios.py b/lollypop/view_radios.py
index d984da34..67caf2b7 100644
--- a/lollypop/view_radios.py
+++ b/lollypop/view_radios.py
@@ -12,7 +12,8 @@
 
 from gi.repository import Gtk, GLib
 
-from lollypop.helper_task import TaskHelper
+from threading import Thread
+
 from lollypop.view import LazyLoadingView
 from lollypop.widgets_radio import RadioWidget
 from lollypop.radios import Radios
@@ -71,13 +72,15 @@ class RadiosView(LazyLoadingView):
     def populate(self):
         """
             Populate view with tracks from playlist
+            Thread safe
         """
         Lp().player.set_radios(self.__radios_manager.get())
         if Lp().player.current_track.id == Type.RADIOS:
             Lp().player.set_next()  # We force next update
             Lp().player.set_prev()  # We force prev update
-        helper = TaskHelper()
-        helper.run(self.__get_radios, callback=(self.__on_get_radios,))
+        t = Thread(target=self.__populate)
+        t.daemon = True
+        t.start()
 
 #######################
 # PROTECTED           #
@@ -121,16 +124,16 @@ class RadiosView(LazyLoadingView):
 #######################
 # PRIVATE             #
 #######################
-    def __get_radios(self):
+    def __populate(self):
         """
-            Get radios
-            @return [name]
+            Populate view with tracks from playlist
+            Thread safe
         """
         radios = []
         # Get radios name
         for (name, url) in self.__radios_manager.get():
             radios.append(name)
-        return radios
+        GLib.idle_add(self.__show_stack, radios)
 
     def __on_radios_changed(self, manager):
         """
@@ -183,6 +186,16 @@ class RadiosView(LazyLoadingView):
             Lp().player.set_next()  # We force next update
             Lp().player.set_prev()  # We force prev update
 
+    def __on_logo_changed(self, player, name):
+        """
+            Update radio logo
+            @param player as Plyaer
+            @param name as string
+        """
+        for child in self._box.get_children():
+            if child.title == name:
+                child.update_cover()
+
     def __show_stack(self, radios):
         """
             Switch empty/radios view based on radios
@@ -220,24 +233,3 @@ class RadiosView(LazyLoadingView):
             GLib.idle_add(self.lazy_loading)
             if self._viewport.get_child() is None:
                 self._viewport.add(self._box)
-
-    def __on_logo_changed(self, player, name):
-        """
-            Update radio logo
-            @param player as Plyaer
-            @param name as string
-        """
-        for child in self._box.get_children():
-            if child.title == name:
-                child.update_cover()
-
-    def __on_get_radios(self, radios):
-        """
-            Switch empty/radios view based on radios
-            @param [radio names as string]
-        """
-        if radios:
-            self.__stack.set_visible_child(self._scrolled)
-            self.__add_radios(radios, True)
-        else:
-            self.__stack.set_visible_child(self.__empty)
diff --git a/lollypop/web.py b/lollypop/web.py
new file mode 100644
index 00000000..5c5f2997
--- /dev/null
+++ b/lollypop/web.py
@@ -0,0 +1,238 @@
+# Copyright (c) 2014-2017 Cedric Bellegarde <cedric.bellegarde@adishatz.org>
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+# GNU General Public License for more details.
+# You should have received a copy of the GNU General Public License
+# along with this program. If not, see <http://www.gnu.org/licenses/>.
+
+from gi.repository import GObject, GLib
+
+from threading import Thread
+
+from lollypop.sqlcursor import SqlCursor
+from lollypop.tagreader import TagReader
+from lollypop.web_youtube import WebYouTube
+# from lollypop.web_jgm90 import WebJmg90
+from lollypop.define import Lp, DbPersistent, Type
+from lollypop.lio import Lio
+
+
+class Web(GObject.Object):
+    """
+        Web helper
+    """
+
+    __gsignals__ = {
+        "saved": (GObject.SignalFlags.RUN_FIRST, None, (int,)),
+        "progress": (GObject.SignalFlags.RUN_FIRST, None, (float,))
+    }
+
+    def play_track(track, play, callback):
+        """
+            Play track
+            @param track as Track
+            @param play as bool
+            @param callback as func(uri: str, track: Track, play: bool)
+        """
+        # if track.is_jgm:
+        #    uri = WebJmg90.get_uri_content(track.uri)
+        # elif track.is_youtube:
+        uri = WebYouTube.get_uri_content(track.uri)
+        # else:
+        #    return
+        GLib.idle_add(callback, uri, track, play)
+
+    def __init__(self):
+        """
+            Init helper
+        """
+        GObject.Object.__init__(self)
+        self.__helpers = [WebYouTube()]
+
+    def save_track(self, item, persistent, genre_ids=[]):
+        """
+            Save item into collection as track
+            @param item as SearchItem
+            @param persistent as DbPersistent
+            @param genre ids as [int]
+        """
+        t = Thread(target=self.__save_track_thread,
+                   args=(item, persistent, genre_ids))
+        t.daemon = True
+        t.start()
+
+    def save_album(self, item, persistent, genre_ids=[]):
+        """
+            Save item into collection as album
+            @param item as SearchItem
+            @param persistent as DbPersistent
+            @param genre ids as [int]
+        """
+        t = Thread(target=self.save_album_thread,
+                   args=(item, persistent, genre_ids))
+        t.daemon = True
+        t.start()
+
+    def save_album_thread(self, item, persistent, genre_ids):
+        """
+            Save item into collection as album
+            @param item as SearchItem
+            @param persistent as DbPersistent
+            @param genre ids as [int]
+            @thread safe
+        """
+        nb_items = len(item.subitems)
+        # Should not happen but happen :-/
+        if nb_items == 0:
+            return
+        start = 0
+        album_artist = item.subitems[0].artists[0]
+        album_id = None
+        for track_item in item.subitems:
+            (album_id, track_id) = self.__save_track(track_item, persistent,
+                                                     album_artist, genre_ids)
+            if track_id is not None:
+                # Download cover
+                if start == 0:
+                    t = Thread(target=self.__save_cover, args=(item, album_id))
+                    t.daemon = True
+                    t.start()
+            start += 1
+            GLib.idle_add(self.emit, "progress", start / nb_items)
+        GLib.idle_add(self.emit, "progress", 1)
+        if Lp().settings.get_value("artist-artwork")and\
+                persistent != DbPersistent.CHARTS:
+            Lp().art.cache_artists_info()
+        if album_id is not None:
+            GLib.idle_add(self.emit, "saved", album_id)
+
+#######################
+# PRIVATE             #
+#######################
+    def __save_track_thread(self, item, persistent, genre_ids):
+        """
+            Save item into collection as track
+            @param item as SearchItem
+            @param persistent as DbPersistent
+            @param genre ids as [int]
+        """
+        album_artist = item.artists[0]
+        (album_id, track_id) = self.__save_track(item, persistent,
+                                                 album_artist, genre_ids)
+        if track_id is None:
+            return
+        self.__save_cover(item, album_id)
+        if Lp().settings.get_value("artist-artwork") and\
+                persistent != DbPersistent.CHARTS:
+            Lp().art.cache_artists_info()
+        GLib.idle_add(self.emit, "saved", track_id)
+
+    def __save_track(self, item, persistent, album_artist, genre_ids):
+        """
+            Save item into collection as track
+            @param item as SearchItem
+            @param persistent as DbPersistent
+            @param album artist as str
+            @param genre ids as [int]
+            @return (album id as int, track id as int)
+        """
+        t = TagReader()
+        # Get uri from helpers
+        for helper in self.__helpers:
+            uri = helper.get_uri(item)
+            if uri:
+                break
+
+        # Don"t found anything
+        if not uri:
+            return (None, None)
+
+        # If album exists, is not in charts and we want to save
+        # a charts track to this album, abort!
+        # User already saved this album to collection,
+        # may have removed some tracks, do not add them again!
+        (exists, album_id) = item.album.exists_in_db()
+        if exists:
+            album_genre_ids = Lp().albums.get_genre_ids(album_id)
+            if Type.CHARTS not in album_genre_ids and\
+                    persistent == DbPersistent.CHARTS:
+                        return (None, None)
+
+        # Check if track needs to be updated
+        (exists, track_id) = item.exists_in_db()
+        if exists:
+            if Lp().tracks.get_persistent(track_id) == DbPersistent.NONE\
+                    and persistent == DbPersistent.EXTERNAL:
+                Lp().tracks.set_persistent(track_id, DbPersistent.EXTERNAL)
+                return (None, None)
+            # Do not mark as charts any local/web track
+            track_genre_ids = Lp().tracks.get_genre_ids(track_id)
+            if Type.CHARTS in track_genre_ids:
+                album_id = Lp().tracks.get_album_id(track_id)
+                with SqlCursor(Lp().db) as sql:
+                    t.update_track(track_id, [], genre_ids, item.mtime)
+                    t.update_album(album_id, [], genre_ids, item.album.mtime,
+                                   None)
+                    sql.commit()
+                return (None, None)
+
+        with SqlCursor(Lp().db) as sql:
+            # Happen often with Itunes/Spotify
+            if album_artist not in item.artists:
+                item.artists.append(album_artist)
+            artists = "; ".join(item.artists)
+            artist_ids = t.add_artists(artists, album_artist, "")
+            album_artist_ids = t.add_album_artists(album_artist, "")
+            (album_id, new_album) = t.add_album(item.album.name,
+                                                album_artist_ids, "",
+                                                False, 0,
+                                                0, True)
+            # FIXME: Check this, could move this in add_album()
+            if new_album:
+                Lp().albums.set_synced(album_id, Type.NONE)
+
+            if persistent == DbPersistent.CHARTS:
+                genre_ids.append(Type.CHARTS)
+                new_artist_ids = []
+            else:
+                new_artist_ids = list(set(artist_ids) | set(album_artist_ids))
+
+            # Default genre id if missing
+            if not genre_ids:
+                genre_ids = t.add_genres("Web")
+
+            # Add track to db
+            track_id = Lp().tracks.add(item.name, uri, item.duration,
+                                       item.tracknumber, item.discnumber,
+                                       "", album_id,
+                                       item.year, 0,
+                                       0, 0, persistent)
+            t.update_track(track_id, artist_ids, genre_ids, item.mtime)
+            t.update_album(album_id, album_artist_ids,
+                           genre_ids, item.mtime, None)
+            sql.commit()
+
+        if persistent != DbPersistent.CHARTS:
+            for genre_id in genre_ids:
+                GLib.idle_add(Lp().scanner.emit,
+                              "genre-updated", genre_id, True)
+            for artist_id in new_artist_ids:
+                GLib.idle_add(Lp().scanner.emit,
+                              "artist-updated", artist_id, True)
+        return (album_id, track_id)
+
+    def __save_cover(self, item, album_id):
+        """
+            Save cover to store
+            @param item as SearchItem
+            @param album id as int
+        """
+        f = Lio.File.new_for_uri(item.cover)
+        (status, data, tag) = f.load_contents(None)
+        if status:
+            Lp().art.save_album_artwork(data, album_id)
diff --git a/lollypop/web_jgm90.py b/lollypop/web_jgm90.py
new file mode 100644
index 00000000..c67cf68c
--- /dev/null
+++ b/lollypop/web_jgm90.py
@@ -0,0 +1,108 @@
+# Copyright (c) 2014-2017 Cedric Bellegarde <cedric.bellegarde@adishatz.org>
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+# GNU General Public License for more details.
+# You should have received a copy of the GNU General Public License
+# along with this program. If not, see <http://www.gnu.org/licenses/>.
+
+from gi.repository import GLib
+
+import json
+
+from lollypop.utils import escape
+from lollypop.lio import Lio
+
+
+class WebJmg90:
+    """
+        Web Jmg90 helper
+    """
+
+    def get_uri_content(uri):
+        """
+            Get content uri
+            @param uri as str
+            @return content uri as str/None
+        """
+        try:
+            f = Lio.File.new_for_uri(uri)
+            (status, data, tag) = f.load_contents(None)
+            if status:
+                return data.decode("utf-8")
+        except IndexError:
+            pass
+        except Exception as e:
+            print("WebJmg90::get_uri_content():", e)
+        return None
+
+    def __init__(self):
+        """
+            Init helper
+        """
+        pass
+
+    def get_uri(self, item):
+        """
+            Item uri
+            @param item as SearchItem
+            @return uri as str
+        """
+        jmg_id = self.__get_jgm_id(item)
+        if jmg_id is None:
+            return ""
+        else:
+            return "http://app.jgm90.com/cmapi/download/%s/160000" % jmg_id
+
+#######################
+# PRIVATE             #
+#######################
+    def __get_jgm_id(self, item):
+        """
+            Get jmg id
+            @param item as SearchItem
+            @return jpg id as str
+        """
+        # Try to handle compilations (itunes one)
+        unwanted = ["variout artists", "multi-interprètes"]
+        if item.artists[0].lower() in unwanted:
+            if len(item.artists) > 1:
+                artist = item.artists[1]
+            else:
+                artist = ""
+        else:
+            artist = item.artists[0]
+        unescaped = "%s %s" % (artist,
+                               item.name)
+        for c in ["/", "?", "!"]:
+            if c in unescaped:
+                unescaped = unescaped.replace(c, " ")
+
+        search = GLib.uri_escape_string(unescaped,
+                                        "",
+                                        True)
+        try:
+            f = Lio.File.new_for_uri("http://app.jgm90.com/cmapi/search/"
+                                     "%s/1/10" % search)
+            (status, data, tag) = f.load_contents(None)
+            if status:
+                decode = json.loads(data.decode("utf-8"))
+                for song in decode["result"]["songs"]:
+                    try:
+                        song_artist = escape(
+                                            song["artists"][0]["name"].lower())
+                        if song_artist == escape(artist.lower()):
+                            return song["id"]
+                    except Exception as e:
+                        print("WebJmg90::__get_jmg_id():", e)
+        except IndexError:
+            pass
+        except KeyError:
+            pass
+        except Exception as e:
+            print("WebJmg90::__get_jmg_id():", e)
+        return None
diff --git a/lollypop/web_youtube.py b/lollypop/web_youtube.py
new file mode 100644
index 00000000..2ab840a9
--- /dev/null
+++ b/lollypop/web_youtube.py
@@ -0,0 +1,219 @@
+# Copyright (c) 2014-2017 Cedric Bellegarde <cedric.bellegarde@adishatz.org>
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+# GNU General Public License for more details.
+# You should have received a copy of the GNU General Public License
+# along with this program. If not, see <http://www.gnu.org/licenses/>.
+
+from gi.repository import GLib
+
+import json
+from re import sub
+
+from lollypop.define import Lp, GOOGLE_API_ID
+from lollypop.utils import escape
+from lollypop.lio import Lio
+
+
+class WebYouTube:
+    """
+        Web YoutTube helper
+    """
+
+    __BAD_SCORE = 1000000
+
+    def get_uri_content(uri):
+        """
+            Get content uri
+            @param uri as str
+            @return content uri as str/None
+        """
+        # Remove playlist args
+        uri = sub("list=.*", "", uri)
+        argv = ["youtube-dl", "-g", "-f", "bestaudio", uri, None]
+        (s, o, e, s) = GLib.spawn_sync(None,
+                                       argv,
+                                       None,
+                                       GLib.SpawnFlags.SEARCH_PATH,
+                                       None)
+        if o:
+            return o.decode("utf-8")
+        else:
+            if Lp().notify:
+                Lp().notify.send(e.decode("utf-8"))
+            print("WebYouTube::get_uri_content:", e.decode("utf-8"))
+            return None
+
+    def __init__(self):
+        """
+            Init helper
+        """
+        self.__fallback = False
+
+    def get_uri(self, item):
+        """
+            Item uri
+            @param item as SearchItem
+            @return uri as str
+        """
+        yid = self.__get_youtube_id(item)
+        if yid is None:
+            return ""
+        else:
+            return "https://www.youtube.com/watch?v=%s" % yid
+
+#######################
+# PRIVATE             #
+#######################
+    def __get_youtube_id(self, item):
+        """
+            Get youtube id
+            @param item as SearchItem
+            @return youtube id as str
+        """
+        if self.__fallback:
+            return self.__get_youtube_id_fallback(item)
+        # Try to handle compilations (itunes one)
+        unwanted = ["variout artists", "multi-interprètes"]
+        if item.artists[0].lower() in unwanted:
+            if len(item.artists) > 1:
+                artist = item.artists[1]
+            else:
+                artist = ""
+        else:
+            artist = item.artists[0]
+        unescaped = "%s %s" % (artist,
+                               item.name)
+        search = GLib.uri_escape_string(
+                            unescaped.replace(" ", "+"),
+                            None,
+                            True)
+        key = Lp().settings.get_value("cs-api-key").get_string()
+        try:
+            f = Lio.File.new_for_uri("https://www.googleapis.com/youtube/v3/"
+                                     "search?part=snippet&q=%s&"
+                                     "type=video&key=%s&cx=%s" % (
+                                                              search,
+                                                              key,
+                                                              GOOGLE_API_ID))
+            (status, data, tag) = f.load_contents(None)
+            if status:
+                decode = json.loads(data.decode("utf-8"))
+                dic = {}
+                best = self.__BAD_SCORE
+                for i in decode["items"]:
+                    score = self.__get_youtube_score(i["snippet"]["title"],
+                                                     item.name,
+                                                     artist,
+                                                     item.album.name)
+                    if score < best:
+                        best = score
+                    elif score == best:
+                        continue  # Keep first result
+                    dic[score] = i["id"]["videoId"]
+                # Return url from first dic item
+                if best == self.__BAD_SCORE:
+                    return None
+                else:
+                    return dic[best]
+        except Exception as e:
+            self.__fallback = True
+            return self.__get_youtube_id_fallback(item)
+        return None
+
+    def __get_youtube_score(self, page_title, title, artist, album):
+        """
+            Calculate youtube score
+            if page_title looks like (title, artist, album), score is lower
+            @return int
+        """
+        page_title = escape(page_title.lower(), [])
+        artist = escape(artist.lower(), [])
+        album = escape(album.lower(), [])
+        title = escape(title.lower(), [])
+        # YouTube page title should be at least as long as wanted title
+        if len(page_title) < len(title):
+            return self.__BAD_SCORE
+        # Remove common word for a valid track
+        page_title = page_title.replace("official", "")
+        page_title = page_title.replace("video", "")
+        page_title = page_title.replace("audio", "")
+        # Remove artist name
+        page_title = page_title.replace(artist, "")
+        # Remove album name
+        page_title = page_title.replace(album, "")
+        # Remove title
+        page_title = page_title.replace(title, "")
+        return len(page_title)
+
+    def __get_youtube_id_fallback(self, item):
+        """
+            Get youtube id (fallback)
+            @param item as SearchItem
+            @return youtube id as str
+        """
+        try:
+            from bs4 import BeautifulSoup
+        except:
+            print("$ sudo pip3 install beautifulsoup4")
+            return None
+        try:
+            # Try to handle compilations (itunes one)
+            unwanted = ["variout artists", "multi-interprètes"]
+            if item.artists[0].lower() in unwanted:
+                if len(item.artists) > 1:
+                    artist = item.artists[1]
+                else:
+                    artist = ""
+            else:
+                artist = item.artists[0]
+
+            unescaped = "%s %s" % (artist,
+                                   item.name)
+            search = GLib.uri_escape_string(
+                            unescaped.replace(" ", "+"),
+                            None,
+                            True)
+            f = Lio.File.new_for_uri("https://www.youtube.com/"
+                                     "results?search_query=%s" % search)
+            (status, data, tag) = f.load_contents(None)
+            if not status:
+                return None
+
+            html = data.decode("utf-8")
+            soup = BeautifulSoup(html, "html.parser")
+            ytems = []
+            for link in soup.findAll("a"):
+                href = link.get("href")
+                title = link.get("title")
+                if href is None or title is None:
+                    continue
+                if href.startswith("/watch?v="):
+                    href = href.replace("/watch?v=", "")
+                    ytems.append((href, title))
+            dic = {}
+            best = self.__BAD_SCORE
+            for (yid, title) in ytems:
+                score = self.__get_youtube_score(title,
+                                                 item.name,
+                                                 artist,
+                                                 item.album.name)
+                if score < best:
+                    best = score
+                elif score == best:
+                    continue  # Keep first result
+                dic[score] = yid
+            # Return url from first dic item
+            if best == self.__BAD_SCORE:
+                return None
+            else:
+                return dic[best]
+        except Exception as e:
+            print("WebYouTube::__get_youtube_id_fallback():", e)
+            self.__fallback = True
+        return None
diff --git a/lollypop/widgets_album.py b/lollypop/widgets_album.py
index 3445d101..05661728 100644
--- a/lollypop/widgets_album.py
+++ b/lollypop/widgets_album.py
@@ -368,6 +368,7 @@ class AlbumWidget(BaseWidget):
             self._overlay_orientation = Gtk.Orientation.VERTICAL
         else:
             self._overlay_orientation = Gtk.Orientation.HORIZONTAL
+        del surface
 
     def update_cover(self):
         """
@@ -384,6 +385,7 @@ class AlbumWidget(BaseWidget):
             self._overlay_orientation = Gtk.Orientation.VERTICAL
         else:
             self._overlay_orientation = Gtk.Orientation.HORIZONTAL
+        del surface
 
     def update_state(self):
         """
diff --git a/lollypop/widgets_album_detailed.py b/lollypop/widgets_album_detailed.py
index 68218cc6..0fa9768c 100644
--- a/lollypop/widgets_album_detailed.py
+++ b/lollypop/widgets_album_detailed.py
@@ -17,7 +17,7 @@ from gettext import gettext as _
 from lollypop.widgets_rating import RatingWidget
 from lollypop.widgets_loved import LovedWidget
 from lollypop.widgets_album import AlbumWidget
-from lollypop.pop_menu import AlbumMenu
+from lollypop.pop_menu import AlbumMenuPopover, AlbumMenu
 from lollypop.widgets_context import ContextWidget
 from lollypop.define import WindowSize, Loading
 from lollypop.widgets_track import TracksWidget, TrackRow
@@ -171,6 +171,9 @@ class AlbumDetailedWidget(Gtk.Bin, AlbumWidget):
         self.set_opacity(0)
 
         self._lock_overlay = False
+        if self._album.is_web and self._cover is not None:
+            self._cover.get_style_context().add_class(
+                                                "cover-frame-web")
 
     def update_playing_indicator(self):
         """
@@ -415,9 +418,21 @@ class AlbumDetailedWidget(Gtk.Bin, AlbumWidget):
         """
         ancestor = self.get_ancestor(Gtk.Popover)
         # Get album real genre ids (not contextual)
-        popover = Gtk.Popover.new_from_model(widget,
-                                             AlbumMenu(self._album,
-                                                       ancestor is not None))
+        genre_ids = Lp().albums.get_genre_ids(self._album.id)
+        if genre_ids and genre_ids[0] == Type.CHARTS:
+            popover = AlbumMenuPopover(self._album, None)
+            popover.set_relative_to(widget)
+            popover.set_position(Gtk.PositionType.BOTTOM)
+        elif self._album.is_web:
+            popover = AlbumMenuPopover(self._album,
+                                       AlbumMenu(self._album,
+                                                 ancestor is not None))
+            popover.set_relative_to(widget)
+        else:
+            popover = Gtk.Popover.new_from_model(
+                                            widget,
+                                            AlbumMenu(self._album,
+                                                      ancestor is not None))
         if ancestor is not None:
             Lp().window.view.show_popover(popover)
         else:
@@ -457,6 +472,16 @@ class AlbumDetailedWidget(Gtk.Bin, AlbumWidget):
         widget[disc_number].add(row)
         GLib.idle_add(self.__add_tracks, tracks, widget, disc_number, i + 1)
 
+    def __show_spinner(self, widget, track_id):
+        """
+            Show spinner for widget
+            @param widget as TracksWidget
+            @param track id as int
+        """
+        track = Track(track_id)
+        if track.is_web:
+            widget.show_spinner(track_id)
+
     def __on_size_allocate(self, widget, allocation):
         """
             Change box max/min children
@@ -580,7 +605,7 @@ class AlbumDetailedWidget(Gtk.Bin, AlbumWidget):
             if not Lp().player.is_party and not\
                     Lp().settings.get_enum("playback") == NextContext.STOP:
                 # If in artist view, reset album list
-                if self._filter_ids:
+                if self._filter_ids and Type.CHARTS not in self._filter_ids:
                     Lp().player.set_albums(track_id,
                                            self._filter_ids,
                                            self._album.genre_ids)
@@ -591,5 +616,6 @@ class AlbumDetailedWidget(Gtk.Bin, AlbumWidget):
             elif Lp().settings.get_enum("playback") == NextContext.STOP:
                 if not Lp().player.has_album(self._album):
                     Lp().player.clear_albums()
+            self.__show_spinner(widget, track_id)
             track = Track(track_id)
             Lp().player.load(track)
diff --git a/lollypop/widgets_album_simple.py b/lollypop/widgets_album_simple.py
index 7acaa7d8..cfed1e8c 100644
--- a/lollypop/widgets_album_simple.py
+++ b/lollypop/widgets_album_simple.py
@@ -16,8 +16,8 @@ from gettext import gettext as _
 from random import choice
 
 from lollypop.widgets_album import AlbumWidget
-from lollypop.pop_menu import AlbumMenu
-from lollypop.define import Lp, ArtSize, Shuffle
+from lollypop.pop_menu import AlbumMenu, AlbumMenuPopover
+from lollypop.define import Lp, ArtSize, Shuffle, Type
 
 
 class AlbumSimpleWidget(Gtk.FlowBoxChild, AlbumWidget):
@@ -105,6 +105,9 @@ class AlbumSimpleWidget(Gtk.FlowBoxChild, AlbumWidget):
         self._widget.connect("leave-notify-event", self._on_leave_notify)
         self._widget.connect("button-press-event", self.__on_button_press)
         self._lock_overlay = False
+        if self._album.is_web:
+            self._cover.get_style_context().add_class(
+                                                "cover-frame-web")
 
     def do_get_preferred_width(self):
         """
@@ -286,9 +289,18 @@ class AlbumSimpleWidget(Gtk.FlowBoxChild, AlbumWidget):
             @param event as Gdk.EventButton
         """
         if event.button != 1:
-            popover = Gtk.Popover.new_from_model(self._cover,
-                                                 AlbumMenu(self._album,
-                                                           True))
+            if self._album.genre_ids and\
+                    self._album.genre_ids[0] == Type.CHARTS:
+                popover = AlbumMenuPopover(self._album, None)
+                popover.set_relative_to(self._cover)
+            elif self._album.is_web:
+                popover = AlbumMenuPopover(self._album, AlbumMenu(self._album,
+                                                                  True))
+                popover.set_relative_to(self._cover)
+            else:
+                popover = Gtk.Popover.new_from_model(self._cover,
+                                                     AlbumMenu(self._album,
+                                                               True))
             popover.set_position(Gtk.PositionType.BOTTOM)
             rect = Gdk.Rectangle()
             rect.x = event.x
diff --git a/lollypop/widgets_context.py b/lollypop/widgets_context.py
index ec1536bd..53e3509a 100644
--- a/lollypop/widgets_context.py
+++ b/lollypop/widgets_context.py
@@ -17,7 +17,8 @@ from gettext import gettext as _
 from lollypop.widgets_rating import RatingWidget
 from lollypop.widgets_loved import LovedWidget
 from lollypop.objects import Album
-from lollypop.define import Lp
+from lollypop.sqlcursor import SqlCursor
+from lollypop.define import Lp, Type
 from lollypop.helper_dbus import DBusHelper
 
 
@@ -88,21 +89,42 @@ class ContextWidget(Gtk.Grid):
         self.__object = object
         self.__button = button
 
-        # Check portal for tag editor
-        dbus_helper = DBusHelper()
-        dbus_helper.call("CanLaunchTagEditor", None,
-                         self.__on_can_launch_tag_editor, None)
-        self.__edit = HoverWidget("document-properties-symbolic",
-                                  self.__edit_tags)
-        self.__edit.set_tooltip_text(_("Modify information"))
-        self.__edit.set_margin_end(10)
-        self.add(self.__edit)
-
-        playlist = HoverWidget("view-list-symbolic",
-                               self.__show_playlist_manager)
-        playlist.set_tooltip_text(_("Add to playlist"))
-        playlist.show()
-        self.add(playlist)
+        if self.__object.is_web:
+            if Type.CHARTS in self.__object.genre_ids:
+                if isinstance(self.__object, Album):
+                    save = HoverWidget("document-save-symbolic",
+                                       self.__save_object)
+                    save.set_tooltip_text(_("Save into collection"))
+                    save.set_margin_end(10)
+                    save.show()
+                    self.add(save)
+            else:
+                trash = HoverWidget("user-trash-symbolic",
+                                    self.__remove_object)
+                if isinstance(self.__object, Album):
+                    trash.set_tooltip_text(_("Remove album"))
+                else:
+                    trash.set_tooltip_text(_("Remove track"))
+                trash.set_margin_end(10)
+                trash.show()
+                self.add(trash)
+        else:
+            # Check portal for tag editor
+            dbus_helper = DBusHelper()
+            dbus_helper.call("CanLaunchTagEditor", None,
+                             self.__on_can_launch_tag_editor, None)
+            self.__edit = HoverWidget("document-properties-symbolic",
+                                      self.__edit_tags)
+            self.__edit.set_tooltip_text(_("Modify information"))
+            self.__edit.set_margin_end(10)
+            self.add(self.__edit)
+
+        if Type.CHARTS not in self.__object.genre_ids:
+            playlist = HoverWidget("view-list-symbolic",
+                                   self.__show_playlist_manager)
+            playlist.set_tooltip_text(_("Add to playlist"))
+            playlist.show()
+            self.add(playlist)
 
         if isinstance(self.__object, Album):
             if Lp().player.album_in_queue(self.__object):
@@ -116,26 +138,74 @@ class ContextWidget(Gtk.Grid):
             queue.show()
             self.add(queue)
         else:
-            rating = RatingWidget(object)
-            rating.set_margin_top(5)
-            rating.set_margin_end(10)
-            rating.set_margin_bottom(5)
-            rating.set_property("halign", Gtk.Align.END)
-            rating.set_property("hexpand", True)
-            rating.show()
-
-            loved = LovedWidget(object)
-            loved.set_margin_end(5)
-            loved.set_margin_top(5)
-            loved.set_margin_bottom(5)
-            loved.show()
-
-            self.add(rating)
-            self.add(loved)
+            if self.__object.is_web:
+                web = Gtk.LinkButton(self.__object.uri)
+                icon = Gtk.Image.new_from_icon_name("web-browser-symbolic",
+                                                    Gtk.IconSize.MENU)
+                web.set_image(icon)
+                web.get_style_context().add_class("no-padding")
+                web.set_margin_start(5)
+                web.set_tooltip_text(self.__object.uri)
+                web.show_all()
+                uri = "https://www.youtube.com/results?search_query=%s" %\
+                    (self.__object.artists[0] + " " + self.__object.name,)
+                search = Gtk.LinkButton(uri)
+                icon = Gtk.Image.new_from_icon_name("edit-find-symbolic",
+                                                    Gtk.IconSize.MENU)
+                search.set_image(icon)
+                search.get_style_context().add_class("no-padding")
+                search.set_tooltip_text(uri)
+                search.show_all()
+
+                self.add(web)
+                self.add(search)
+
+            if Type.CHARTS not in self.__object.genre_ids:
+                rating = RatingWidget(object)
+                rating.set_margin_top(5)
+                rating.set_margin_end(10)
+                rating.set_margin_bottom(5)
+                rating.set_property("halign", Gtk.Align.END)
+                rating.set_property("hexpand", True)
+                rating.show()
+
+                loved = LovedWidget(object)
+                loved.set_margin_end(5)
+                loved.set_margin_top(5)
+                loved.set_margin_bottom(5)
+                loved.show()
+
+                self.add(rating)
+                self.add(loved)
 
 #######################
 # PRIVATE             #
 #######################
+    def __save_object(self, args):
+        """
+            Save object
+            @param args as []
+        """
+        genre_id = Lp().genres.get_id("Web")
+        if genre_id is None:
+            genre_id = Lp().genres.add("Web")
+            Lp().scanner.emit("genre-updated", genre_id, True)
+        Lp().albums.del_genres(self.__object.id)
+        Lp().albums.add_genre(self.__object.id, genre_id)
+        for track_id in self.__object.track_ids:
+            Lp().tracks.del_genres(track_id)
+            Lp().tracks.add_genre(track_id, genre_id)
+        with SqlCursor(Lp().db) as sql:
+            sql.commit()
+        Lp().scanner.emit("album-updated", self.__object.id, True)
+
+    def __remove_object(self, args):
+        """
+            Remove object
+            @param args as []
+        """
+        self.__object.remove()
+
     def __edit_tags(self, args):
         """
             Run tags editor
diff --git a/lollypop/widgets_device.py b/lollypop/widgets_device.py
index 605dc8ff..54a85dd7 100644
--- a/lollypop/widgets_device.py
+++ b/lollypop/widgets_device.py
@@ -13,6 +13,7 @@
 from gi.repository import Gtk, GLib, Gio, GObject, Pango
 
 from gettext import gettext as _
+from threading import Thread
 
 from lollypop.sync_mtp import MtpSync
 from lollypop.sqlcursor import SqlCursor
@@ -21,7 +22,7 @@ from lollypop.selectionlist import SelectionList
 from lollypop.define import Lp, Type
 from lollypop.objects import Album
 from lollypop.loader import Loader
-from lollypop.helper_task import TaskHelper
+from lollypop.lio import Lio
 
 
 # FIXME This class should not inherit MtpSync
@@ -130,7 +131,7 @@ class DeviceManagerWidget(Gtk.Bin, MtpSync):
             @param uri as str
         """
         self._uri = uri
-        d = Gio.File.new_for_uri(uri)
+        d = Lio.File.new_for_uri(uri)
         try:
             if not d.query_exists():
                 d.make_directory_with_parents()
@@ -159,10 +160,12 @@ class DeviceManagerWidget(Gtk.Bin, MtpSync):
         else:
             playlists.append(Type.NONE)
 
-        helper = TaskHelper()
-        helper.run(self._sync, playlists,
-                   self.__switch_mp3.get_active(),
-                   self.__switch_normalize.get_active())
+        t = Thread(target=self._sync,
+                   args=(playlists,
+                         self.__switch_mp3.get_active(),
+                         self.__switch_normalize.get_active()))
+        t.daemon = True
+        t.start()
 
     def cancel_sync(self):
         """
@@ -231,7 +234,7 @@ class DeviceManagerWidget(Gtk.Bin, MtpSync):
         error_text = _("Unknown error while syncing,"
                        " try to reboot your device")
         try:
-            d = Gio.File.new_for_uri(self._uri)
+            d = Lio.File.new_for_uri(self._uri)
             info = d.query_filesystem_info("filesystem::free")
             free = info.get_attribute_as_string("filesystem::free")
 
@@ -322,7 +325,7 @@ class DeviceManagerWidget(Gtk.Bin, MtpSync):
             # Cache directory playlists
             if not files_list:
                 try:
-                    d = Gio.File.new_for_uri(self._uri)
+                    d = Lio.File.new_for_uri(self._uri)
                     infos = d.enumerate_children(
                                             "standard::name,standard::type",
                                             Gio.FileQueryInfoFlags.NONE,
diff --git a/lollypop/widgets_info.py b/lollypop/widgets_info.py
index 459ace09..c1971b42 100644
--- a/lollypop/widgets_info.py
+++ b/lollypop/widgets_info.py
@@ -12,6 +12,7 @@
 
 from gi.repository import Gtk, Gdk, GdkPixbuf, GLib, Gio
 
+from threading import Thread
 from gettext import gettext as _
 
 try:
@@ -21,7 +22,7 @@ except:
 from lollypop.define import Lp
 from lollypop.utils import get_network_available
 from lollypop.cache import InfoCache
-from lollypop.helper_task import TaskHelper
+from lollypop.lio import Lio
 
 
 class InfoContent(Gtk.Stack):
@@ -35,8 +36,8 @@ class InfoContent(Gtk.Stack):
         """
         Gtk.Stack.__init__(self)
         InfoCache.init()
-        self._helper = TaskHelper()
-        self._cancellable = Gio.Cancellable.new()
+        self._stop = False
+        self.__cancel = Gio.Cancellable.new()
         self._artist = ""
         self.set_transition_duration(500)
         self.set_transition_type(Gtk.StackTransitionType.CROSSFADE)
@@ -64,7 +65,8 @@ class InfoContent(Gtk.Stack):
         """
             Stop loading
         """
-        self._cancellable.cancel()
+        self._stop = True
+        self.__cancel.cancel()
 
     @property
     def artist(self):
@@ -73,24 +75,31 @@ class InfoContent(Gtk.Stack):
         """
         return self._artist
 
-    def set_content(self, prefix, content, image_uri, suffix):
+    def set_content(self, prefix, content, image_url, suffix):
         """
             populate widget with content
             @param prefix as str
             @param content as str
-            @param image uri as str
+            @param image url as str
             @param suffix as str
             @thread safe
         """
-        if image_uri is None:
-            self.__set_content(content, None)
-        else:
-            self._helper.load_uri_content(image_uri,
-                                          self._cancellable,
-                                          self.__on_uri_content,
-                                          prefix,
-                                          content,
-                                          suffix)
+        try:
+            data = None
+            stream = None
+            if content is not None:
+                if image_url is not None:
+                    f = Lio.File.new_for_uri(image_url)
+                    (status, data, tag) = f.load_contents(self.__cancel)
+                    if status:
+                        stream = Gio.MemoryInputStream.new_from_data(data,
+                                                                     None)
+                    else:
+                        data = None
+                InfoCache.add(prefix, content, data, suffix)
+            GLib.idle_add(self.__set_content, content, stream)
+        except Exception as e:
+            print("InfoContent::set_content: %s" % e)
 
 #######################
 # PROTECTED           #
@@ -106,9 +115,7 @@ class InfoContent(Gtk.Stack):
         if content is not None:
             stream = None
             if data is not None:
-                bytes = GLib.Bytes(data)
-                stream = Gio.MemoryInputStream.new_from_bytes(bytes)
-                bytes.unref()
+                stream = Gio.MemoryInputStream.new_from_data(data, None)
             GLib.idle_add(self.__set_content, content, stream)
             return True
         return False
@@ -154,7 +161,9 @@ class InfoContent(Gtk.Stack):
                     surface = Gdk.cairo_surface_create_from_pixbuf(pixbuf,
                                                                    scale,
                                                                    None)
+                    del pixbuf
                     self.__image.set_from_surface(surface)
+                    del surface
                     self.__image.show()
                 except:
                     pass
@@ -163,24 +172,6 @@ class InfoContent(Gtk.Stack):
             self.__on_not_found()
         self._spinner.stop()
 
-    def __on_uri_content(self, uri, status, uri_content,
-                         prefix, content, suffix):
-        """
-            Set image
-            @param uri as str
-            @param status as bool
-            @param uri_content as bytes  # The image
-            @param prefix as str
-            @param content as bytes
-            @param suffix as str
-        """
-        if status:
-            bytes = GLib.Bytes(uri_content)
-            stream = Gio.MemoryInputStream.new_from_bytes(bytes)
-            bytes.unref()
-            InfoCache.add(prefix, content, uri_content, suffix)
-            self.__set_content(content, stream)
-
 
 class WikipediaContent(InfoContent):
     """
@@ -210,10 +201,12 @@ class WikipediaContent(InfoContent):
         if not self._load_cache_content(artist, "wikipedia"):
             GLib.idle_add(self.set_visible_child_name, "spinner")
             self._spinner.start()
-            self._helper.run(self.__load_page_content, artist)
+            self.__load_page_content(artist)
         elif get_network_available():
-            self._helper.run(self.__get_menu, self._artist, self.__album,
-                             callback=(self.__on_get_menu,))
+            t = Thread(target=self.__setup_menu,
+                       args=(self._artist, self.__album))
+            t.daemon = True
+            t.start()
 
     def clear(self):
         """
@@ -231,8 +224,10 @@ class WikipediaContent(InfoContent):
         """
         InfoContent.__on_not_found(self)
         if get_network_available():
-            self._helper.run(self.__get_menu, self._artist, self.__album,
-                             callback=(self.__on_get_menu,))
+            t = Thread(target=self.__setup_menu,
+                       args=(self._artist, self.__album))
+            t.daemon = True
+            t.start()
 
 #######################
 # PRIVATE             #
@@ -246,22 +241,22 @@ class WikipediaContent(InfoContent):
         wp = Wikipedia()
         try:
             (url, content) = wp.get_page_infos(artist)
-        except Exception as e:
-            print("WikipediaContent::__load_page_content():", e)
+        except:
             url = content = None
-        if not self._cancellable.is_cancelled():
+        if not self._stop:
             InfoContent.set_content(self, self._artist, content,
                                     url, "wikipedia")
             if get_network_available():
-                self._helper.run(self.__get_menu, self._artist, self.__album,
-                                 callback=(self.__on_get_menu,))
+                t = Thread(target=self.__setup_menu,
+                           args=(self._artist, self.__album))
+                t.daemon = True
+                t.start()
 
-    def __get_menu(self, artist, album):
+    def __setup_menu(self, artist, album):
         """
             Setup menu for artist
             @param artist as str
             @param album as str
-            @return menu as [str]
         """
         wp = Wikipedia()
         result = wp.search(artist)
@@ -269,9 +264,9 @@ class WikipediaContent(InfoContent):
         cleaned = list(set(result))
         if artist in cleaned:
             cleaned.remove(artist)
-        return cleaned
+        GLib.idle_add(self.__setup_menu_strings, cleaned)
 
-    def __on_get_menu(self, strings):
+    def __setup_menu_strings(self, strings):
         """
             Setup a menu with strings
             @param strings as [str]
@@ -302,7 +297,9 @@ class WikipediaContent(InfoContent):
         InfoContent.clear(self)
         self.set_visible_child_name("spinner")
         self._spinner.start()
-        self._helper.run(self.__load_page_content, artist)
+        t = Thread(target=self.__load_page_content, args=(artist,))
+        t.daemon = True
+        t.start()
 
 
 class LastfmContent(InfoContent):
@@ -324,9 +321,9 @@ class LastfmContent(InfoContent):
         """
         self._artist = artist
         if not self._load_cache_content(artist, "lastfm"):
-            self.set_visible_child_name("spinner")
+            GLib.idle_add(self.set_visible_child_name, "spinner")
             self._spinner.start()
-            self._helper.run(self.__load_page_content, artist)
+            self.__load_page_content(artist)
 
 #######################
 # PRIVATE             #
@@ -338,8 +335,7 @@ class LastfmContent(InfoContent):
         """
         try:
             (url, content) = Lp().lastfm.get_artist_info(artist)
-        except Exception as e:
-            print("LastfmContent::__load_page_content():", e)
+        except:
             url = content = None
-        if not self._cancellable.is_cancelled():
+        if not self._stop:
             InfoContent.set_content(self, artist, content, url, "lastfm")
diff --git a/lollypop/widgets_playlist.py b/lollypop/widgets_playlist.py
index ee33b102..1f058c37 100644
--- a/lollypop/widgets_playlist.py
+++ b/lollypop/widgets_playlist.py
@@ -12,13 +12,13 @@
 
 from gi.repository import Gtk, GLib, Gdk, Pango, GObject
 
+from threading import Thread
 from gettext import gettext as _
 
 from lollypop.define import Lp, Type, WindowSize, Loading
 from lollypop.cellrenderer import CellRendererAlbum
 from lollypop.widgets_track import TracksWidget, PlaylistRow
 from lollypop.objects import Track
-from lollypop.helper_task import TaskHelper
 
 
 class PlaylistsWidget(Gtk.Grid):
@@ -311,6 +311,16 @@ class PlaylistsWidget(Gtk.Grid):
                 prev_album_id = Track(self.__tracks_left[-1]).album.id
         self.__tracks_widget_right.update_headers(prev_album_id)
 
+    def __show_spinner(self, widget, track_id):
+        """
+            Show spinner for widget
+            @param widget as TracksWidget
+            @param track id as int
+        """
+        track = Track(track_id)
+        if track.is_web:
+            widget.show_spinner(track_id)
+
     def __move_track(self, dst, src, up):
         """
             Move track from src to row
@@ -430,8 +440,9 @@ class PlaylistsWidget(Gtk.Grid):
         self.__update_headers()
         self.__tracks_widget_left.update_indexes(1)
         self.__tracks_widget_right.update_indexes(len(self.__tracks_left) + 1)
-        helper = TaskHelper()
-        helper.run(update_playlist)
+        t = Thread(target=update_playlist)
+        t.daemon = True
+        t.start()
 
     def __on_size_allocate(self, widget, allocation):
         """
@@ -474,6 +485,7 @@ class PlaylistsWidget(Gtk.Grid):
             else:
                 Lp().player.append_to_queue(track_id)
         else:
+            self.__show_spinner(widget, track_id)
             Lp().player.load(Track(track_id))
             if not Lp().player.is_party:
                 Lp().player.populate_user_playlist_by_tracks(
@@ -741,8 +753,9 @@ class PlaylistsManagerWidget(Gtk.Bin):
                 Lp().playlists.add_tracks(playlist_id, tracks)
             else:
                 Lp().playlists.remove_tracks(playlist_id, tracks)
-        helper = TaskHelper()
-        helper.run(set, playlist_id, add)
+        t = Thread(target=set, args=(playlist_id, add))
+        t.daemon = True
+        t.start()
 
     def __on_playlist_edited(self, widget, path, name):
         """
@@ -850,8 +863,9 @@ class PlaylistEditWidget(Gtk.Bin):
             populate view if needed
         """
         if len(self.__model) == 0:
-            helper = TaskHelper()
-            helper.run(self.__append_tracks, callback=(self.__append_track,))
+            t = Thread(target=self.__append_tracks)
+            t.daemon = True
+            t.start()
 
 #######################
 # PROTECTED           #
@@ -924,8 +938,10 @@ class PlaylistEditWidget(Gtk.Bin):
                     artist_name = ", ".join(track.artists)
                 else:
                     artist_name = ", ".join(track.album.artists)
-                helper = TaskHelper()
-                helper.run(Lp().lastfm.unlove, artist_name, track.name)
+                t = Thread(target=Lp().lastfm.unlove,
+                           args=(artist_name, track.name))
+                t.daemon = True
+                t.start()
             self.__model.remove(iterator)
         Lp().playlists.remove_tracks(self.__playlist_id, tracks)
         self.__infobar.hide()
@@ -945,7 +961,8 @@ class PlaylistEditWidget(Gtk.Bin):
         """
             Append tracks
         """
-        return Lp().playlists.get_track_ids(self.__playlist_id)
+        track_ids = Lp().playlists.get_track_ids(self.__playlist_id)
+        GLib.idle_add(self.__append_track, track_ids)
 
     def __append_track(self, track_ids):
         """
diff --git a/lollypop/widgets_radio.py b/lollypop/widgets_radio.py
index 76458954..6c6c844a 100644
--- a/lollypop/widgets_radio.py
+++ b/lollypop/widgets_radio.py
@@ -112,9 +112,8 @@ class RadioWidget(Gtk.FlowBoxChild, BaseWidget):
             Return preferred width
             @return (int, int)
         """
-        if self._widget is None:
-            return (0, 0)
-        width = Gtk.FlowBoxChild.do_get_preferred_width(self)[0]
+        # Padding: 3px, border: 1px + spacing
+        width = ArtSize.BIG + 16
         return (width, width)
 
     def set_name(self, name):
@@ -136,6 +135,7 @@ class RadioWidget(Gtk.FlowBoxChild, BaseWidget):
                     ArtSize.BIG,
                     self._cover.get_scale_factor())
         self._cover.set_from_surface(surface)
+        del surface
 
     def update_cover(self):
         """
@@ -148,6 +148,7 @@ class RadioWidget(Gtk.FlowBoxChild, BaseWidget):
                     ArtSize.BIG,
                     self._cover.get_scale_factor())
         self._cover.set_from_surface(surface)
+        del surface
 
     def update_state(self):
         """
diff --git a/lollypop/widgets_rating.py b/lollypop/widgets_rating.py
index a43c9630..f00528e4 100644
--- a/lollypop/widgets_rating.py
+++ b/lollypop/widgets_rating.py
@@ -12,8 +12,6 @@
 
 from gi.repository import Gtk, GLib
 
-from gettext import gettext as _
-
 from lollypop.objects import Track
 from lollypop.define import Lp, Type
 from lollypop.helper_dbus import DBusHelper
@@ -44,9 +42,6 @@ class RatingWidget(Gtk.Bin):
         self._stars.append(builder.get_object("star4"))
         self._on_leave_notify(None, None)
         self.add(builder.get_object("widget"))
-        if isinstance(object, Track):
-            play_count = object.popularity
-            self.set_tooltip_text(_("Song played %s times") % play_count)
 
 #######################
 # PROTECTED           #
@@ -81,8 +76,7 @@ class RatingWidget(Gtk.Bin):
         """
         user_rating = True
         stars = self.__object.get_rate()
-        # -1 for compatiblity with previous release
-        if stars in [0, -1]:
+        if stars == Type.NONE:
             stars = self.__object.get_popularity()
             user_rating = False
         if stars < 1:
@@ -144,8 +138,7 @@ class RatingWidget(Gtk.Bin):
         """
         if Lp().scanner.is_locked():
             return
-        # -1 for compatiblity with previous release
-        user_rating = self.__object.get_rate() not in [0, -1]
+        user_rating = self.__object.get_rate() != Type.NONE
         event_star = widget.get_children()[0]
         if event_star in self._stars:
             position = self._stars.index(event_star)
@@ -161,13 +154,16 @@ class RatingWidget(Gtk.Bin):
             self.__object.set_rate(pop)
         else:
             self.__object.set_popularity(pop)
+        if isinstance(self.__object, Track):
+            Lp().player.emit("rate-changed")
         # Save to tags if needed
         # FIXME We really need a radio object
         # FIXME We look to kid3-cli here!
         if Lp().settings.get_value("save-to-tags") and\
                 GLib.find_program_in_path("kid3-cli") is not None and\
                 isinstance(self.__object, Track) and\
-                self.__object.id >= 0:
+                self.__object.id >= 0 and\
+                not self.__object.is_web:
             if pop == 0:
                 value = 0
             elif pop == 1:
diff --git a/lollypop/widgets_track.py b/lollypop/widgets_track.py
index 3a07ca27..ec010d0f 100644
--- a/lollypop/widgets_track.py
+++ b/lollypop/widgets_track.py
@@ -92,7 +92,11 @@ class Row(Gtk.ListBoxRow):
         if self._artists_label is not None:
             self._grid.add(self._artists_label)
         self._grid.add(self._duration_label)
-        self._grid.add(self.__menu_button)
+        # TODO Remove this later
+        if Gtk.get_minor_version() > 16:
+            self._grid.add(self.__menu_button)
+        else:
+            self.connect("map", self.__on_map)
         self.add(self._row_widget)
         self.get_style_context().add_class("trackrow")
 
@@ -370,7 +374,10 @@ class PlaylistRow(Row):
         self.__cover = Gtk.Image()
         self.__cover.set_property("halign", Gtk.Align.CENTER)
         self.__cover.set_property("valign", Gtk.Align.CENTER)
-        self.__cover.get_style_context().add_class("small-cover-frame")
+        if self._track.is_web:
+            self.__cover.get_style_context().add_class("small-cover-web")
+        else:
+            self.__cover.get_style_context().add_class("small-cover-frame")
         self.__cover.set_no_show_all(True)
         # We force width with a Box
         box = Gtk.Box()
@@ -469,6 +476,7 @@ class PlaylistRow(Row):
                                         self.get_scale_factor())
             self.__cover.set_from_surface(surface)
             self.__cover.show()
+            del surface
             self.__header.show_all()
         else:
             self.__cover.set_tooltip_text("")
diff --git a/lollypop/widgets_web.py b/lollypop/widgets_web.py
index d907a04c..0181266d 100644
--- a/lollypop/widgets_web.py
+++ b/lollypop/widgets_web.py
@@ -57,7 +57,7 @@ class WebView(Gtk.Stack):
         settings.set_property("enable-plugins", False)
         settings.set_property("enable-fullscreen", False)
         settings.set_property("enable-html5-database", False)
-        settings.set_property("enable-html5-local-storage", True)
+        settings.set_property("enable-html5-local-storage", False)
         settings.set_property("enable-media-stream", False)
         settings.set_property("enable-mediasource", False)
         settings.set_property("enable-offline-web-application-cache", False)
diff --git a/lollypop/window.py b/lollypop/window.py
index 719e0e66..c5e301a3 100644
--- a/lollypop/window.py
+++ b/lollypop/window.py
@@ -12,11 +12,9 @@
 
 from gi.repository import Gtk, Gio, Gdk, GLib, Gst
 
-from gettext import gettext as _
 from lollypop.container import Container
 from lollypop.define import Lp, WindowSize
 from lollypop.toolbar import Toolbar
-from lollypop.helper_task import TaskHelper
 from lollypop.utils import is_unity, set_loved, is_loved
 
 
@@ -33,8 +31,6 @@ class Window(Gtk.ApplicationWindow, Container):
         self.__signal1 = None
         self.__signal2 = None
         self.__timeout = None
-        self.__mediakeys = None
-        self.__media_keys_busnames = []
         self.__was_maximized = False
         Gtk.ApplicationWindow.__init__(self,
                                        application=Lp(),
@@ -62,7 +58,6 @@ class Window(Gtk.ApplicationWindow, Container):
 
         self.__setup_content()
         self.setup_window()
-        # FIXME Remove this, handled by MPRIS in GNOME 3.26
         self.__setup_media_keys()
         self.__enabled_shortcuts = False
         self.enable_global_shortcuts(True)
@@ -275,80 +270,77 @@ class Window(Gtk.ApplicationWindow, Container):
            isinstance(position_setting[1], int):
             self.move(position_setting[0], position_setting[1])
 
-    # FIXME Remove this, handled by MPRIS in GNOME 3.26
     def __setup_media_keys(self):
         """
             Setup media player keys
         """
-        self.__media_keys_busnames = [
-            "org.gnome.SettingDaemon.MediaKeys",
-            "org.gnome.SettingsDaemon",
-        ]
-
-        self.__get_media_keys_proxy()
-
-    # FIXME Remove this, handled by MPRIS in GNOME 3.26
-    def __get_media_keys_proxy(self):
-        if self.__media_keys_busnames:
-            bus_name = self.__media_keys_busnames.pop(0)
-            try:
-                bus = Lp().get_dbus_connection()
-                Gio.DBusProxy.new(
-                    bus,
-                    Gio.DBusProxyFlags.DO_NOT_LOAD_PROPERTIES,
-                    None,
-                    bus_name,
-                    "/org/gnome/SettingsDaemon/MediaKeys",
-                    "org.gnome.SettingsDaemon.MediaKeys",
-                    None,
-                    self.__on_get_proxy,
-                )
-
-            except Exception as e:
-                print("Window::__setup_media_keys():", e)
-
-    # FIXME Remove this, handled by MPRIS in GNOME 3.26
+        try:
+            bus = Lp().get_dbus_connection()
+            Gio.DBusProxy.new(bus, Gio.DBusProxyFlags.NONE, None,
+                              "org.gnome.SettingsDaemon",
+                              "/org/gnome/SettingsDaemon/MediaKeys",
+                              "org.gnome.SettingsDaemon.MediaKeys", None,
+                              self.__on_get_proxy)
+        except Exception as e:
+            print("Window::__setup_media_keys():", e)
+
     def __on_get_proxy(self, source, result):
+        """
+            Grab keys
+            @param source as GObject.Object
+            @param result as Gio.AsyncResult
+        """
         try:
-            self.__mediakeys = source.new_finish(result)
+            proxy = source.new_finish(result)
+
+            proxy.call("GrabMediaPlayerKeys",
+                       GLib.Variant("(su)", ("Lollypop", 0)),
+                       Gio.DBusCallFlags.NONE,
+                       -1, None,
+                       self.__on_grab_media_player_keys, proxy)
         except Exception as e:
-            self.__mediakeys = None
             print("Window::__on_get_proxy():", e)
-        else:
-            if self.__mediakeys.get_name_owner():
-                self.__grab_media_keys()
-                self.__mediakeys.connect('g-signal', self.__mediakey_signal)
-            else:
-                self.__mediakeys = None
-                self.__get_media_keys_proxy()
-
-    # FIXME Remove this, handled by MPRIS in GNOME 3.26
-    def __grab_media_keys(self):
-        if not self.__mediakeys:
-            return
-        self.__mediakeys.call(
-            "GrabMediaPlayerKeys",
-            GLib.Variant("(su)", ("org.gnome.Lollypop", 0)),
-            Gio.DBusCallFlags.NONE,
-            -1,
-            None,
-            None,
-        )
-
-    def __mediakey_signal(self, proxy, sender, signal, param, userdata=None):
-        if signal != "MediaPlayerKeyPressed":
-            return
 
-        app, action = param.unpack()
-        if app == "org.gnome.Lollypop":
-            if action == "Play":
-                Lp().player.play_pause()
-            elif action == "Next":
-                Lp().player.next()
-            elif action == "Stop":
-                Lp().player.stop()
-            elif action == "Previous":
-                Lp().player.prev()
+    def __on_grab_media_player_keys(self, source, result, proxy):
+        """
+            Listen to key signal
+            @param source as GObject.Object
+            @param result as Gio.AsyncResult
+            @param proxy as Gio.DBusConnection
+        """
+        try:
+            bus = Lp().get_dbus_connection()
+            bus.signal_subscribe(None, "org.gnome.SettingsDaemon.MediaKeys",
+                                 "MediaPlayerKeyPressed",
+                                 "/org/gnome/SettingsDaemon/MediaKeys",
+                                 None,
+                                 Gio.DBusSignalFlags.NONE,
+                                 self.__on_signal,
+                                 None)
+        except Exception as e:
+            print("Window::__on_grab_media_player_keys():", e)
+
+    def __on_signal(self, connection, sender, path,
+                    interface, signal, params, data):
+        """
+            Do player actions in response to media key pressed
+            @param connection as Gio.DBusConnection
+            @param sender as str
+            @param path as str
+            @param interface as str
+            @param signal as str
+            @param parameters as GLib.Variant
+            @param data as object
+        """
+        response = params[1]
+        if "Play" in response:
+            Lp().player.play_pause()
+        elif "Stop" in response:
+            Lp().player.stop()
+        elif "Next" in response:
+            Lp().player.next()
+        elif "Previous" in response:
+            Lp().player.prev()
 
     def __setup_content(self):
         """
@@ -371,60 +363,10 @@ class Window(Gtk.ApplicationWindow, Container):
         self.add(vgrid)
         self.__main_stack.add_named(self._paned_main_list, "main")
         self.__main_stack.set_visible_child_name("main")
-        self.drag_dest_set(Gtk.DestDefaults.DROP | Gtk.DestDefaults.MOTION,
-                           [], Gdk.DragAction.MOVE)
-        self.drag_dest_add_text_targets()
-        self.connect("drag-data-received", self.__on_drag_data_received)
-        self.connect("drag-motion", self.__on_drag_motion)
-        self.connect("drag-leave", self.__on_drag_leave)
-
-    def __on_drag_data_received(self, widget, context, x, y, data, info, time):
-        """
-            Import values
-            @param widget as Gtk.Widget
-            @param context as Gdk.DragContext
-            @param x as int
-            @param y as int
-            @param data as Gtk.SelectionData
-            @param info as int
-            @param time as int
-        """
-        from lollypop.collectionimporter import CollectionImporter
-        importer = CollectionImporter()
-        uris = data.get_text().strip("\n").split("\r")
-        task_helper = TaskHelper()
-        task_helper.run(importer.add, uris, callback=(self.update_db,))
-
-    def __on_drag_motion(self, widget, context, x, y, time):
-        """
-            Add style
-            @param widget as Gtk.Widget
-            @param context as Gdk.DragContext
-            @param x as int
-            @param y as int
-            @param time as int
-        """
-        import_widget = self.__main_stack.get_child_by_name("import")
-        if import_widget is None:
-            import_widget = Gtk.Label()
-            import_widget.set_markup(_("<span size='xx-large'>"
-                                       "<b>Import music</b></span>"))
-            import_widget.show()
-            self.__main_stack.add_named(import_widget, "import")
-        self.__main_stack.set_visible_child_name("import")
-
-    def __on_drag_leave(self, widget, context, time):
-        """
-            Remove style
-            @param widget as Gtk.Widget
-            @param context as Gdk.DragContext
-            @param time as int
-        """
-        self.__main_stack.set_visible_child_name("main")
 
     def __on_hide(self, window):
         """
-            Remove callbacks we don"t want to save an invalid value on hide
+            Remove callbacks (we don"t want to save an invalid value on hide
             @param window as GtkApplicationWindow
         """
         if self.__signal1 is not None:
@@ -476,10 +418,6 @@ class Window(Gtk.ApplicationWindow, Container):
         Lp().settings.set_boolean("window-maximized",
                                   "GDK_WINDOW_STATE_MAXIMIZED" in
                                   event.new_window_state.value_names)
-        # FIXME Remove this, handled by MPRIS in GNOME 3.26
-        if event.changed_mask & Gdk.WindowState.FOCUSED and \
-           event.new_window_state & Gdk.WindowState.FOCUSED:
-            self.__grab_media_keys()
 
     def __on_destroyed_window(self, widget):
         """
diff --git a/meson.build b/meson.build
index 86c63a8c..47bf29a6 100644
--- a/meson.build
+++ b/meson.build
@@ -1,5 +1,5 @@
 project('lollypop',
-  version: '0.9.300',
+  version: '0.9.243',
   meson_version: '>= 0.40.0'
 )
 i18n = import('i18n')
@@ -18,9 +18,8 @@ dependency('gobject-introspection-1.0', version: '>=1.35.9')
 dependency('gtk+-3.0', version :'>=3.14')
 
 python_dir = join_paths(get_option('prefix'), python.sysconfig_path('purelib'))
-LIBEXEC_DIR = join_paths(get_option('prefix'), get_option('libexecdir'))
+LIBEXEC_DIR = join_paths(get_option('prefix'), 'libexec')
 DATA_DIR = join_paths(get_option('prefix'), get_option('datadir'), meson.project_name())
-bindir = join_paths(get_option('prefix'), get_option('bindir'))
 
 conf = configuration_data()
 conf.set('PACKAGE_URL', 'https://github.com/gnumdk/lollypop')
@@ -30,7 +29,6 @@ conf.set('PYTHON_DIR', python_dir)
 conf.set('PYTHON_EXEC_DIR', join_paths(get_option('prefix'), python.sysconfig_path('stdlib')))
 conf.set('libexecdir', LIBEXEC_DIR)
 conf.set('VERSION', meson.project_version())
-conf.set('PYTHON', python_bin.path())
 
 subdir('data')
 subproject('po')
@@ -42,24 +40,19 @@ install_subdir(
   install_dir: python_dir
 )
 
-install_subdir(
-  'thirdparty',
-  install_dir: join_paths(python_dir, 'lollypop')
-)
-
 message('Preparing init file')
 configure_file(
   input: 'lollypop.in',
   output: 'lollypop',
   configuration: conf,
-  install_dir: bindir
+  install_dir: 'bin'
 )
 
 configure_file(
   input: 'lollypop-cli.in',
   output: 'lollypop-cli',
   configuration: conf,
-  install_dir: bindir
+  install_dir: 'bin'
 )
 
 meson.add_install_script('meson_post_install.py')
diff --git a/run.sh b/run.sh
deleted file mode 100755
index 94d97291..00000000
--- a/run.sh
+++ /dev/null
@@ -1 +0,0 @@
-ninja -C build install && lollypop
diff --git a/save/mpd.py b/save/mpd.py
index a9eb4a50..d84cdccc 100644
--- a/save/mpd.py
+++ b/save/mpd.py
@@ -472,7 +472,7 @@ class MpdHandler(socketserver.StreamRequestHandler):
 
     def _listplaylistinfo(self, cmd_args):
         """
-            List playlist information
+            List playlist informations
             @syntax listplaylistinfo name
             @param args as str
             @return msg as str
@@ -750,7 +750,7 @@ class MpdHandler(socketserver.StreamRequestHandler):
 
     def _playlistid(self, cmd_args):
         """
-            Send information about current playlist
+            Send informations about current playlist
             @param playlistid
             @param args as str
             @return msg as str
@@ -773,7 +773,7 @@ class MpdHandler(socketserver.StreamRequestHandler):
 
     def _playlistinfo(self, cmd_args):
         """
-            Send information about current playlist
+            Send informations about current playlist
             @syntax playlistinfo [[pos]|[start:end]]
             @param playlistinfo
             @param args as str
diff --git a/search-provider/lollypop-sp.in b/search-provider/lollypop-sp.in
index 38ee8d45..9ec0e81b 100755
--- a/search-provider/lollypop-sp.in
+++ b/search-provider/lollypop-sp.in
@@ -1,4 +1,4 @@
-#!@PYTHON@
+#!/usr/bin/env python3
 # Copyright (c) 2014-2016 Cedric Bellegarde <cedric.bellegarde@adishatz.org>
 # This program is free software: you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
@@ -163,7 +163,7 @@ class SearchLollypopService(Server, Gio.Application):
                                     GLib.SpawnFlags.SEARCH_PATH |
                                     GLib.SpawnFlags.DO_NOT_REAP_CHILD, None)
         except Exception as e:
-            print("SearchLollypopService::ActivateResult():", e)
+            print(e)
 
     def GetInitialResultSet(self, terms):
         return self.__search(terms)
@@ -194,7 +194,7 @@ class SearchLollypopService(Server, Gio.Application):
                       'gicon': GLib.Variant('s', gicon) }
                 results.append(d)
         except Exception as e:
-            print("SearchLollypopService::GetResultMetas():", e)
+            print(e)
             return []
         return results
 
@@ -224,7 +224,7 @@ class SearchLollypopService(Server, Gio.Application):
             for (track_id, name) in self.tracks.search(search):
                 ids.append("t:"+str(track_id))
         except Exception as e:
-            print("SearchLollypopService::__search():", e)
+            print(e)
         return ids
 
 def main():
diff --git a/subprojects/po b/subprojects/po
index 2091b07d..dae1b58b 160000
--- a/subprojects/po
+++ b/subprojects/po
@@ -1 +1 @@
-Subproject commit 2091b07dfd099f5e127dbc5affbd2c8423850625
+Subproject commit dae1b58b1491e1fa83e1729ddffce32a39baef73
diff --git a/thirdparty/GioNotify.py b/thirdparty/GioNotify.py
deleted file mode 100644
index 7b19632f..00000000
--- a/thirdparty/GioNotify.py
+++ /dev/null
@@ -1,178 +0,0 @@
-#
-# Copyright (C) 2016 Jason Gray <jasonlevigray3@gmail.com>
-#
-# This program is free software: you can redistribute it and/or modify it
-# under the terms of the GNU General Public License version 3, as published
-# by the Free Software Foundation.
-#
-# This program is distributed in the hope that it will be useful, but
-# WITHOUT ANY WARRANTY; without even the implied warranties of
-# MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR
-# PURPOSE.  See the GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License along
-# with this program.  If not, see <http://www.gnu.org/licenses/>.
-# END LICENSE
-
-# See <https://developer.gnome.org/notification-spec/> and
-# <https://github.com/JasonLG1979/possibly-useful-scraps/wiki/GioNotify>
-# for documentation.
-
-from enum import Enum
-
-from gi.repository import GLib, GObject, Gio
-
-
-class GioNotify(Gio.DBusProxy):
-
-    # Notification Closed Reason Constants.
-    class Closed(Enum):
-        REASON_EXPIRED = 1
-        REASON_DISMISSED = 2
-        REASON_CLOSEMETHOD = 3
-        REASON_UNDEFINED = 4
-
-        @property
-        def explanation(self):
-            value = self.value
-            if value == 1:
-                return 'The notification expired.'
-            elif value == 2:
-                return 'The notification was dismissed by the user.'
-            elif value == 3:
-                return 'The notification was closed by a call to CloseNotification.'
-            elif value == 4:
-                return 'The notification was closed by undefined/reserved reasons.'
-
-    __gtype_name__ = 'GioNotify'
-    __gsignals__ = {
-        'action-invoked': (GObject.SignalFlags.RUN_FIRST, None, (GObject.TYPE_STRING,)),
-        'closed': (GObject.SignalFlags.RUN_FIRST, None, (GObject.TYPE_PYOBJECT,)),
-    }
-
-    def __init__(self, **kwargs):
-        super().__init__(
-            g_bus_type=Gio.BusType.SESSION,
-            g_interface_name='org.freedesktop.Notifications',
-            g_name='org.freedesktop.Notifications',
-            g_object_path='/org/freedesktop/Notifications',
-            **kwargs
-        )
-
-        self._app_name = ''
-        self._last_signal = None
-        self._caps = None
-        self._server_info = None
-        self._replace_id = 0
-        self._actions = []
-        self._callbacks = {}
-        self._hints = {}
-
-    @classmethod
-    def async_init(cls, app_name, callback):
-        def on_init_finish(self, result, data):
-            try:
-                self.init_finish(result)
-            except GLib.Error as e:
-                callback(None, None, None, error=e)
-            else:
-                if not self.get_name_owner():
-                    callback(None, None, None, error='Notification service is unowned')
-                else:
-                    self.call(
-                        'GetCapabilities',
-                        None,
-                        Gio.DBusCallFlags.NONE,
-                        -1,
-                        None,
-                        on_GetCapabilities_finish,
-                        None,
-                    )
-
-        def on_GetCapabilities_finish(self, result, data):
-            try:
-                caps = self.call_finish(result).unpack()[0]
-            except GLib.Error as e:
-                callback(None, None, None, error=e)
-            else:
-                self.call(
-                    'GetServerInformation',
-                    None,
-                    Gio.DBusCallFlags.NONE,
-                    -1,
-                    None,
-                    on_GetServerInformation_finish,
-                    caps,
-                )
-
-        def on_GetServerInformation_finish(self, result, caps):
-            try:
-                info = self.call_finish(result).unpack()
-            except GLib.Error as e:
-                callback(None, None, None, error=e)
-            else:
-                server_info = {
-                    'name': info[0],
-                    'vendor': info[1],
-                    'version': info[2],
-                    'spec_version': info[3],
-                }
-
-                self._app_name = app_name
-
-                callback(self, server_info, caps)
-
-        self = cls()
-        self.init_async(GLib.PRIORITY_DEFAULT, None, on_init_finish, None)
-
-    def show_new(self, summary, body, icon):
-        def on_Notify_finish(self, result):
-            self._replace_id = self.call_finish(result).unpack()[0]
-
-        args = GLib.Variant('(susssasa{sv}i)', (self._app_name, self._replace_id,
-                                                icon, summary, body,
-                                                self._actions, self._hints, -1))
-
-        self.call(
-            'Notify',
-            args,
-            Gio.DBusCallFlags.NONE,
-            -1,
-            None,
-            on_Notify_finish,
-        )
-
-    def add_action(self, action_id, label, callback):
-        self._actions += [action_id, label]
-        self._callbacks[action_id] = callback
-
-    def clear_actions(self):
-        self._actions.clear()
-        self._callbacks.clear()
-
-    def set_hint(self, key, value):
-        if value is None:
-            if key in self._hints:
-                del self._hints[key]
-        else:
-            self._hints[key] = value
-
-    def do_g_signal(self, sender_name, signal_name, parameters):
-        id, signal_value = parameters.unpack()
-        # We only care about our notifications.
-        if id != self._replace_id:
-            return
-        # In GNOME Shell at least this stops multiple
-        # redundant 'NotificationClosed' signals from being emmitted.
-        if (id, signal_name) == self._last_signal:
-            return
-        self._last_signal = id, signal_name
-        if signal_name == 'ActionInvoked':
-            self.emit('action-invoked', signal_value)
-            self._callbacks[signal_value]()
-        else:
-            self.emit('closed', GioNotify.Closed(signal_value))
-
-    def __getattr__(self, name):
-        # PyGObject ships an override that breaks our usage.
-        return object.__getattr__(self, name)
